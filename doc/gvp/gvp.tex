\documentclass[preprint,12pt,authoryear]{elsarticle}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{capt-of}
\usepackage{float}

\usepackage{newunicodechar}
\usepackage{pmboxdraw}

\usepackage{natbib}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}

\usepackage{booktabs}
\usepackage{enumitem}
\RequirePackage{fancyvrb}
\usepackage{anyfontsize}
\usepackage{pifont}

\usepackage{fancyvrb}
\usepackage{mathtools}
\usepackage{qtree}
\usepackage[shortcuts]{extdash}


\newenvironment{Snippet}{\Verbatim[samepage=true,fontsize=\small]}{\endVerbatim}

\DefineVerbatimEnvironment{verbatim}{Verbatim}{samepage=true}
\newunicodechar{─}{\textSFx}
\newunicodechar{│}{\textSFxi}
\newunicodechar{╭}{\textSFi}
\newunicodechar{╰}{\textSFii}
\newunicodechar{╮}{\textSFiii}
\newunicodechar{╯}{\textSFiv}
\newunicodechar{═}{\textSFxliii}
\newunicodechar{║}{\textSFxxiv}
\newunicodechar{╔}{\textSFxxxix}
\newunicodechar{╚}{\textSFxxxviii}
\newunicodechar{╗}{\textSFxxv}
\newunicodechar{╝}{\textSFxxvi}
\newunicodechar{◀}{$\triangleleft$}
\newunicodechar{▶}{$\triangleright$}
\newunicodechar{▮}{\hspace{0.6pt}|\hspace{0.6pt}}

\journal{Information and Software Technology}

\begin{document}

\begin{frontmatter}

\title{Towards a Common General Visual Programming System}

\author[1]{Maciej Godek}
\address[1]{Gdynia Maritime University, Department of Computer Science, Gdynia, Poland}
\ead{m.godek@wi.umg.edu.pl}

\begin{abstract}
We investigate the apparent failure of visual programming to gain
mainstream adoption and introduce the notion of General Visual
Programming (GVP) as a framework for analyzing such systems. We review
several existing approaches in light of this definition and identify
which of them can be considered GVP systems, discussing their
limitations that go beyond visual representation itself. We also
consider some desirable features of programming environments that are
not necessarily related to GVP. Finally, we present the design and
implementation of GRASP, our experimental GVP system, highlighting
major design decisions, lessons learned, and future directions.
\end{abstract}

\begin{keyword}
Visual programming \sep Programming environments \sep Human-computer
interaction \sep Program comprehension \sep Cognitive dimensions \sep
Programming tools
\end{keyword}

\end{frontmatter}

\section{Introduction}

Visual programming systems appear to improve the efficiency of certain
aspects of programming, compared to their textual counterparts. This
advantage is followed by deserved popularity in certain niches - for
example, the makers of the educational visual programming environment
\textit{Scratch} claim to have over 135 million registered users (as of 2025).

The success of visual programming environments isn't limited to
education, though. Some other important domains, such as dynamic
system modeling, game scripting or instrument control and industrial
automation, are also covered by visual programming tools like
Simulink, Unreal Engine Blueprint or LabVIEW.

However, when we look at programming language popularity rankings, it
turns out that they are firmly dominated by programming languages that
are based on text. According to the programming language popularity
ranking maintained by TIOBE (as of 2025), the most popular visual
programming language included in the ranking is Scratch, whose peak
popularity between 2009 and 2025 was around 1.8\% (by comparison, the
peak popularity of the highest-ranked language, Python, is over
25\%). And although the methodology employed by TIOBE is not
infallible, it seems to reflect the everyday experiences of
programmers: that in the professional setup, the dominance of textual
programming languages is unquestionable.

It is not hard to see why this is the case: text is, overall, a very
elastic medium to impose strict meaning on, and the digital
infrastructure -- from teletypes to e-mail communication to copy-paste
clipboard operations -- is very well adapted to working with textual
data, and the ubiquitous ASCII encoding maps very nicely to computer
memory.

On the other hand, even the most popular visual programming systems
seem to struggle to escape from their usually shallow niches to the
realm of ``general programming, where everything is possible''.  It is
rather uncommon for such systems to be used for the development of
themselves (while using text-based tools, such as Emacs or Eclipse,
for their own development, is completely unsurprising, and being
\textit{self-hosted} is a very desirable property for compilers).

Moreover, if we take a closer look at e.g. the way Scratch stores its
programs, it turns out that underneath they are just ZIP archives
containing a bunch of files storing objects serialized to the textual
JSON format.

\section{General Visual Programming}

Perhaps the fundamental problem with the framing of visual programming
systems is that researchers often try to draw a sharp boundary between
them and textual programming languages (even despite the fact that
text itself is a visual medium), rather than trying to see the
continuity between them. Even programs written in the most classic
text-based environments can be presented and explored visually as
icons embedded in a hierarchical structure, using tools such as
Windows Explorer, Apple Finder or a programming environment's file
browser - only such visualizations are typically shallow and do not
expose the underlying semantic structure of programs.

Visual programming systems have proven their worth only in very
specific and very limited domains. In this regard, they resemble
\textit{Domain-Specific Languages} (DSLs), which are specialized
languages of limited applicability, suitable for describing problems
that appear in particular subject domains.

The approach to system construction based on designing DSLs is
sometimes called \textit{Language-Oriented Programming}.

Probably the most striking example of Language-Oriented Programming is
the Racket programming system, developed by the PLT group, although
even the UNIX operating system, whose components are known to employ
parser generators such as TMG or YACC, is also sometimes considered a
Language-Oriented Programming environment.

In this paper, we propose the notion of \textit{General Visual
  Programming}, which is an extension to Language-Oriented Programming
that allows to define arbitrary Domain-Specific Notations/ways of
interaction for programmers to work with their code.

General Visual Programming requires a specialized editor in order to
be carried out. The editor needs to have the following properties:

\begin{itemize}
\item it needs to provide a base system, in which programmers can
  define specialized editors
\item it needs to be able to embed the specialized editors within
  the base system
\item the state of the specialized editors needs to be persisted along
  with the representation of code expressed in the base system
\end{itemize}

In principle, we cannot exclude the possibility of programmers
designing their own Domain-Specific Notations, whose domain would be
the design of particular Domain-Specific Notations. On the contrary,
we consider this endeavour to be an interesting research direction in
its own right.

The generality of General Visual Programming does not mean that the
editor should be able to support every existing programming
language. It only means that it should support at least one
general-purpose programming language as its base system.

\section{Evaluating existing General Visual Programming systems}

A number of existing programming systems can be analyzed through the
lens of General Visual Programming.

\subsection{Dr Racket}

Dr Racket is an Integrated Development Environment designed for the
Racket programming system with programming education in mind.  The
Racket itself is derived from the Scheme programming language, so it
inherits its \textit{heavily-parenthesized} syntax of
\textit{s-expressions}. However, its \texttt{\#lang} extension
mechanism allows to support languages with arbitrary syntaxes.

In addition to being an academic research vehicle, it comes
with a rich educational curriculum.

The IDE is implemented in the Racket programming language, which
extends the Scheme language with its idiosyncratic Object-Oriented
Programming system.

The Dr Racket environment is focused mainly on textual languages,
although it is quite unique in that it allows to use images (inserted
to the editor via system clipboard or file browser).  However,
inserting an image to the program source makes the whole program
incomprehensible to people who use plain text editors.

The images (called \textit{snips}) can be assigned to variables
and passed to functions. They can also be used to create other
images via means of composition provided by the language.

The Racket programming environment provides a very interesting purely
functional model of creating interactive applications called
\textit{Big Bang}. Racket has also been used as the core of an
artistic live-programming environment called Fluxus.

Despite very good support for graphics, and being an explicitly
language-oriented programming system, Dr Racket alone cannot be
considered a General Visual Programming system. However, the design of
the environment is fundamentally open to visual extensions, and there
is a line of research from the Racket community which tries to adapt
it as such.

It is going to be described in the next section.

\subsection{Interactive Visual Syntax}

The paper \textit{Adding Interactive Syntax to Textual Code} describes
a principled attempt to turn dr Racket into a General Visual
Programming environment. It dwells on the notion of code execution
phases that were specified for the Racket programming language (which
allows for arbitrary code execution during compilation time for the
purpose of macro expansion) - so for example, there is a syntax
expansion phase, as well as runtime execution phase.

The \textit{Interactive Syntax} project adds another conceptual
phase, namely \textit{editing} phase.

It provides special forms analogous to \texttt{define-syntax} and
\texttt{begin-for-syntax} (which are used for writing code that runs
at macro-expansion time), namely \texttt{define-interactive-syntax}
and \texttt{begin-for-interactive-syntax}, which are evaluated at edit
time.

The \texttt{define-interactive-syntax} form requires to define
the following methods:

\begin{itemize}
\item \texttt{draw}, which specifies how the visual interactive
  extension should be rendered
  
\item \texttt{on-event}, which specifies how the visual interactive
  extension should react to user input

\item an \textit{elaborator}, which specifies how the visual extension
  should be converted back to the textual form

\item code that handles \textit{persistent storage} of the
  visualization (the motivational example provided in the paper is
  that ``user may expect the text [of some particular visual
    extension] to be saved in the file, but not the current cursor
  position. However, the user does expect the cursor to remain in
  place while the document is open''.).
  
\end{itemize}

The implementation of the \texttt{define-interactiv-syntax} form
leans on Racket's Object-Orientation system.

Taken as a whole, the language extension also adds two buttons to the
Dr Racket IDE - \textit{Insert Editor} and \textit{Update
  Editors}. The latter forces the program text to be re-scanned in
search of the occurrences of the \texttt{\#editor} special form.

Unfortunately, even though using interactive syntax doesn't spoil the
textuality of the source code the same way that using snips with
images does, the \texttt{\#editor} special form is mostly illegible to
humans. 

The \textit{Interactive Syntax} project has been further elaborated in
Leif Andersen's PhD thesis, \textit{Adding Visual and
  Interactive-Syntax to Textual Programs}. In the course of her work,
she concluded that the Racket's GUI library (used, among other things,
to build the Dr Racket IDE) isn't flexible enough to be reused inside
the domain-specific editors.

For this reason, Andersen decided to build a browser-based IDE that
would implement interactive visual syntax for ClojureScript, where the
common GUI elements could be reused between the visual extensions and
the application being developed.

This new approach also improved the textual representation of
domain-specific editors, and the visual interface allows to present
the textual variant of code alongside the visual one.

The treatment of visual extensions as ``syntax'', in the tradition of
Lisp-based systems, is probably the most general approach to General
Visual Programming conceivable: it is imaginable to not only use
domain-specific editors for representing data structures, but also the
code itself: it's possible to imagine control-flow or data-flow
editors that would expand directly to code that implements the same
logic.

Even though the examples presented in Andersen's work do not reflect
this generality entirely, they exemplify the following roles of
interactive syntax:
\begin{itemize}
\item data literals
\item templates (from which literals can be constructed)
\item algebraic matcher's patterns
\item binding forms
\end{itemize}

The Racket-based realization of interactive syntax presented an
implementation of Tsuro board game, Okasaki's algorithm of Red-Black
Tree balancing, Form Builders and a few other \textit{worked examples}
(most of which are available in the evaluation artifacts
repository\footnote{\url{https://github.com/LeifAndersen/artifact2020}}).

In particular, the Red-Black Tree example is notable for using visual
extensions not only in regular code position, but also as patterns
inside a pattern matching form, and templates for constructing a tree.

The ClojureScript realization of interactive syntax goes even further
in this regard -- it provides a new special form to the language
called \texttt{g/let}, that can be used with a particular type of
visual extensions that are desugared to an expression that can be
placed inside of ClojureScript's core binding form, so that the
components of the visual extension can serve to name certain
components of some structure that is represented by that extension.

The exact definition of the \texttt{g/let} form in ClojureScript
is the following:

\begin{Snippet}
  (defmacro (g/let [diagram] & body)
    `(clojure.core/let ~(macroexpand diagram) ~@body))
\end{Snippet}

The ClojureScript realization of visual interactive syntax also
includes the Tsuro example, Form Builders, Bézier curve mid-point
computation, a hexagonal board for the game Settlers of Catan (serving
as a demonstration of the synergy that interactive syntax can get from
running in the web browser environment, as it is based on a
third-party JavaScript library) and a few others.

Andersen also build a ``bridge'' to be able to execute Racket code
from within the browser by connecting the browser-based IDE to a
language server via websockets. While she called this solution ``a
Frankenstein monster'', she admitted that one user, Cameron Moy,
managed to use it to build visual syntax for PLT Redex programming
language build in the Racket system.

\subsection{Hazel}

Hazel is a browser-based programming environment and a functional
programming language developed to explore the notion of \textit{typed
  holes}, where even incomplete programs can be properly typed, and
thus various software services such as autocomplete can be implemented
in a principled manner. Unlike Andersen, who focuses on adding visual
extensions to textual code, the makers of Hazel decided to create a
structure editor in such a way that the experience of using it
resembles textual programming -- but at every moment of program
development the program code is properly structured (even if it
contains holes).

Being of functional programming descent, Hazel is implemented in
ReasonML, which is a functional language that can be compiled to
native code and to JavaScript. The code expressed in Hazel is
internally serialized to s-expressions, although this representation
is never exposed to users, and could easily be changed to any other
format.

Hazel comes with the concept of \textit{live literals} or
\textit{livelits}, which are user-defined visual extensions.

A live literal can be defined for some specific (concrete) type using
the \texttt{livelit} keyword, and it consists of two type definitions
(\texttt{Model} and \texttt{Action}) and four function definitions
(\texttt{init}, \texttt{update}, \texttt{view} and \texttt{expand}).

Livelit definition is therefore very similar to the
\texttt{define-interactive-syntax} form, where the \texttt{update}
function corresponds to the \texttt{on-event} method, the
\texttt{view} function corresponds to the \texttt{draw} method, and
the \texttt{expand} function corresponds to the elaborator.

The creators of Hazel claim that the live literals are
\textit{compositional}, in the sense that it is possible to embed
livelits inside other livelits. The compositionality of livelits
is achieved via a mechanism called \textit{splices}.

The paper which describes livelits presents the following examples: a
slider, a color picker, a data frame (which is like a spreadsheet
embedded in the source code), a specialized widget for adjusting
school grade cutoffs, and another specialized widget for adjusting
image filters (brightess and contrast).

However, the examination of the code
base\footnote{\url{https://github.com/hazelgrove/hazel/blob/livelits/src/hazelcore/livelits/BuiltinLivelits.re}}
shows that most of those livelits are built-in (implemented in
ReasonML), and therefore do not use the extension system described in
the paper. The only example of a livelit defined and used from Hazel
itself available for
examination\footnote{\url{https://hazel.org/build/livelits/}} is a
variant of slider named \texttt{\$slidy}. However, the exact extension
method differs from the one described in the paper, and it resorts to
techniques invoking inline JavaScript code.

Despite those apparent shortcommings, Hazel is a fine example of a
General Visual Programming system. Although on the surface it may not
seem as general as Interactive Visual Syntax, because it only allows
to specify visual representations of literals (rather than arbitrary
pieces of program), there is nothining in principle that should
prevent programmers from e.g. defining literals that would express
control flow diagrams, and then write interpreters for those diagrams
(on the other hand, it isn't obvious whether it would be possible to
use livelits as either patterns or templates in a pattern matching
construct, as it was the case in Andersen's Red-Black Tree balancing
example).

\subsection{Polytope}

Another General Programming System to consider is Polytope, developed
by Elliot Evans. Polytope is an editor written in TypeScript and
running in the browser, which also provides fundamental architecture.
The current implementation of Polytope is designed to work with
JavaScript code.  It comes with a bunch of specialized editors,
including editors for directed and undirected graphs, math formulas,
markdown and music staff. It should in principle be possible for
developers to define their own editors and use them post hoc, but
there is no distinct automatic mechanism for scanning and installing
definitons in the system.

Editors are implemented by subclassing \texttt{EditorElement} (which
itself is a subclass of browser's builtin \texttt{HTMLElement}),
implementing \texttt{render} method (for displaying editor content on
its HTML canvas or in another DOM element) and \texttt{toOutput}
method (for converting an element to text, usually a JSON string) and
registering event listeners (using the JavaScript's
\texttt{addEventListener} method) and adding a parser/recognizer to
the global \texttt{builders} array. Moreover, to make the extension
available via a drop-down context menu, one needs to add an entry to
the global \texttt{dropdownItems} array.

There is no universal mechanism that would connect the names of
extensions with their occurrences within the source code.  Instead,
the particular extensions tend to check whether a considered object
has some particular structure. For example, if a JSON object
contains the keys \texttt{nodes} and \texttt{edges} (and their values
are arrays), it will be considered a graph, and if it's an array and
its first element is an object containing the key \texttt{note}, it
will be considered music staff.

Polytope is also capable of typesetting certain mathematical
functions, for example \texttt{exp(x, y)} can be rendered as
$\mathtt{x}^\mathtt{y}$, and \texttt{div(x, y)} -- as
$\frac{\mathtt{x}}{\mathtt{y}}$. However, this feature doesn't appear
automatically when the code is typed in the textual editor.  It
appears either when the code is loaded from a file, or when the
user invokes the math editor.

The decision to base Polytope directly on the browser is a very
interesting one, because it allows to reuse a lot of the existing
infrastructure. On the other hand, it narrows the design space and
constrains implementation techniques.

The editors in Polytope resemble Hazel's livelits in many ways, but
the assumption to base the environment around text, rather than
structure editing, is very much like in the Interactive Visual Syntax
project.

\subsection{JetBrains MPS}

JetBrains MPS (MetaProgramming System) is a \textit{language
  workbench} for creating domain-specific languages developed by the
same company that develops and maintains numerous Integrated
Development Environments for various programming systems, including
IntelliJ IDEA, Android Studio, CLion, PyCharm, PhpStorm, WebStorm and
a few others. The company also created the Kotlin programming
language. Despite being developed by a commercial software company,
MPS is available with full source code under the Apache License.  It
runs on the JVM platform.

MPS is a complex piece of software. One of its important components is
a highly tweakable \textit{projectional editor} which is able to
operate directly on the edited program's abstract syntax tree, even
though the process is made to resemble working with text. For this
purpose, the editor has to understand the structure of a programming
language that it's supposed to edit.

MPS uses a non-standard terminology to refer to the units from which a
program is built (and it might therefore be misleading). In
particular, the thing referred to as \textit{a concept} in MPS roughly
corresponds to \textit{a grammar production rule} in the theory of
parsing. However, MPS operates directly on the programs' abstract
syntax trees (which are called \textit{models} in MPS terminology), so
it is not a parser-based system -- and in this sense MPS's concept can
be thought of as \textit{a syntax tree node type}.

The \texttt{.mps} files that are stored on the disk represent syntax
trees that are serialized to a variant of the \texttt{XML} format,
although they are neither readable to nor editable by humans (which
probably defies the purpose of using XML for storing data).

The definition of a language in MPS consists of a few
\textit{aspects}.  The most fundamental type is the language's
\textit{structure}, which consists of a set of language units (the
aforementioned \textit{concepts} or \textit{syntax tree node
  types}). In other words, the \textit{structure} aspect of a language
definition determines which components are available in the language,
and how they can be composed.

Another -- closely related -- aspect in MPS is called
\textit{constraints}, and this one -- in turn -- limits the way
certain components can be composed.

A crucial -- and very interesting -- aspect of a language defined in
MPS is called \textit{editor}. It specifies the way the particular
types of program nodes ought to be rendered. A seemingly fundamental
language decision -- whether to use a Python-style indentation-based
syntax, or a Java-style syntax based on curly braces -- in MPS is only
a matter of tweaking an editor.

Editors in MPS don't necessarily have to be textual -- according to
the documentation, it is also possible to define editors that render
arbitary graphics (based on the Java Swing API). This feature makes
MPS a fine example of a General Visual Programming system.

That being said, the current set of practices focuses mainly on
textual editors or some of their blends (such as decision tables and
other tabular data, or matrix literals). A notable exception includes
state machine definitions in the \textit{mbeddr} project.

Two aspects that are related to editing the language in the structure
editor are called \textit{actions} (for elaborating the syntax tree)
and \textit{intents} (for transforming sub-trees of the syntax tree).

Another aspect of language definition is \textit{generator}, which
determines how certain nodes are transformed to the constructs of some
simpler language. In the LISP tradition, this step is usually called
\textit{macro expansion}. This aspect concerns transforming trees in
one language into trees in another language. But in order to be able
to integrate with some existing ecosystems, MPS also provides the
notion of \textit{base languages}, which can be transformed to text
(the most typical base language of MPS
\texttt{jetbrains.mps.baseLanguage}, which is in 1-1 correspondence to
Java, and from which Java text can be generated).

The remaining aspects of language definition in MPS have to do with
interfacing with its dataflow analysis engine and typechecking system.

At the moment of writing this, MPS has been available as a
corporate-backed open source project for over 15 years. Yet despite a
few documented use cases, its success seems very limited. This is
probably due to the fact that the system itself seems to have a very
steep learning curve, and it doesn't integrate well with existing
tools (e.g. it is possible to use the \texttt{diff} tool on
\texttt{.mps} files, but the information one can get from reading such
diffs is close to none).

\subsection{Glamorous Toolkit}

Glamorous Toolkit is a \textit{moldable} development environment
developed by Tudor Girba and his associates. It is based on Pharo
Smalltalk and it inherits many properties that are typically
associated with Smalltalk-based systems. In particular, it comes with
a bunch of tools that can be used to explore the running system, and
the system itself is organized as a multitude of communicating
objects.

The key point of Glamorous Toolkit is the idea of \textit{moldable
  development}, which is somewhat similar to language-oriented
programming, but instead of designing domain-specific languages, it
encourages developers to develop domain-specific (micro) tools for
particular problems.

In the context of Glamorous Toolkit, this practice is often
implemented by means of creating specialized \textit{views}
for particular objects.

Glamorous Toolkit is an open-source software, and its development
model has been based on a private software consultancy that
specializes in analyzing and improving existing legacy systems.  Its
developers also seem to put considerable effort into making the tool
accessible to wider audiences. Yet it seems that despite all the
effort, the learning curve remains fairly steep.

Glamorous Toolkit provides very good support for custom (user-defined)
graphics rendering, and it comes with a very large number of examples.

However, in its current form, it can hardly be considered a General
Visual Programming environment. The language used for program
development -- Smalltalk -- is inherently textual, and there seems to
be no attempts among the developers of Glamorous Toolkit to experiment
with program representation; the main purpose of the custom
visualizations is system analysis. This is not to say that Glamorous
Toolkit wouldn't be the right substrate to develop a General Visual
Programming system. Conversely, projects such as eToys or Sandblocks
have proven that Smalltalk-based systems offer a lot of flexibility
when it comes to non-standard program representations.

\section{Some Desirable Features of a Programming System}

In the previous section, we have presented a number of existing
systems, and we have analyzed them through the lens of General
Visual Programming. The systems ranged from research prototypes to
industrial-grade programming environments, but the systems which were
more focused on visual programming tended to be more immature and less
useful than the ones that treated programming more textually.

This is not to say that general visual programming is inherently worse
or less capable than textual programming. But there is no doubt that
purely textual programming has an uncomparably more established
tradition. Moreover, text is both a very simple and a very elastic
medium, and generic tools for working with text (including text
editors, but also operating system facilities such as a system
clipboard which allows to perform copy and paste operations between
different applications) often turn out to be sufficient for developing
computer programs.

Lastly, the paradigm which treats programs as \textit{plain text} is
agnostic of any particular authoring tools, so it decouples the act of
creating a program from the act of interpreting it, effectively
allowing programmers to use the editors of their preference. It also
allows to develop programming language tools independently of editors.

In this sense, textual programming is on a privileged position
compared to visual programming. It seems that, if we are to develop a
compelling visual programming system (that could compete with the
existing textual programming systems), we somehow need to tackle the
question of universality: is it possible to construct a generic hybrid
visual-textual editor that would support a wide variety of programming
languages, the same way a generic text editor supports them?

The alternative is to focus on a single specific programming language
(possibly even to design a new one), which may simplify the work
greatly, but it can also limit the potential audience of the system.
It may also not be immediately clear how to choose the particular
programming language -- by the merits of popularity, expected demand
for visual extensions, personal preference, simplicity of
implementation or some other reason.

Of course, the intrinsic qualities of a software tool are not enough
to determine its success -- even the highest-quality seed needs the
right soil in which to take root and flourish.

The single most important feature a system must possess in order to
become successful is that it addresses the actual needs of its
potential users.  It must also be simple enough to be understandable,
or at least it must provide some learning path that eventually leads
to sufficient understanding.

\section{The GRASP System}

This section describes our experience with the development of the
GRASP programming system.

Like most systems described in this paper, GRASP is a General Visual
Programming system. It is neither a text-based system (such as
Polytope or Visual Interactive Syntax) nor a projectional editor (such
as MPS or Hazel). Instead, it is a generic structure editor for
s-expressions, so while it allows to create malformed programs (or
rather structures), the textual representation of those structures
necessarily consists of balanced parentheses.

GRASP renders a balanced pair of parentheses as a \textit{box}.

For example, a definition of the \textit{factorial} function that uses
the GRASP representation is depicted on figure
\ref{fig:grasp-factorial}.

\begin{figure}[h]
  \begin{Snippet}
    ╭        ╭     ╮                      ╮
    │ define │ ! n │                      │
    │        ╰     ╯                      │
    │   ╭    ╭        ╮                 ╮ │
    │   │ if │ <= n 1 │                 │ │
    │   │    ╰        ╯                 │ │
    │   │                               │ │
    │   │       1                       │ │
    │   │                               │ │
    │   │       ╭     ╭   ╭       ╮ ╮ ╮ │ │
    │   │       │ * n │ ! │ - n 1 │ │ │ │ │
    ╰   ╰       ╰     ╰   ╰       ╯ ╯ ╯ ╯ ╯
  \end{Snippet}
  \caption{A definition of the factorial function rendered using the
    GRASP representation}
  \label{fig:grasp-factorial}
\end{figure}

Boxes in GRASP occupy a rectangular area. The left parentheses can be
used to drag a given box out of the document and move it elsewhere,
and the right parentheses are used to resize the box.

GRASP also allows users to define \textit{extensions} or \textit{magic
  boxes}, which are an instances of the domain-specific editors
discussed in the earlier section.

\subsection{A Brief History}

At the time of writing, GRASP has gone through four iterations of
development. The first prototype was written in Racket, and its
development was preceded by announcing the \textit{Draggable Rectangle
  Challenge} on the Quora social
network\footnote{\url{https://eidolon-language.quora.com/Draggable-rectangle-challenge-part-I-the-introduction}},
which consisted of three tasks:

\begin{quote}
  \begin{enumerate}
  \item Implement a program where I can freely drag rectangles
    around the screen
  \item Implement a program like above, but the rectangles can also
    contain draggable rectangles (and so on)
  \item Implement a program where I can move the rectangles from
    one “inner rectangle” into some others.
  \end{enumerate}
\end{quote}

The purpose of the challenge was to explore alternative designs for
the fundamental mechanics of GRASP editing.

The key tension was between functional programming (immutable) designs
and object-oriented (mutable) ones.

\subsection{The first prototype (2018-2019)}

The initial implementation in the Racket programming
language\footnote{the source code of the prototype and the solutions
to the Draggable Rectangle Challenge is available at
\url{https://github.com/panicz/sracket}} explored the technique of
\textit{mix-in composition}, where all the features were implemented
as mix-ins. This technique, however, turned out to be problematic for
several reasons. First, because we relied on the identity of closures
of the Scheme programming language as the identity of objects, and
each mix-in created a new closure, the identity of objects was
inconsistent. This could probably be improved by modeling object
identity more explicitly. The other problem was that each mix-in
created a new layer of indirection in runtime, which -- without a
proper language support -- incurred a  performance penalty.

While the prototype allowed to perform drag\&drop and resize the
boxes, its editing capabilities were very limited. It was not possible
to open or save files, and while the elements could be removed, the
only kind of elements that could be added were boxes (using the
\texttt{[} key).

The content of the screen could not be scrolled, and the support for
keyboard editing was very limited. Nevertheless, even though both the
content of the edited document and the list of supported visual
extensions were hard-coded in the editor, the extension mechanism was
already designed to be convenient for users: it simply required to
create an object that is able to understand the messages
\texttt{as-image} (which is supposed to produce a Racket image) and
\texttt{as-expression} (which is supposed to return a list that stands
for an expression).

Registering an extension is based on a special form called
\texttt{define-interaction}.

The entire prototype consisted of less than 1,000 lines of code, and it
came with a built-in extension for rendering directed graphs (see figure
\ref{fig:digraph-extension} for its definition).

\begin{figure}[!h]
  \begin{Snippet}
(define (Graph neighbour-list)
  (let* ((vertices (in-circle
		    (map (lambda (`(,node . ,neigbours))
			   (Vertex node))
			 neighbour-list)))
	 (collection (Collection vertices)))
      (lambda message
	(match message
  \end{Snippet}
  \begin{Snippet}
	  (`(as-image)
	   (let ((image (collection 'as-image)))
	     (for `(,source (,node . ,neighbours)) in (zip vertices
							   neighbour-list)
	       (for neighbour in neighbours
		 (let ((target (find (lambda (v)
				       (eq? neighbour (v 'as-expression)))
				     vertices)))
		   (draw-edge! source target image))))
	     image))
  \end{Snippet}
  \begin{Snippet}
	  (`(as-expression)
	   `(digraph . ,neighbour-list))
  \end{Snippet}
  \begin{Snippet}
	  (`(acquire-element!)
	   #false)
  \end{Snippet}
  \begin{Snippet}
	  (_
	   (apply collection message))))))
  \end{Snippet}
  \begin{Snippet}
(define-interaction (digraph . neighbour-list)
  (Graph neighbour-list))
  \end{Snippet}
  \caption{A code that defines the \texttt{digraph} extension in the
    first prototype of GRASP}
  \label{fig:digraph-extension}
\end{figure}

\begin{figure}[!h]
  \centering%
  \includegraphics[width=.45\linewidth]{images/digraph-1}\hfill%
  \includegraphics[width=.45\linewidth]{images/digraph-2}\hfill%
  \caption{A structural representation of a directed graph and its
    visualization in the first prototype of GRASP}
  \label{fig:digraph-example}
\end{figure}

\subsection{The second prototype (2020)}

The choice for the Racket programming language certainly had its
merits. Racket fits naturally with an editor that operates on
s-expressions, and it is maintained for the three major platforms
(Windows, Linux and OS X).

However, Racket also has its limitations. In particular, it does not
support the creation of applications for the Android platform, which
was of our interest, because despite being very popular, it offered
very few programming tools, most of which were scaled-down versions of
desktop applications, and none of which tried to explore the specifics
of programming that would involve small multi-touch screens.

For this reason, we decided to develop the next prototype in Java,
which has been the recommended language for Android development since
the inception of the platform.

After doing some research, we made the decision to not only develop
the next version of GRASP for Android, but also -- to develop it
\textbf{on} an Android phone, using the Termux environment. There were
several reasons for this decision. This mode of development provided a
faster feedback and better continuity than having to attach a phone to
a desktop computer after each modification of the application. But
more importantly, the constraints of the environment were forcing us
to think about the editor features that would ease the development
in the future.

The second prototype was rather clumsy. It used a box representation
that was similar to the one employed by the Racket prototype.  It did
support drag\&drop and the creation of boxes, as well as some
rudimentary text editing, but it wasn't able to persist the created
structures, nor to evaluate them. Despite having some placeholders in
the user interface, it did not support any extensions.

The main purpose was to check whether editing code on a multi-touch
screen was feasible. The most valuable artefact from the development
is a three-minute video showing the construction of a definition of
the factorial
function\footnote{\url{https://www.youtube.com/watch?v=BmZ39IfElzg}}. The
fact that it took entire 3 minutes was rather alarming (entering the
same text using a traditional keyboard takes about 15 seconds, or
about 30 seconds using an on-screen keyboard on a phone), but it also
encouraged to look for optimizations in the editing process.

Despite being in some ways less capable than the first prototype, the
second prototype consisted of almost 3,000 lines of Java code.

\subsection{The third prototype (2020-2021)}

Architecture-wise, the second prototype turned out to be a dead-end.

The third prototype was planned in stages, to allow to backtrack on
bad design decisions without having to start everything over.

The initial stages for the third prototype featured splitting the
screen into multiple panes, as is possible in such editors as Emacs,
vi or Blender 3D. The documents visible inside the panes could be
scrolled and rotated (using pinch-zoom).

It was also the first prototype of GRASP which supported loading and
saving s-expression text files (but the supported syntax only included
lists and atoms -- no strings, vectors or comments). The editing
capabilities were also vastly improved: the left parenthesis was now
responsible for dragging expressions, and the rigth one -- for
resizing them. The expressions could be removed by throwing them
quickly off the screen, and the attempt to throw the right parenthesis
off the screen would cause the content of the list to be spliced into
its parent.

Double-tapping on the left parenthesis would make a copy of the entire
expression.

The third prototype of GRASP also supported several gestures: drawing
a rectangle would add a new box to the document, drawing a spike would
cause an expression under the spike to be evaluated, and drawing an
underscore gesture (down-right-up) would add a new atom. Adding a new
atom involved opening a floating text editor window. This prototype
was also capable of reading the data from the phone's inertial
measurement unit, and use the act of shaking to invoke code
reindentation.

The support for those gestures allowed to reduce the time required to
define the \texttt{factorial} function from 3 minutes to about 1
minute after some training, and (according to the only known user, who
also happens to be the developer of GRASP) the editor itself was
fairly pleasant to use, even despite lack of support for operations
such as \textit{undo} or \textit{copy-paste}.

The document representation could be described by the following
Haskell-like type definitions:

\begin{Snippet}
Bit = Atom following_space: (Space|null) 
           text: String
    | Box following_space: (Space|null) 
          first_interline: Interline;
\end{Snippet}
\begin{Snippet}
Space = Space width: float 
              following_bit: (Bit|null);
\end{Snippet}
\begin{Snippet}
Interline = Interline height: float 
                      following_line: (Line|null);
\end{Snippet}
\begin{Snippet}
Line = Line first_space: (Space|null) 
            next_interline: (Interline|null);
\end{Snippet}

so \texttt{Bit} was an interface with two implementations --
\texttt{Box} and \texttt{Atom}, where a \texttt{Box} consisted of
\texttt{Interline}s interleaved with \texttt{Line}s, and each line
consisted of \texttt{Bit}s interleaved with \texttt{Space}s.

Because of its complexity, this representation wasn't particularly
pleasant to work with, and it was hard to integrate it with any
extension system (although with some effort we managed to create an
extension which allowed to present a green rectangle).

Despite having been planned in stages, the third prototype had some
flaws that were hard to backtrack. After integrating with the Kawa
evaluator, the build times became much longer and were often using up
all the available memory. Moreover, the third prototype only ran on
Android, and testing changes required the full build-install cycle.

But the bigger issue was that the Java programming language, which was
used for the development, wasn't based on s-expressions, which meant
that there would be no option to use GRASP for the further development
of GRASP. This reason alone was a sufficient to drop almost 10,000
lines of Java code and start over.

\subsection{The fourth prototype (2022-2025)}

The fourth prototype was started after a a successful attempt to use
Kawa Scheme to create an application for Android. This time the editor
was supposed to run (and developed) not only on Android, but also on
the PC. An additional requirement was to be able to run various pieces
of code without rebuilding the entire project. Since GRASP is a visual
and interactive application and the support for graphics in
terminal-based environments is rather poor, we decided that we also
want to be able to render the ``graphical'' output of GRASP to text,
and also to run the entire GRASP appliaction in a terminal emulator.

This decision had significant implications on the architecture of
GRASP. All the rendering in the system is performed via the interface
called \texttt{Painter}. The code base of GRASP provides four
implementations of that interface: one for Android, one for desktop,
one for string rendering, and one for terminal rendering (the latter
two share a lot of their implementations).

Excluding tests, there are three main entry points to the fourth
prototype of GRASP -- one for the desktop client, one for the terminal
client and one for the Android client. Each of those clients also uses
different code for handling events, but from the perspective of GRASP
itself, these are unified.

The decision to make GRASP available on PCs was not driven solely by
the desire to make testing more efficient. Just as an Android device
is a natural environment for developing applications intended to run
on Android and make use of multi-touch interaction, a PC is the
natural platform for building applications controlled primarily via
keyboard and mouse. One of the design goals for the fourth prototype
of GRASP was to make keyboard editing at least as efficient as in a
traditional text editor -- and we believe that this goal has largely
been achieved.

A few words need to be said about the Kawa language. Before developing
the fourth prototype of GRASP, we had over ten years of experience with
programming in Scheme (mainly Guile and Racket), and while we were
mostly enthusiastic about the language, we felt that it lacked some
important features, such as type signatures or robust record type
definitions.

To our surprise, the Kawa language either addressed these deficiencies
(by providing optional type annotations for variables and procedure
return values) or offered mechanisms that allowed us to address them
ourselves. It also came with very good JVM interoperability and a
mostly tasteful (in our opinion) set of syntactic extensions.

On the other hand, during development we encountered several issues
stemming from the behaviour of the Kawa compiler. The available
community support was limited, mainly because Kawa is no longer
actively maintained, which made it difficult to resolve problems or
obtain clarifications.

Overall, despite these problems, we feel that the combination of
Java-like, strongly typed, interface-based object orientation with the
syntactic flexibility and minimalism of the Scheme programming
language was an excellent match for building the GRASP project.

The fourth prototype of GRASP consists of over 30,000 lines of code,
making it a fairly large project. It is also the most feature-complete
version to date -- it supports most of the syntax of the Scheme
programming language, including not only lists and atoms, but also
strings and three kinds of comments defined by the Scheme language
specification (line comments, block comments and expression comments).

It also includes a working mechanism for writing extensions (described
in more detail in the next section), and at the time of writing the
repository contains over a dozen different extensions.

The representation of documents in the fourth prototype of GRASP is
somewhat convoluted: initially we tried to design an editor that would
operate directly on Lisp's \texttt{cons}-cells. This was a bit
challenging, because the document must also store information about
whitespaces and comments. We therefore decided to use a bunch of hash
tables, called \texttt{pre-head-space}, \texttt{post-head-space},
\texttt{pre-tail-space} and \texttt{post-tail-space} to store the
whitespace/comment information. There was an additional table called
\texttt{dotted?}, which contained \texttt{\#true} if a given cell was
written down using the dotted-pair notation. Moreover, since there is
only one instance of an empty list in most Lisps (including Kawa), but
lists can also contain whitespace and comments, we created additional
pair of tables -- \texttt{null-head-space} and
\texttt{null-tail-space} -- to store the whitespace/comment
information if, respectively, a head or a tail of the cell contained a
reference to the empty list.

The use of hash tables turned out to be problematic, because the
developers of Kawa decided to override their \texttt{cons}-cell's
\texttt{equals} method with Scheme's \texttt{equal?}-like semantics,
which meant that all the occurrences of lists that contain the same
elements would be considered the same list.

If we wanted to stick with our design, we therefore either had to
patch the Kawa compiler, or to subclass its class that represents
\texttt{cons}-cells. After running some experiments, we chose the
latter option.

The complication grew even further when we started implementing atom
editing capability. There were a few problems that we were facing:
\begin{itemize}
\item since most atoms (e.g. symbols or numbers) are immutable, every
  keystroke would have to generate a new object
\item during editing, certain kinds of atoms would need to be
  transformed into other kinds of atoms (e.g. numbers into symbols)
\item certain atoms can have many different representations (for
  example, numbers can be represented as decimal, hexadecimal, octal
  or binary)
\end{itemize}

For this reason, we decided to create a mutable proxy called
\texttt{Atom}, that could stand for various different atoms (symbols,
numbers, boolean). This change had an unfortunate impact, though: the
parts of the document could no longer be evaluated.

To account for that, we introduced a \textit{parameter object} called
\texttt{cell-access-mode}, which could take one of the two enum values
(\texttt{Editing} or \texttt{Evaluating}) and we further modified our
subclass of Kawa's \texttt{cons}-cell class: its \texttt{getCar} and
\texttt{getCdr} methods checked the value of the parameter, and either
returned the \texttt{Atom}, or the result of invoking \texttt{read} on
the \texttt{Atom}'s content.

In addition to lists and atoms, GRASP provides a distinct
representation of string objects. Strings are deliberately rendered
using a monospace font, so that the textual representation of GRASP
objects can also be viewed from the graphical clients.

Another kind of primitive objects that can be present in the document
are spaces. A \texttt{Space} object holds a list of integer numbers
that represent single spaces. Two consecutive integers in the list
represent a line break. The list can also contain \texttt{Comment}
objects, which can be of three types: \texttt{LineComment},
\texttt{BlockComment} and \texttt{ExpressionComment}. A
\texttt{LineComment} also induces a line break.

The fourth prototype also features clipboard integration\footnote{For
some reason, the terminal client is unable to connect to the system
clipboard, but it maintains its internal clipboard.} and the
\textit{undo} mechanism.

\textit{Undo} is implemented by tracking invertible operations on the
mutable document object, and it effectively maintains a history tree
(although currently it isn't visualized in any way, and the part of
the undone history becomes inaccessible after new operations).

The implementation of keyboard editing requires tracking cursor
position. This task is fairly easy for regular text editors, where
a cursor can be represented by a line number and a column number,
but it becomes more complicated for a structure editor.

In the case of GRASP, a cursor is represented by a sequence of indices.


\section{The Architecture of GRASP}



\section{GRASP as an Application Platform}

\section{Discussion and Future Work}


\end{document}
