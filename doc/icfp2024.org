#+LATEX_CLASS: sigplan

#+LATEX_HEADER: \usepackage{newunicodechar}
#+LATEX_HEADER: \usepackage{pmboxdraw}
#+LATEX_HEADER: \RequirePackage{fancyvrb}
#+LATEX_HEADER: \usepackage{anyfontsize}
#+LATEX_HEADER: \usepackage{pifont}
#+LATEX_HEADER: \usepackage{fancyvrb}

#+LATEX_HEADER: \newenvironment{Snippet}{\Verbatim[samepage=true]}{\endVerbatim}

#+LATEX_HEADER: \newunicodechar{─}{\textSFx}
#+LATEX_HEADER: \newunicodechar{│}{\textSFxi}
#+LATEX_HEADER: \newunicodechar{╭}{\textSFi}
#+LATEX_HEADER: \newunicodechar{╰}{\textSFii}
#+LATEX_HEADER: \newunicodechar{╮}{\textSFiii}
#+LATEX_HEADER: \newunicodechar{╯}{\textSFiv}

#+LATEX_HEADER: \newunicodechar{═}{\textSFxliii}
#+LATEX_HEADER: \newunicodechar{║}{\textSFxxiv}
#+LATEX_HEADER: \newunicodechar{╔}{\textSFxxxix}
#+LATEX_HEADER: \newunicodechar{╚}{\textSFxxxviii}
#+LATEX_HEADER: \newunicodechar{╗}{\textSFxxv}
#+LATEX_HEADER: \newunicodechar{╝}{\textSFxxvi}

#+LATEX_HEADER: \newunicodechar{◀}{$\triangleleft$}
#+LATEX_HEADER: \newunicodechar{▶}{$\triangleright$}
#+LATEX_HEADER: \newunicodechar{▮}{\hspace{0.23pt}|\hspace{0.23pt}}


The direct purpose of this paper - as its title suggests - is to
present how the visual evaluator extension is implemented in the GRASP
programming system.

The indirect purpose of it is to provide a tutorial around the design
of GRASP, and in particular - of the architecture of its extension
mechanism.

Neither GRASP nor its extension mechanisms are, at the moment of
writing this paper, final or complete, and we are certain that some
details of the solutions described in here will change even before the
first release.

What will not change, though, is the set of problems that need to be
solved in order to build a system with capabilities similar to those
of GRASP.

We believe that these problems might be of interest of the Scheme
community.


* An Implementation of a Visual Stepper in the GRASP programming system
  
GRASP is a nascent graphical development environment for the Scheme
programming language, consisting of a structural editor for
S-expressions, as well as an extension mechanism, which allows to
display various forms of data in an arbitrary visual way.

This paper presents an implementation of one such extension, namely --
a visual stepper, which allows to observe single step reductions of a
purely functional subset of Scheme.

GRASP is currently available as a desktop appication, a terminal
applcation and an Android application.  It is implemented in Kawa,
which is a dialect of Scheme that runs on the JVM and provides
extensions for interfacing with JVM classes and libraries, including
the capability of defining new classes, as well as optional checked
monomorphic type annotations.

** The fundamental ideas of GRASP

At the core of GRASP, there are two fundamental ideas.  The first one
is that it is a generic editor for S-expressions that uses boxes to
represent a pair of matching parentheses.

Here's what the definition of the factorial function looks like
in a GRASP representation:

#+ATTR_LATEX :environment Snippet
#+BEGIN_EXAMPLE
╭        ╭     ╮                      ╮
│ define │ ! n │                      │
│        ╰     ╯                      │
│   ╭    ╭        ╮                 ╮ │
│   │ if │ <= n 1 │                 │ │
│   │    ╰        ╯                 │ │
│   │                               │ │
│   │       1                       │ │
│   │                               │ │
│   │       ╭     ╭   ╭       ╮ ╮ ╮ │ │
│   │       │ * n │ ! │ - n 1 │ │ │ │ │
╰   ╰       ╰     ╰   ╰       ╯ ╯ ╯ ╯ ╯
#+END_EXAMPLE

The boxes can be manipulated using pointing interfaces such as touch
screens and computer mice. The left edge of a regular box can be used for
moving it to another place in the document (or some other document),
removing it, or copying (by using two presses). The right edge
of the box can be used for resizing it or splicing its contents
into its parent box.

The second idea is that the user is allowed to define custom boxes
that can be rendered and interacted with in special ways: a box then
receives an area in the document to which it can draw; it also
receives touch events from that area, and if the custom box is in the
focus, it additionally receives events from the keyboard.

Currently, GRASP contains a few predefined extensions. Among them,
there is the extension called Button, which reacts to presses by
invoking the thunk that was provided during its creation.

A button is created in a GRASP document by inputting an expression
such as

#+BEGIN_SRC scheme
(Button label: "Press me" 
        action: (lambda () (WARN "Button pressed")))
#+END_SRC

and then either "enchanting" the expression (by pressing the
tab key with the text cursor positioned on either opening
on closing parenthesis of the outermost expression),
or evaluating it (by pressing ctrl+e).

The result will be displayed roughly like this:

#+BEGIN_SRC
╭──────────╮
│ Press me │
╰──────────╯
#+END_SRC

And of course, when the button is pressed, it causes the text
"Button pressed" to be displayed somewhere.

** The Visual Stepper Extension

Another built-in extension is the visual stepper, which
is the subject of this work. It can be instantiated by typing
=(Stepper <expression>)= into the editor, and pressing the tab
key on the closing parenthesis of the expression. For example, 
if =<expression>= is =(! 5)=, then the corresponding stepper
will look something like this:

#+BEGIN_SRC
╔═══════════════════════════════════╗
║╭     ╮                            ║
║│ ! 5 │                            ║
║╰     ╯                            ║
║╭─────╮╭─────╮╭─────╮╭─────╮╭─────╮║
║│ ▮◀◀ ││ ▮◀  ││  ▶  ││  ▶▮ ││ ▶▶▮ │║
║╰─────╯╰─────╯╰─────╯╰─────╯╰─────╯║
╚═══════════════════════════════════╝
#+END_SRC

If the "!" symbol is bound to the factorial function as defined on the
first picture, then pressing the ▶ or ▶▮ buttons will cause the
expression to be reduced by means of the substitution model of
procedure evaluation.

In this regard, the visual stepper in GRASP is similar to the stepper
available for the Beginner Student Language in the dr Racket
programming environment.

What makes the stepper in GRASP different, is first that it uses the
representation of s-expressions as nested boxes, rather than text, and
second, that during the evaluation, subsequent steps of reductions are
smoothly morphed from one into another: the "!" will gradually morph
into the body of the factorial function, the "5" will triple itself,
and each of its occurrences will slide into the positions of the
occurrences of "n" in the body of the definition of factorial.

Eventually, we will get a something that looks like this:

#+BEGIN_SRC
╔═══════════════════════════════════╗
║╭    ╭        ╮                 ╮  ║
║│ if │ <= 5 1 │                 │  ║
║│    ╰        ╯                 │  ║
║│                               │  ║
║│       1                       │  ║
║│                               │  ║
║│       ╭     ╭   ╭       ╮ ╮ ╮ │  ║
║│       │ * 5 │ ! │ - 5 1 │ │ │ │  ║
║╰       ╰     ╰   ╰       ╯ ╯ ╯ ╯  ║
║╭─────╮╭─────╮╭─────╮╭─────╮╭─────╮║
║│ ▮◀◀ ││ ▮◀  ││  ▶  ││  ▶▮ ││ ▶▶▮ │║
║╰─────╯╰─────╯╰─────╯╰─────╯╰─────╯║
╚═══════════════════════════════════╝
#+END_SRC

Now, on the next step, the expression ~(<= 5 1)~ will morph into the
value =#false=:

#+BEGIN_SRC
╔═════════════════════════════════════════╗
║╭                               ╮        ║
║│ if #false                     │        ║
║│                               │        ║
║│                               │        ║
║│       1                       │        ║
║│                               │        ║
║│       ╭     ╭   ╭       ╮ ╮ ╮ │        ║
║│       │ * 5 │ ! │ - 5 1 │ │ │ │        ║
║╰       ╰     ╰   ╰       ╯ ╯ ╯ ╯        ║
║╭─────╮╭─────╮╭─────╮╭─────╮╭─────╮      ║
║│ ▮◀◀ ││ ▮◀  ││  ▶  ││  ▶▮ ││ ▶▶▮ │      ║
║╰─────╯╰─────╯╰─────╯╰─────╯╰─────╯      ║
╚═════════════════════════════════════════╝
#+END_SRC

Subsequently the whole expression will be replaced with the "else"
branch of the "if" expression: the content of the outermost expression
will fade away, and the expression =(* 5 (! (- 5 1)))= will slide into
the top left corner of the outer box.

A video recording of this process (performed in both graphical and terminal
clients of GRASP) can be found at https://www.youtube.com/watch?v=wN8Fy5xTXeQ, 
and the reader is encouraged to watch it before proceeding through the next
sections of this paper.

** The simplified model of the reduction

Computationally, visual stepper in GRASP is currently based on an
erroreous implementation of a small-step evaluator of an extended
lambda-calculus.  Because the implementation was meant only as a proof
of concept, it is only capable of processing primitive values such as
numbers, and has problems with symbolic expressions (and lists in
particular).

#+BEGIN_SRC scheme
(define (self-evaluating? x)
  (or (and-let* ((`(lambda ,args ,body) x)))
      (and (isnt x list?)
	   (isnt x pair?)
	   (isnt x symbol?))))
#+END_SRC
#+BEGIN_SRC scheme
(define-object (EvaluationContext)
  ;;(define macro-definitions ::)

  (define definitions ::java.util.Map
    (let ((table ::java.util.Map (java.util.HashMap)))
      (table:put '+ +)
      (table:put '- -)
      (table:put '* *)
      (table:put '/ /)
      (table:put '< <)
      (table:put '<= <=)
      (table:put '> >)
      (table:put '>= >=)
      (table:put '= =)
      (table:put 'eq? eq?)		
      (table:put 'eqv? eqv?)
      table))

  (define (value symbol)
    (cond ((definitions:contains-key symbol)
	   (definitions:get symbol))
	  (else
	   (error "undefined symbol: "symbol))))

  (define (defines-macro? symbol)
    #f)

  (define (defines? symbol)
    (definitions:contains-key symbol))

  (define (define! name value)
    (definitions:put name value))

  (define (primitive? symbol)
    (and (definitions:contains-key symbol)
	 (let ((value (definitions:get symbol)))
	   (procedure? value))))
  )
#+END_SRC
#+BEGIN_SRC scheme
(define default-context ::EvaluationContext
  (EvaluationContext))
#+END_SRC
#+BEGIN_SRC scheme
(define (reduce expression #!optional (context::EvaluationContext
				       default-context))
  (match expression
    (`(if #f ,then ,else)
     else)
    (`(if ,test ,then ,else)
     (let ((test* (reduce test context)))
       (if (equal? test test*)
	   then
	   `(if ,test* ,then ,else))))
    (`(lambda ,args ,body)
     expression)
    (`(quote ,_)
     expression)
    (`(,operator . ,operands)
     (if (and (symbol? operator)
	      (context:defines-macro? operator))
	 (error "Macros not supported (yet)")
	 (let ((operands* (reduce-operands operands context)))
	   (if (isnt operands equal? operands*)
	       `(,operator . ,operands*)
	       (match operator
		 (,@symbol?
		  (cond ((context:primitive? operator)
			 (apply (context:value operator)
				operands))
			((context:defines? operator)
			 (reduce `(,(context:value operator)
				   . ,operands)
				 context))
			(else
			 `(,operator . ,operands))))
		 (`(lambda ,args ,body)
		  (substitute args #;with operands
			      #;in body))
		 (`(,_ . ,_)
		  (let ((operator* (reduce operator
					   context)))
		    `(,operator* . ,operands)))
		 (_
		  `(,operator . ,operands)))))))
    (_
     (if (and (symbol? expression)
	      (context:defines? expression))
	 (context:value expression)
	 expression))))
#+END_SRC
#+BEGIN_SRC scheme
(define (reduce-operands operands #!optional (context::EvaluationContext
			      		      default-context))
  (match operands
    (`(,first . ,rest)
     (let ((first* (reduce first context)))
       (if (equal? first first*)
	   `(,first . ,(reduce-operands rest context))
	   `(,first* . ,rest))))
    ('()
     '())
    (_
     (reduce operands context))))
#+END_SRC
#+BEGIN_SRC scheme
(define (any. satisfying? elements)
  (match elements
    (`(,h . ,t)
     (or (satisfying? h)
	 (any. satisfying? t)))
    ('()
     #f)
    (x
     (satisfying? x))))
#+END_SRC
#+BEGIN_SRC scheme
(define (in. element collection)
  (any. (is _ eq? element) collection))
#+END_SRC
#+BEGIN_SRC scheme
(define (substitute variables #;with values #;in expression)
  (match expression
    (`(quote ,_)
     expression)
    (`(lambda ,args ,body)
     (let-values (((variables* values*) (only. (isnt _ in. args)
					       variables values)))
       `(lambda ,args
	  ,(substitute variables* #;with values*
		       #;in body))))
    (`(,operator . ,operands)
     `(,(substitute variables #;with values #;in operator)
       . ,(substitute variables #;with values #;in operands)))
    (_
     (if (symbol? expression)
	 (counterpart #;of expression #;from variables
			   #;in values)
	 expression))))
#+END_SRC
#+BEGIN_SRC scheme
(define (counterpart #;of variable #;from variables
			  #;in values)
  (match variables
    (`(,,variable . ,_)
     (let ((result (car values)))
       (if (self-evaluating? result)
	   result
	   `',result)))
    (,variable
     `',values)
    (`(,_ . ,rest)
     (counterpart #;of variable #;from rest
		       #;in (cdr values)))
    (_
     variable)))
#+END_SRC

The =is= and =isnt= forms are defined in SRFI-156. The =match= form is
derived from the sample implementation in the (withdrawn) SRFI-200
document. The =and-let*= form is defined in the SRFI-202 document. The
code uses Kawa's syntactic extensions for accessing classes'
properties and metods, as well as for defining DSSSL style optional
arguments. It also makes use of some classes and interfaces provided
by the JVM platform. The =only.= function is a counterpart of SRFI-1's
=filter=, but it also supports improper lists (and replaces the
improper tail with ='()= if it doesn't satisfy the predicate
argument).


** Requirements for the visual stepper

The stepper presented in the previous section used the classical
cons-cells, symbols and numbers to represent expressions. All it did
was performing substitution in nested lists.

However, this is insufficient for the purpose of the visual evaluator
presented at the beginning of this paper. In addition to simply obtaining
new expressions, we also need to track the origins of the components
of its subexpressions. Consider the reduction from the expression

#+BEGIN_SRC scheme
(! 1)
#+END_SRC

to

#+BEGIN_SRC scheme
(if (<= 1 1)
    1
   (* 1 (! (- 1 1))))
#+END_SRC

There are six occurrences of =1= in this expression, but only
three of them originate from argument substitution. Therefore, we need
to be able to track their identity using other means than the equality
predicates that are provided by Scheme.

Moreover, cons-cells themselves carry no information about line breaks
and indentation structure. This limitation has traditionally been
circumvented by pretty-printing, which can be confusing when the
indentation of the expression obtained from substitution changes
compared to the original expression. The source code can also contain
comments, and it can be desirable to preserve them in the process of
substitution.

** The representation of expressions in GRASP

Some of the requirements from the previous section are already satisfied
by the representation of expressions that was developed for representing
documents in GRASP.

We do not claim, that the current representation of expressions of GRASP
is particularly good, and we are open to better alternatives.

First off, GRASP represents documents by subclassing the =pair= class
provided by Kawa. Originally the reason for it was that Kawa defined
an =equal?=-like =equals= method on cons-cells, which didn't allow to
use cons-cells' pointer (=eq?=-like) equality in the context of hash
tables.

Intially GRASP used a number of hash tables, named =pre-head-space=,
=post-head-space=, =pre-tail-space= and =post-tail-space=, as well as
=null-head-space= and =null-tail-space= hash tables for representing
spaces and comments between elements of the list.

However, there was a problem with editable representation of symbols:
given that the Scheme's =eq?= corresponds directly to the object
idenity in Kawa, it was impossible to modify only a signle occurrence
of a symbol, leaving the remaining ones intact. Moreover, it is
impossible to change object's type in runtime, and in Scheme even some
very similar expressions (such as 1 and 1-) have different types (a
number and a symbol, respectively).

Therefore a new class called =Atom= was devised, that contained an
editable representation of atoms. A (SRFI-39-like) parameter called
=cell-access-mode= was introduced, and the =getCar= and =getCdr=
methods of the =cons= cell were overridden, so that if the value of
=(cell-access-mode)= was =CellAccessMode:Editing=, they would be
returning =Atom= objects, and otherwise if the parameter's value was
=CellAccessMode:Evaluating=, they would return the parsed content of
=Atom= object's internal buffer.

Overriding the accessor methods also allowed to solve the problem with
the lack of identity of empty lists, and an object called
=EmptyListProxy= was introduced which held the internal space of
various instances of empty list. This allowed to remove the
=null-head-space= and =null-tail-space= hash tables. Furthermore, some
of the remaining tables were moved from hash tables to the property
list of the =cons= object with the hope of optimizing the performance.

GRASP uses this representation to this day, although in retrospect
having two different access modes turned out to be very confusing, and
it would probably be better to have a different structure for editing
and a different one for evaluation, and conversion functions that
would transform between those two representations.

** The model of reduction that tracks origins of expressions

The new variant of the =reduce= function will take two additional
arguments. One of them, called =progeny=, will be a mutable hash-table
that maps a source element to all the subexpressions that were created
by substituting that element with them. The second additional
argument, called =origin=, will map the other way around, from an
expression to all the expressions that were used to create it.

Although according to the reduction rules of lambda-calculus every
expression can have at most one origin element, we will represent both
tables as mappings from an element to a list of elements.

By default, the hash table of an element e will return a list
containing only that element (which essentially means that by default
every element is its own origin/progeny).

Otherwise, an element can have many elements in its progeny list.
This corresponds to the argument substitution of arguments with
values.  It is also possible for an expression to have an empty
progeny list, which means that the expression disappears in the course
of reduction.

Both tables are populated with data as the reduction proceeds.  They
are also returned as additional values from the =reduce= function.

#+BEGIN_SRC scheme
(define (reduce expression
		#!optional
		(origin::(!maps (Element) to: (list-of Element))
			 (property (e::Element)::(list-of Element)
				   (recons e '())))
		(progeny::(!maps (Element) to: (list-of Element))
			  (property (e::Element)::(list-of Element)
				    (recons e '())))
		#!key
		(context::EvaluationContext (default-context)))
  
  (define (mark-origin! newborn parent)
    (set! (origin newborn) (recons parent '()))
    (set! (progeny parent) (recons newborn '())))

  (define (add-origin! newborn parent)
    (and-let* ((`(,default) (origin newborn))
	       ((eq? newborn default)))
      (set! (origin newborn) '()))
    (and-let* ((`(,default) (progeny parent))
	       ((eq? parent default)))
      (set! (progeny parent) '()))
    (unless (any (is _ eq? parent) (origin newborn))
      (set! (origin newborn) (cons parent (origin newborn))))
    (unless (any (is _ eq? newborn) (progeny parent))
      (set! (progeny parent) (cons newborn (progeny parent)))))
  
  (define (dissolve! item #!key (when? ::predicate
				       (lambda (item)
					 (and-let* ((`(,i) (progeny item))
						    ((eq? i item)))))))
    (when (when? item)
      (for child in (progeny item)
	(set! (origin child) (only (isnt _ eq? item) (origin child))))
      (set! (progeny item) '()))
    
    (when (gnu.lists.LList? item)
      (traverse
       item
       doing:
       (lambda (e::Element t::Traversal)
	 (dissolve! e when?: when?)))))

  (define (eradicate! item #!key (when? ::predicate
					(lambda (item)
					  (and-let* ((`(,i) (origin item))
						     ((eq? i item)))))))
    (when (when? item)
      (for child in (origin item)
	(set! (progeny child) (only (isnt _ eq? item) (progeny child))))     
      (set! (origin item) '()))
    
    (when (gnu.lists.LList? item)
      (traverse
       item
       doing:
       (lambda (e::Element t::Traversal)
	 (eradicate! e when?: when?)))))
  
  (define (substitute variables #;with values #;in expression)
    (match expression
      (`(quote ,_)
       expression)
      (`(lambda ,args ,body)
       (let*-values (((variables* values*) (only. (isnt _ in. args)
						  variables values))
		     ((result) (cons* (car expression) args
				      (substitute variables* #;with values*
						  #;in body))))
	 (copy-properties cell-display-properties
			  (cdr expression) (cdr result))
	 (copy-properties cell-display-properties
			  expression result)
	 result))
      (`(,operator . ,operands)
       (let ((result (cons (substitute variables #;with values
				       #;in operator)
			   (substitute variables #;with values
				       #;in operands))))
	 (mark-origin! result expression)
	 (copy-properties cell-display-properties expression
			  result)))
      (_
       (if (Atom? expression)
	   (counterpart #;of expression #;from variables
					    #;in values)
	   expression))))

  (define (counterpart #;of variable #;from variables
			    #;in values)
    (match variables
      (`(,,variable . ,_)
       (let* ((result (deep-copy (car values)))
	      (result (if (self-evaluating? result)
			  result
			  (cons (Atom "quote") result))))
	 (eradicate! result when?: always)
	 (add-origin! result (car variables))
	 result))
      (,variable
       (let ((result (cons (Atom "quote") (copy values))))
	 (add-origin! result variable)
	 result))
      (`(,_ . ,rest)
       (counterpart #;of variable #;from rest
			 #;in (cdr values)))
      (_
       variable)))
  
  (define (reduce-operands operands)
    (match operands
      (`(,first . ,rest)
       (let ((first* (reduce first)))
	 (if (match/equal? first first*)
	     (let ((result (cons first (reduce-operands rest))))
	       (mark-origin! result operands)
	       (copy-properties cell-display-properties operands result))
	     (let ((result (cons first* rest)))
	       (mark-origin! result operands)
	       (copy-properties cell-display-properties operands result)))))
      (`()
       operands)
      (_
       (reduce operands))))

  (define (deep-copy expression)
    (match expression
      (`(,h . ,t)
       (let ((result (cons (deep-copy h) (deep-copy t))))
	 (mark-origin! result expression)
	 (copy-properties cell-display-properties expression result)
	 result))
      (_
       (let ((result (copy expression)))
	 (mark-origin! result expression)
	 result))))

  (define (transfer-heritage! args vals)
    (match args
      (`(,arg . ,args*)
       (let ((val (car vals))
	     (vals* (cdr vals))
	     (children (progeny arg)))
	 (set! (progeny val) children)
	 (for p in children
	   (set! (car (origin p)) val))
	 (transfer-heritage! args* vals*)))
      ('()
       (values))
      (arg
       (let ((children (progeny arg)))
	 (set! (progeny vals) children)
	 (for p in children
	   (set! (car (origin p)) vals))))))
	 
  (define (reduce expression)
    (match expression
      (`(if #f ,then ,else)
       (dissolve! expression)
       (let ((result (deep-copy else)))
	 (mark-origin! result else)
	 result))
      (`(if ,test ,then ,else)
       (let ((test* (reduce test))
	     (if* (car expression)))
	 (cond ((match/equal? test test*)
		(dissolve! expression)
		(let ((result (deep-copy then)))
		  (mark-origin! result then)
		  result))
	       (else
		(let ((result (cons* if* test* then else '())))
		  (mark-origin! result expression)
		  (mark-origin! test* test)
		  (copy-properties* cell-display-properties expression result)
		  result)))))
      (`(lambda ,args ,body)
       expression)
      (`(quote ,_)
       expression)
      (`(,operator . ,operands)
       (if (and (Atom? operator)
		(context:defines-macro? operator))
	   (error "Macros not supported (yet)")
	   (let ((operands* (reduce-operands operands)))
	     (if (isnt operands match/equal? operands*)
		 (let* ((operator* (copy operator))
			(result (cons operator* operands*)))
		   (mark-origin! operator* operator)
		   (mark-origin! operands* operands)
		   (mark-origin! result expression)
		   (copy-properties cell-display-properties expression
				    result))
		 (match operator
		   (,@Atom?		    
		    (cond ((context:primitive? operator)
			   (let* ((result
				   (grasp
				    (parameterize ((cell-access-mode
						    CellAccessMode:Evaluating))
				      (apply (context:value operator)
					     (map (lambda (x) x) operands))))))
			     (mark-origin! result expression)
			     result))
			  ((context:defines? operator)
			   (let ((operator* (context:value operator)))
			     (match operator*
			       (`(lambda ,args ,body)
				(let ((result (substitute args #;with operands
							  #;in body)))
				  (transfer-heritage! args operands)
				  (dissolve! expression)
				  (mark-origin! result operator)
				  result))
			       (_
				`(,operator* . ,operands)))))
			  (else
			   expression)))
		   (`(lambda ,args ,body)
		    (dissolve! expression)
		    (let ((result (substitute args #;with operands
					      #;in body)))
		      result))
		   (`(,_ . ,_)
		    (let* ((operator* (reduce operator))
			   (result (cons operator* operands)))
		      (mark-origin! result expression)
		      (mark-origin! operator* operator)
		      (copy-properties cell-display-properties expression
				       result)))
		   (_
		    expression))))))
      (_
       (if (and (Atom? expression)
		(context:defines? expression))
	   (let ((result (copy (context:value expression))))
	     (dissolve! expression)
	     (mark-origin! result expression)
	     result)
	   expression))))

  (values (reduce expression)
	  origin
	  progeny))
#+END_SRC


The =traverse= function is used for iterating over subsequent elements
in the document, where even elements are spaces/comments, and odd
elements are actual data.  The =cell-display-properties= variable
points to a list with references to =pre-head-space=,
=post-head-space=, =pre-tail-space= and =post-tail-space=.

** Rendering transitions between expressions

The most spectacular part of the visual stepper are transitions. They
are expressed using the =Morph= object, which - among other things -
contains the =progress= property, which is a real number between 0 and
1, where 0 means that we should only render the source expression,
while 1 means that we should only render the target expression.

For every other value in that range, we should get an interpolation
between those two expressions.

The =Morph= class is defined in the following way:

#+BEGIN_SRC scheme
(define-object (Morph initial::Tile
		      final::Tile
		      origin::(maps (Element) to: (list-of
						   Element))
		      progeny::(maps (Element) to: (list-of
						    Element)))
  ::Enchanted
  (define progress ::float 0.0)

  (define initial-position ::(maps (Element) to: Position)
    (measure-positions! initial))

  (define initial-extent ::Extent
    (extent+ initial))

  (define final-position ::(maps (Element) to: Position)
    (measure-positions! final))

  (define final-extent ::Extent
    (extent+ final))

  (define maximum-extent ::Extent
    (Extent width: (max initial-extent:width
			final-extent:width)
	    height: (max initial-extent:height
			 final-extent:height)))

  (define (extent) ::Extent maximum-extent)

  (define shift ::(maps (Element) to: Position)
    (property+ (element::Element)::Position
	       (Position left: 0 top: 0)))

  (define (draw! context::Cursor)::void
    (cond ((is progress <= 0.5) ;>
           (draw-tween! final origin 
                        final-position
                        initial-position
	                progress)
	   (draw-tween! initial
		        progeny
		        initial-position
		        final-position
		        (- 1.0 progress)))
	  (else
	   (draw-tween! initial progeny
		        initial-position
                        final-position
		        (- 1.0 progress))
	   (draw-tween! final
		        origin
	                final-position
		        initial-position
	                progress))))
  (Magic))
#+END_SRC

As we can see, it takes two arguments - the =initial= expression, the
=final= expression and the two maps returned by the =reduce= function.

Upon initialization, it measures the positions of all sub-expressions
of the =initial= and =final= expressions.

The class is defined as a subclass of =Magic= that defines the
=Enchanted= interface, which is required by the extension system of
GRASP.

The =draw!= method is defined so that if =progress= is no greater than
0.5, then we render the final expression as the background, and then -
on top of it - we draw the initial expression in the foreground.  But
once the progress of 0.5 is exceeded, we first draw the initial
expression, and then we draw the final expression on top of it.

This allows to achieve satisfying visual effects even in the terminal client
of GRASP, which does not provide any mechanisms for transparency.

The =draw-tween!= function has to support two cases: the first one is
when the list of the rendered expression's counterparts is empty. In
such a case, we want this expression to dissolve into background.

Otherwise we want to morph the expression into each of its counterparts.

#+BEGIN_SRC scheme
(define (draw-tween! expression::Element
		     counterparts::(maps (Element)
					 to: (list-of
					      Element))
		     source-position::(maps (Element)
					    to: Position)
		     target-position::(maps (Element)
					    to: Position)
		     intensity::float
		     #!key (only-with-relatives ::boolean #f))
  ::void
  (let ((links (counterparts expression)))
    (cond
     ((empty? links)
      (draw-emerging! expression
		      (source-position expression)
		      intensity)
      (when (gnu.lists.LList? expression)
	(traverse
	 expression
	 doing:
	 (lambda (sub::Element t::Traversal)
	   (draw-tween! sub counterparts
			       source-position
			       target-position
			       intensity
			       only-with-relatives:
			       only-with-relatives)))))
     (else
      (for x in links
	(draw-morph! expression x counterparts
		     source-position
		     target-position
		     intensity
		     only-with-relatives: only-with-relatives))))))
#+END_SRC

When it comes to morphing, we need to do three things. First, we need
to find the interpolation between the positions of the source and the
target expression. Second, we need to stretch the rendered expressions
to make their sizes an interpolation between the source and the target
expressions.  Third, we need to adjust the intensity of the source and
the target expressions to make the effect of fading from one
expression to another.

Thus, the =draw-morph!= procedure is defined in the following way:

#+BEGIN_SRC scheme
(define (draw-morph! foreground::Element
		     background::Element
		     counterparts::(maps (Element)
					 to: (list-of
					      Element))
		     source-position::(maps (Element)
					    to: Position)
		     target-position::(maps (Element)
					    to: Position)
		     progress::float
		     #!key (only-with-relatives ::boolean #f))
  ::void
  (let* ((p0 ::Position (source-position foreground))
	 (p1 ::Position (target-position background))
	 (left ::real (linear-interpolation
		       from: p0:left to: p1:left
		       at: (- 1 progress)))
	 (top ::real (linear-interpolation
		      from: p0:top to: p1:top
		      at: (- 1 progress))))
    (cond
     ((match/equal? foreground background)
      ;; here we just draw the foreground
      ;; with full intensity
      (unless (and only-with-relatives
		   (eq? foreground background))
	(with-translation (left top)
	  (draw! foreground))))

     ((or (isnt foreground Tile?)
	  (isnt background Tile?))
      ;; at least one of the elements is (presumably)
      ;; a space, so the only way we can morph them
      ;; is by fading
      (with-translation (left top)
	(painter:with-intensity (- 1.0 progress)
	  (lambda ()
	    (draw! background)))
	(painter:with-intensity progress
	  (lambda ()
	    (draw! foreground)))))

     ((and (gnu.lists.LList? foreground)
	   (gnu.lists.LList? background))
      (let* ((e0 ::Extent (extent+ foreground))
	     (e1 ::Extent (extent+ background))
	     (width ::real (linear-interpolation
			    from: e0:width to: e1:width
			    at: (- 1 progress)))
	     (height ::real (linear-interpolation
			     from: e0:height to: e1:height
			     at: (- 1 progress))))
	(unless only-with-relatives
	  (with-translation (left top)
	    (painter:draw-box! width height '())))
	(traverse
	 foreground
	 doing:
	 (lambda (item::Element t::Traversal)
	   (draw-tween! item
			  counterparts
			  source-position
			  target-position
			  progress
			  only-with-relatives: only-with-relatives)))))
     ((and (Tile? foreground)
	   (Tile? background))
      (let* ((e0 ::Extent (extent+ foreground))
	     (e1 ::Extent (extent+ background))
	     (width ::real (linear-interpolation
			    from: e0:width to: e1:width
			    at: (- 1 progress)))
	     (height ::real (linear-interpolation
			     from: e0:height to: e1:height
			     at: (- 1 progress))))
	  (with-translation (left top)
	    (painter:with-intensity (- 1.0 progress)
	      (lambda ()
		(painter:with-stretch (/ width e1:width) (/ height e1:height)
		  (lambda ()
		    (draw! background)))))
	    (painter:with-intensity progress
	      (lambda ()
		(painter:with-stretch (/ width e0:width) (/ height e0:height)
		  (lambda ()
		    (draw! foreground)))))))
      (when (gnu.lists.LList? foreground)
	(traverse foreground
		  doing:
		  (lambda (element::Element traverse::Traversal)
		    (draw-tween! element counterparts
				   source-position
				   target-position
				   progress
				   only-with-relatives: #t)))))
     )))
#+END_SRC

The =draw-emerging!= supplementary procedure is defined as

#+BEGIN_SRC scheme
(define (draw-emerging! expression::Element p::Position
			intensity::float)
  ::void
  (painter:with-intensity intensity
    (lambda ()
      (with-translation (p:left p:top)
	(if (gnu.lists.LList? expression)
	    (let ((outer ::Extent (extent+ expression)))
	      (painter:draw-box! outer:width outer:height '()))
	    (draw! expression))))))
#+END_SRC

*** The rendering interface in GRASP

The last two defintions revealed the =painter= object that is an
important component of GRASP.

Since GRASP supports 3 different rendering methods (desktop
environments via JVM's AWT framework, terminal environments via Java's
Lanterna library and Android devices via Android's Graphics API),
there's a need for an interface which unifies rendering operations
between the target systems.

In GRASP, this interface is called Painter, and GRASP clients are
responsible for providing particular implementations of that
interface.

The interface itself is rather complex, because it needs to provide
operations at varying levels of abstraction. From the point of view of
the visual stepper, it needs to provide the operations =with-stretch=
(for stretching the expressions), =with-intensity= (for fading beween
expressions) and =with-translation= (for interpolating between
expressions' positions).

** The extension mechanism of GRASP




** Limitations and the future work


** Related work


** Biography


* Appendix A - The Reduction Model



If we provide the definition of the factorial function to the context

#+BEGIN_SRC scheme
(default-context:define! '!
  '(lambda (n)
     (if (<= n 1)
	 1
	 (* n (! (- n 1))))))
#+END_SRC

and unfold the =reduce= function from the expression =(! 5)= until
it reaches a fix point, we'll get the following sequence of expansions:

#+BEGIN_SRC scheme
(! 5)

  (if (<= 5 1)
      1
      (* 5 (! (- 5 1))))
  
  (if #f
      1
      (* 5 (! (- 5 1))))
  
  (* 5 (! (- 5 1)))
  
  (* 5 (! 4))
  
  (* 5 (if (<= 4 1)
	   1
	   (* 4 (! (- 4 1)))))
  
  (* 5 (if #f
	   1
	   (* 4 (! (- 4 1)))))
  
  (* 5 (* 4 (! (- 4 1))))
  
  (* 5 (* 4 (! 3)))
  
  (* 5 (* 4 (if (<= 3 1)
		1
		(* 3 (! (- 3 1))))))
  
  (* 5 (* 4 (if #f
		1
		(* 3 (! (- 3 1))))))
  
  (* 5 (* 4 (* 3 (! (- 3 1)))))
  
  (* 5 (* 4 (* 3 (! 2))))
  
  (* 5 (* 4 (* 3 (if (<= 2 1)
		     1
		     (* 2 (! (- 2 1)))))))
  
  (* 5 (* 4 (* 3 (if #f
		     1
		     (* 2 (! (- 2 1)))))))
  
  (* 5 (* 4 (* 3 (* 2 (! (- 2 1))))))
  
  (* 5 (* 4 (* 3 (* 2 (! 1)))))
  
  (* 5 (* 4 (* 3 (* 2 (if (<= 1 1)
			  1
			  (* 1 (! (- 1 1))))))))
  
  (* 5 (* 4 (* 3 (* 2 (if #t
			  1
			  (* 1 (! (- 1 1))))))))

  (* 5 (* 4 (* 3 (* 2 1))))

  (* 5 (* 4 (* 3 2)))

  (* 5 (* 4 6))

  (* 5 24)

  120
#+END_SRC

Likewise, if we extend the set of primitive operators - for example,
with the following defintions

#+BEGIN_SRC scheme
      (default-context:define! 'cons 
       (lambda args
         (match args
	   (`(',a ',b)
	    `',(cons a b))
	   (`(,a ',b)
	    `',(cons a b))
	   (`(',a ,b)
	    `',(cons a b))
	   (`(,a ,b)
	    `',(cons a b)))))
#+END_SRC
#+BEGIN_SRC scheme
      (default-context:define! 'car 
       (lambda (x)
        (match x
 	 (`'(,a . ,b)
	  (if (self-evaluating? a)
	      a
	      `',a)))))
#+END_SRC
#+BEGIN_SRC scheme
      (default-context:define! 'cdr 
       (lambda (x)
        (match x
	 (`'(,a . ,b)
	  (if (self-evaluating? b)
	       b
	       `',b)))))
#+END_SRC
#+BEGIN_SRC scheme
      (default-context:define! 'pair? 
       (lambda (x)
        (and-let* ((`'(,_ . ,_) x)))))
#+END_SRC
#+BEGIN_SRC scheme
      (default-context:define! 'null? 
       (lambda (x)
        (and-let* ((`'() x)))))

#+END_SRC

then we can define the =append= function like this:

#+BEGIN_SRC scheme
(default-context:define! 'append
  '(lambda (a b)
     (if (null? a)
	 b
	 (cons (car a) (append (cdr a) b)))))
#+END_SRC

And while we admit that the set of primitives for working with
cons-cells feels a bit complicated (or even simply wrong), it does
allow to obtain the proper sequence of expansions of the expression
=(append '(1 2) '(3 4 5))=:

#+BEGIN_SRC scheme
  (append '(1 2) '(3 4 5))
#+END_SRC
#+BEGIN_SRC scheme
  (if (null? '(1 2))
      '(3 4 5)
      (cons (car '(1 2)) (append (cdr '(1 2)) '(3 4 5))))
#+END_SRC
#+BEGIN_SRC scheme
  (if #f
      '(3 4 5)
      (cons (car '(1 2)) (append (cdr '(1 2)) '(3 4 5))))
#+END_SRC
#+BEGIN_SRC scheme
  (cons (car '(1 2)) (append (cdr '(1 2)) '(3 4 5)))
#+END_SRC
#+BEGIN_SRC scheme
  (cons 1 (append (cdr '(1 2)) '(3 4 5)))
#+END_SRC
#+BEGIN_SRC scheme
  (cons 1 (append '(2) '(3 4 5)))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (if (null? '(2))
	     '(3 4 5)
	     (cons (car '(2)) (append (cdr '(2)) '(3 4 5)))))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (if #f
	     '(3 4 5)
	     (cons (car '(2)) (append (cdr '(2)) '(3 4 5)))))
 #+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (cons (car '(2)) (append (cdr '(2)) '(3 4 5))))
#+END_SRC
#+BEGIN_SRC scheme 
 (cons 1 (cons 2 (append (cdr '(2)) '(3 4 5))))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (cons 2 (append '() '(3 4 5))))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (cons 2 (if (null? '())
		     '(3 4 5)
		     (cons (car '()) (append (cdr '()) '(3 4 5))))))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (cons 2 (if #t
		     '(3 4 5)
		     (cons (car '()) (append (cdr '()) '(3 4 5))))))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 (cons 2 '(3 4 5)))
#+END_SRC
#+BEGIN_SRC scheme
 (cons 1 '(2 3 4 5))
#+END_SRC
#+BEGIN_SRC scheme
 '(1 2 3 4 5)
#+END_SRC

* Appendix B - Reduction 
