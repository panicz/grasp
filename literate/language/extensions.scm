;; Note: this file was generated from the ~grasp.org~
;; document, which also serves as the project's documentation.
;; 
;; Please do not edit this file directly, as all the changes
;; will be overwritten after code regeneration, and modify
;; the ~grasp.org~ file instead.

(module-name (language extensions))
;; mind that, for some reason, importing ANY module from this
;; one causes the compiler to break, probably because of the
;; way macroexpander is implemented in Kawa. This could likely
;; be solved by splitting this module into a bunch of smaller
;; ones, to enforce the proper staging, but that would only
;; complicate things

(define-syntax define-syntax-rule
  (syntax-rules ()
    ((define-syntax-rule (<keyword> . <arguments>)
       <substitution>)
     (define-syntax <keyword>
       (syntax-rules ()
         ((<keyword> . <arguments>)
          <substitution>))))))

(define-syntax-rule (comment . <anything>)
  (values))

;; this code is valid, even though the code
;; inside the ~comment~ form is not - that's
;; because it will be discarded according to
;; our earlier definition of the ~comment~
;; macro!
(comment
 (define-syntax <defined-keyword>
   (syntax-rules (<keywords> ...)
    (<pattern-1> <template-1>)
    (<pattern-2> <template-2>)
    ...)))

(define-syntax-rule (assert proposition)
  (or proposition
    (error "Assertion failed: "'proposition)))

(define invalid-example
  (make-parameter
    (lambda (expression result . expectation)
      (if (pair? expectation)
        (error "while evaluating\n\n  "
               expression
               "\n\nexpected:\n\n  "
               (car expectation)
               "\n\ngot:\n\n  "
               result)
        (error "expected "expression" to be non-#false")))))

(define valid-example
  (make-parameter
    (lambda (expression result . expectation)
      result)))

(define-syntax e.g.
  (syntax-rules (===>)
    
    ((_ expression ===> value)
     (let ((result expression)
           (source 'expression)
           (expectation 'value))
       (if (equal? result expectation)
          ((valid-example) source result expectation)
          ((invalid-example) source result expectation))))

    ((_ expression)
     (let ((result expression)
           (source 'expression))
       (if result
         ((valid-example) source result)
         ((invalid-example) source result))))

    ((_ expression ===> value ...)
     (let ((source 'expression)
           (expectation '(value ...)))
       (call-with-values (lambda () expression)
         (lambda results
           (if (equal? results '(value ...))
             ((valid-example) source results expectation)
             ((invalid-example) source results expectation))))))
    ))

(e.g. (+ 2 2) ===> 4)

(e.g. (append '(a b c) '(d e)) ===> (a b c d e))

(e.g. (even? 4))

(e.g. (pair? (cons 1 2)))

(e.g. (values 1 2 3) ===> 1 2 3)

(e.g. (values) ===>)

(define-syntax infix/postfix
  (syntax-rules ()
    
    ((infix/postfix x somewhat?)
     (somewhat? x))

    ((infix/postfix left related-to? right)
     (related-to? left right))

    ((infix/postfix left related-to? right . likewise)
     (let ((right* right))
       (and (infix/postfix left related-to? right*)
            (infix/postfix right* . likewise))))))

(define-syntax extract-_
  (syntax-rules (_ is isnt quote
                    quasiquote unquote
                   unquote-splicing)
    ;; ok, it's a bit rough, so it requires an explanation.
    ;; the macro operates on sequences of triples
    ;;
    ;;   (<remaining-expr> <arg-list> <processed-expr>) +
    ;;
    ;; where <remaining-expr> is being systematically
    ;; rewritten to <processed-expr>. When the _ symbol
    ;; is encountered, it is replaced with a fresh "arg"
    ;; symbol, which is appended to both <arg-list>
    ;; and <processed-expr>.
    ;;
    ;; The goal is to create a lambda where each
    ;; consecutive _ is treated as a new argument
    ;; -- unless there are no _s: then we do not
    ;; create a lambda, but a plain expression.
    ;;
    ;; The nested "is" and "isnt" operators are treated
    ;; specially, in that the _s within those operators are
    ;; not extracted.
    ;;
    ;; Similarly, the _ isn't extracted from quoted forms,
    ;; and is only extracted from quasi-quoted forms if
    ;; it appears on unquoted positions.

    ;; The support for quasiquote modifies the tuples
    ;; to have the form
    ;;
    ;;   (<remaining-expr> <arg-list> <processed-expr> . qq*) +
    ;;
    ;; where qq* is a sequence of objects that expresses
    ;; the nesting level of the 'quasiquote' operator
    ;; (i.e. quasiquote inside quasiquote etc.)

    ;; The macro consists of the following cases:
    
    ;; fin case with no _s
    ((extract-_ fin (() () body))
     (fin (infix/postfix . body)))

    ;; fin case with some _s -- generate a lambda
    ((extract-_ fin (() args body))
     (lambda args
       (with-compile-options
        warn-unknown-member: #f
        (fin (infix/postfix . body)))))

    ;; treat 'is' and 'isnt' operators specially and
    ;; don't touch their _s
    ((extract-_ fin (((is . t) . rest) args (body ...)) . *)
     (extract-_ fin (rest args (body ... (is . t))) . *))

    ((extract-_ fin (((isnt . t) . rest) args (body ...)) . *)
     (extract-_ fin (rest args (body ... (isnt . t))) . *))

    ;; same with 'quote'
    ((extract-_ fin (('literal . rest) args (body ...)) . *)
     (extract-_ fin (rest args (body ... 'literal)) . *))

    ;; when 'quasiquote' is encountered, we increase the
    ;; level of quasiquotation (the length of the qq* sequence)
    ((extract-_ fin
                (((quasiquote x) . rest) args body . qq*) . *)
     (extract-_ fin
                ((x) () (quasiquote) qq . qq*)
                (rest args body) . *))

    ;; on the other hand, for 'unquote' and
    ;; 'unquote-splicing', we decrease the nesting level
    ;; (i.e. we consume one element from the qq* sequence)
    ((extract-_ fin
                (((unquote x) . rest) args body qq . qq*) . *)
     (extract-_ fin
                ((x) () (unquote) . qq*)
                (rest args body qq . qq*) . *))

    ((extract-_ fin
                (((unquote-splicing x) . rest) args body
                 qq . qq*) . *)
     (extract-_ fin
                ((x) () (unquote-splicing) . qq*)
                (rest args body qq . qq*) . *))

    ;; push/unnest nested expression for processing
    ((extract-_ fin (((h . t) . rest) args body . qq) . *)
     (extract-_ fin ((h . t) () () . qq)
                (rest args body . qq) . *))

    ;; unquote in the tail position
    ((extract-_ fin
                ((unquote x) args (body ...) qq . qq*) . *)
     (extract-_ fin
                ((x) args (body ... unquote) . qq*) . *))
    
    ;; generate a new arg for the _ in the head position
    ((extract-_ fin ((_ . rest) (args ...) (body ...)) . *)
     (extract-_ fin (rest (args ... arg) (body ... arg)) . *))

    ;; rewrite the term in the head position to the back
    ;; of the processed terms
    ((extract-_ fin ((term . rest) args (body ...) . qq) . *)
     (extract-_ fin (rest args (body ... term) . qq) . *))

    ;; _ in the tail position
    ((extract-_ fin
                (_ (args ...) (body ...) . qq)
                (rest (args+ ...) (body+ ...) . qq+) . *)
     (extract-_ fin
                (rest (args+ ... args ... arg)
                      (body+ ... (body ... . arg)) . qq+) . *))

    ;; pop/nest back processed expression
    ;; ('last' is an atom; most likely (), but can also
    ;; be some value, e.g. in the case of assoc list literals)
    ((extract-_ fin
                (last (args ...) (body ...) . qq)
                (rest (args+ ...) (body+ ...) . qq+) . *)
     (extract-_ fin (rest (args+ ... args ...)
                          (body+ ... (body ... . last))
                          . qq+) . *))
    ))

(define-syntax-rule (identity-syntax form)
  form)

(define-syntax-rule (is . something)
  (extract-_ identity-syntax (something () ())))

(define-syntax-rule (isnt . something)
  (extract-_ not (something () ())))

(define-syntax-rule (while condition actions ...)
  (let ()
    (define (loop)
      (when condition
        actions ... (loop)))
    (loop)))

(define-syntax-rule (escape-with label . commands)
  (call/cc (lambda (label) . commands)))

(e.g.
  (let ((x 0))
    (escape-with break
      (while #t
        (set! x (+ x 1))
        (when (is x >= 5)
          (break))))
    x) ===> 5)

(define-syntax concurrently
  (lambda (stx)
    (syntax-case stx ()
      ((concurrently actions ...)
       (with-syntax (((futures ...)
                      (generate-temporaries #'(actions ...))))
         #'(let ((futures (future actions)) ...)
             (force futures)
             ...))))))

(define (par-for-each function collection)
  (let ((futures ::java.util.List
                 (java.util.ArrayList)))
    (for-each (lambda (x)
                (futures:add (future (function x))))
              collection)
    (for-each (lambda (f)
                (force f))
              futures)
    (futures:clear)))

(define-syntax for
  (syntax-rules (in from to below by
                    in-reverse
                    in-parallel ::)

    ((_ var :: type in-reverse collection . actions)
     (let ((it ::java.util.ListIterator (collection:listIterator
                                         (length collection))))
       (while (it:hasPrevious)
         (let ((var ::type (it:previous)))
           . actions))))

    ((_ var in-reverse collection . actions)
     (let ((it ::java.util.ListIterator (collection:listIterator
                                         (length collection))))
       (while (it:hasPrevious)
         (let ((var (it:previous)))
           . actions))))

    ((_ var :: type in-parallel collection . actions)
     (par-for-each (lambda (var :: type) . actions) collection))

    ((_ var in-parallel collection . actions)
     (par-for-each (lambda (var) . actions) collection))
    
    ((_ var :: type in collection . actions)
     (for-each (lambda (var :: type) . actions) collection))

    ((_ (vars ...) in collection . actions)
     (for-each (lambda (var)
                 (apply (lambda (vars ...) . actions) var))
               collection))
    
    ((_ var in collection . actions)
     (for-each (lambda (var) . actions) collection))

    ((_ var::type from start to end by increment actions ...)
     (let loop ((var::type start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var increment))))))
    
    ((_ var from start to end by increment actions ...)
     (let loop ((var start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var increment))))))

    ((_ var::type from start below end by increment actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var increment))))))
    
    ((_ var from start below end by increment actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var increment))))))

    ((_ var::type from start to end actions ...)
     (let loop ((var start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var 1))))))
    
    ((_ var from start to end actions ...)
     (let loop ((var start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var 1))))))

    ((_ var::type from start below end actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var 1))))))
    
    ((_ var from start below end actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var 1))))))
    ))

(e.g.
  (call-with-input-string "(a::b::c)" read)
  ===> (a :: b :: c))

(e.g.
  (call-with-input-string "(:::::)" read)
  ===> (:: :: :))

(define-alias InputPort gnu.kawa.io.InPort)

(define-alias OutputPort gnu.kawa.io.OutPort)

(define (with-output-to-string proc::(maps () to: ,a))::string
  (call-with-output-string
    (lambda (port::OutputPort)
      (parameterize ((current-output-port port))
	(proc)))))

(define (with-output-to-port port::OutputPort proc::(maps () to: ,a))::,a
  (parameterize ((current-output-port port))
    (proc)))

(define (with-input-from-string s::string proc::(maps () to: ,a))::,a
  (call-with-input-string s
    (lambda (port::InputPort)::,a
      (parameterize ((current-input-port port))
	(proc)))))

(define (with-input-from-port port::InputPort proc::(maps () to: ,a))::,a
  (parameterize ((current-input-port port))
    (proc)))

(define (print . messages)
  (for message in messages
    (display message))
  (newline))

(define-syntax-rule (define-interface name (supers ...) prototypes ...)
  (interface-definition name (supers ...) (prototypes ...) ()))

(define-syntax interface-definition
  (syntax-rules (::)
    ((_ name supers () methods)
     (define-simple-class name supers interface: #t . methods))
    
    ((_ name supers (method :: result . rest) (methods ...))
     (interface-definition
      name supers rest
      (methods ... (method :: result #!abstract))))
    ))

(define-syntax delegate
  (syntax-rules (::)
    ((delegate (method . params) :: type object)
     (delegate (method . params) object))

    ((delegate (method) object args ...)
     (invoke object 'method args ...))

    ((delegate (method param :: type . params) object args ...)
     (delegate (method . params) object args ... param))

    ((delegate (method param . params) object args ...)
     (delegate (method . params) object args ... param))))

(define-syntax object-definition
  (lambda (stx)
    (syntax-case stx (::
                      define
                      define-private
                      define-static
                      delegate)
      
      ((object-definition (object-name . args)
                          (arg :: type . rest)
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          spec)
       #'(object-definition (object-name . args)
                            rest
                            supers
                            (slots ... (arg :: type))
                            methods
                            (initializers
                             ...
                             (slot-set! (this) 'arg arg))
                            spec))

      ((object-definition (object-name . args)
                          (arg . rest)
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          spec)
       #'(object-definition (object-name . args)
                            rest
                            supers
                            (slots ... (arg))
                            methods
                            (initializers
                             ...
                             (slot-set! (this) 'arg arg))
                            spec))

      ((object-definition (object-name . args)
                          rest
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          spec)
       (identifier? #'rest)
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (rest::list))
                            methods
                            (initializers
                             ...
                             (slot-set! (this) 'rest rest))
                            spec))
      
      ((object-definition (object-name . args)
                          ()
                          (supers ...)
                          slots
                          methods
                          initializers
                          (:: type . spec))
       #'(object-definition (object-name . args)
                            ()
                            (supers ... type)
                            slots
                            methods
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((define-private (method . params)
                             . body)
                           . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods
                             ...
                             ((method . params)
                              access: 'private . body))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define-private slot :: type value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot :: type access: 'private))
                            methods
                            (initializers 
                             ... 
                             (set! slot value))
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define-private slot value)
                          . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot access: 'private))
                            methods
                            (initializers 
                             ... 
                             (set! slot value))
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((define-static (method . params)
                             . body)
                           . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods
                             ...
                             ((method . params)
                              allocation: 'static . body))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          initializers
                          ((define-static slot :: type value)
                          . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot :: type allocation: 'static init: value))
                            methods
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          initializers
                          ((define-static slot value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot allocation: 'static init: value))
                            methods
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((define (method . params) . body) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods ... ((method . params) . body))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((delegate (method . params)::type object) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods ... ((method . params)::type 
                                          (delegate (method . params) object)))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((delegate (method . params) object) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods ... ((method . params) 
                                          (delegate (method . params) object)))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define slot :: type value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots
                             ...
                             (slot :: type))
                            methods
                            (initializers
                             ...
                             (set! slot value))
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          initializers
                          ((define slot :: type) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot :: type))
                            methods
                            initializers
                            spec))
      
      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define slot value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot))
                            methods
                            (initializers
                             ...
                             (set! slot value))
                            spec))

      ((object-definition (object-name)
                          ()
                          (supers ...)
                          (slots ...)
                          (methods ...)
                          ()
                          ())
       #'(define-simple-class object-name (supers ...)
           slots ... methods ...))

      ((object-definition (object-name . args)
                          ()
                          (supers ...)
                          slots
                          (methods ...)
                          (initializers ...)
                          ())
       #'(object-definition (object-name)
                            ()
                            (supers ...)
                            slots
                            (methods
                             ...
                             ((*init* . args)
                              initializers ...))
                            ()
                            ()))

      ((object-definition (object-name . args)
                          ()
                          (supers ...)
                          slots
                          (methods ...)
                          (initializers ...)
                          ((super . args*) . init))
       #'(object-definition (object-name)
                            ()
                            (supers ... super)
                            slots
                            (methods
                             ...
                             ((*init* . args)
                              (invoke-special super (this)
                                              '*init*
                                              . args*)
                              initializers ...
                              . init))
                            ()
                            ()))
      )))

(define-syntax-rule (define-object (object-name . args) . spec)
  (object-definition (object-name . args)
                     #;args
                     args
                     #;supers
                     ()
                     #;slots
                     ()
                     #;methods
                     ()
                     #;initializers
                     ()
                     #;spec
                     spec))

(define (keyword->symbol kw)
  (string->symbol (keyword->string kw)))

(define (symbol->keyword s)
  (string->keyword (symbol->string s)))

(define-syntax-rule (define-type (type-name . fields))
  (type-definition type-name fields #;slots () #;initializers (begin)))

(define-syntax type-definition
  (lambda (stx)
    (syntax-case stx (:=)
      ((_ type-name () ((slot-symbol . slot-spec) ...) (initializers ...))
       #'(define-simple-class type-name (java.lang.Cloneable)
           (slot-symbol . slot-spec)
           ...
           ((assign source ::type-name)::void
            (set! slot-symbol (slot-ref source 'slot-symbol))
            ...)

           ((clone)::java.lang.Object
            (let ((copy (type-name)))
              (invoke copy 'assign (this))
              copy))

           ((prettyPrint port ::OutputPort)::void
            (kawa.lib.kawa.pprint:pprintStartLogicalBlock "[" #f "]" port)
            (try-finally
              (begin
               (display 'type-name port)
               (kawa.lib.kawa.pprint:pprintNewline 'miser port)
               (begin
                (write-char #\space port)
                (kawa.lib.kawa.pprint:pprintNewline 'fill port)
                (write 'slot-symbol port)
                (write-char #\: port)
                (write-char #\space port)
                (kawa.lib.kawa.pprint:pprintNewline 'linear port)
                (cond ((string? slot-symbol)
                       (write slot-symbol port))
                      ((java.util.Collection? slot-symbol)
                       (kawa.lib.kawa.pprint:pprintStartLogicalBlock "[" #f "]" port)
                       (try-finally
                        (for item in slot-symbol
                         (kawa.lib.kawa.pprint:pprint item port))
                        (kawa.lib.kawa.pprint:pprintEndLogicalBlock "]" port)))
                      (else
                       (kawa.lib.kawa.pprint:pprint slot-symbol port))))
               ...)
             (kawa.lib.kawa.pprint:pprintEndLogicalBlock "]" port)))

           ((toString)::java.lang.String
            (call-with-output-string 
              (lambda (port ::OutputPort) 
                (invoke (this) 'prettyPrint port))))

           ((equals another ::java.lang.Object)::boolean
            (and (instance? another type-name)
                 (let ((another ::type-name (as type-name another)))
                    (and (equal? slot-symbol (slot-ref another 
                                                       'slot-symbol))
                         ...))))

           ((hashCode)::int
            (let ((hash ::int (invoke 'type-name 'hashCode)))
              (set! hash (+ (* hash 31) (invoke slot-symbol 'hashCode)))
              ...
              hash))
             
           ((*init*)
            (initializers ... (values)))
          ))

      ((_ type-name (slot-keyword slot-type := value . fields)
          (slot-definitions ...) (initializers ...))
       (keyword? (syntax->datum #'slot-keyword))
       (with-syntax ((slot-symbol
                      (datum->syntax
                       stx
                       (keyword->symbol
                         (syntax->datum #'slot-keyword)))))
         #'(type-definition type-name fields
            (slot-definitions ... (slot-symbol type: slot-type))
            (initializers ... (set! slot-symbol value)))))

      ((_ type-name (slot-keyword slot-type . fields)
        (slot-definitions ...) initializers)
       (keyword? (syntax->datum #'slot-keyword))
       (with-syntax ((slot-symbol (datum->syntax
                                   stx
                                   (keyword->symbol
                                     (syntax->datum #'slot-keyword)))))
         #'(type-definition type-name fields
            (slot-definitions ... (slot-symbol type: slot-type))
            initializers)))
      )))

(define (clonable? object)::boolean
  (or (instance? object java.lang.Cloneable)
      (and (procedure? object)
	   (procedure? (procedure-property object 'clone)))))

(define (copy object)
  (cond
   ((instance? object java.util.WeakHashMap)
    (let* ((hash-map ::java.util.WeakHashMap object)
	   (cloned ::java.util.WeakHashMap
		   (java.util.WeakHashMap)))
      (for key in (hash-map:keySet)
	(let ((value (hash-map:get key)))
	  (cloned:put key value)))
      cloned))
   
   ((instance? object java.lang.Cloneable)
    (with-compile-options
     warn-unknown-member: #f
     (let ((clonable ::java.lang.Cloneable object))
       (clonable:clone))))
   
   ((procedure? object)
    (let ((clone (procedure-property object 'clone)))
      (if (procedure? clone)
	  (clone)
	  (error "Unable to clone procedure "object))))
   
   ((pair? object)
    (cons (copy (car object)) (copy (cdr object))))

   ((or (null? object)
	(number? object)
	(boolean? object))
    object)
   
   (else
    (error "Unable to clone "object" "(object:getClass)))))

(define-interface Matchable ()
  (matches? x)::boolean)

(define (match/equal? a b)
  (or (equal? a b)
      (and (Matchable? a)
           (let ((a ::Matchable a))
             (a:matches? b)))))

(define-syntax-rule (match expression (pattern actions* ... value) ...)
  (let ((evaluated expression))
    (match/evaluated evaluated (pattern actions* ... value) ...)))

(define-syntax match/evaluated
  (syntax-rules (::)
    ((match/evaluated value)
     ;; This behavior is unspecified, and an "unspecified"
     ;; value would also be fine here.
     (error 'no-matching-pattern value))

    ((match/evaluated value (pattern::type actions ...) final-clause)
     (match-clause ((pattern::type value))
                   (and)
                   ()
                   actions ...
                   (with-compile-options
                    warn-unreachable: #f
                    (match/evaluated value final-clause))))
    
    ((match/evaluated value (pattern actions ...) final-clause)
     (match-clause ((pattern value))
                   (and)
                   ()
                   actions ...
                   (with-compile-options
                    warn-unreachable: #f                   
                    (match/evaluated value final-clause))))
    
    ((match/evaluated value (pattern::type actions ...) . clauses)
     (match-clause ((pattern::type value))
                   (and)
                   ()
                   actions ...
                   (match/evaluated value . clauses)))
    
    ((match/evaluated value (pattern actions ...) . clauses)
     (match-clause ((pattern value))
                   (and)
                   ()
                   actions ...
                   (match/evaluated value . clauses)))
    ))

(define-syntax match-clause
  (lambda (stx)
    (syntax-case stx (quasiquote
                      unquote quote unquote-splicing
                      and _ list %typename :: $lookup$)
      ((match-clause () condition bindings actions ... alternative)
       #'(check/unique condition bindings #f () ()
                       actions ... alternative))

      ((match-clause (((list items ...) root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((`(,items ...) root) . rest)
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause (((list items ... . last) root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((`(,items ... . ,last) root) . rest)
                       condition
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`,pattern::type root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((pattern::type root) . rest)
                       condition
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`,pattern root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((pattern root) . rest)
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause ((,value::type root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions
                        ...
                        (instance? root type)
                        (match/equal? value root))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((,value root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions ... (match/equal? value root))
                       bindings
                       actions ... alternative))

      ((match-clause ((,@predicate root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions ... (predicate root))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((_::type root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions ... (instance? root type))
                       bindings
                       actions ... alternative))

      ((match-clause ((_ root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause ((variable ::type root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       (identifier? #'variable)
       #'(match-clause rest
                       (conditions ... (instance? root type))
                       ((variable ::type root) . bindings)
                       actions ... alternative))
      
      ((match-clause ((variable root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       (identifier? #'variable)
       #'(match-clause rest
                       condition
                       ((variable root) . bindings)
                       actions ... alternative))

      ((match-clause (('datum root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ... (match/equal? root 'datum))
                       bindings
                       actions ... alternative))

      ((match-clause ((object:key root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ... (match/equal? root
                                                         object:key))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`(left::type . right) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause ((`left::type (car root))
                        (`right (cdr root)) . rest)
                       (and conditions ... (pair? root))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`(left . right) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause ((`left (car root)) (`right (cdr root)) . rest)
                       (and conditions ... (pair? root))
                       bindings
                       actions ... alternative))

      ((match-clause ((`datum root) . rest)
                     conditions
                     bindings
                     actions ... alternative)
       #'(match-clause (('datum root) . rest)
                        conditions
                       bindings
                       actions ... alternative))
      
      ((match-clause (((_ . fields) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause (((%typename . fields) root) . rest)
                       (and conditions ...)
                       bindings
                       actions ... alternative))
      
      ((match-clause (((%typename type) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ...)
                       bindings
                       actions ... alternative))

      ((match-clause (((%typename type key pat . etc) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       (and (keyword? (syntax->datum #'key))
            (identifier? #'type))
       (with-syntax ((name (datum->syntax
                            stx
                            (keyword->symbol (syntax->datum #'key)))))
         #'(match-clause (((%typename type . etc) root)
                          (pat (field (as type root) 'name)) . rest)
                         (and conditions ...)
                         bindings
                         actions ... alternative)))

      ((match-clause (((typename . fields) root) . rest)
                     (and conditions ...)
                     (bindings ...)
                     actions ... alternative)
       (and (identifier? #'typename) (identifier? #'root))
       #'(match-clause (((%typename typename . fields) root) . rest)
                       (and conditions ... (instance? root typename))
                       (bindings ... (root ::typename root))
                       actions ... alternative))

      
      ((match-clause (((typename . fields) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       (identifier? #'typename)
       #'(match-clause (((%typename typename . fields) root) . rest)
                       (and conditions ... (instance? root typename))
                       bindings
                       actions ... alternative))

      ((match-clause ((literal root) . rest)
                     (and conditions ...)
                     bindings
                     actions ...)
       #'(match-clause rest
                       (and conditions ... (match/equal? literal root))
                       bindings
                       actions ...))
      )))

(define-syntax check/unique
  (lambda (stx)
    "add equality checks for repeated identifiers in patterns and remove them from bindings"
    (syntax-case stx (and)
      ((check/unique condition #;unchecked ()
                     #;currently-checked #f
                     #;checked ()
                     #;final bindings actions ... alternative)
       #'(if condition
             (let bindings actions ...)
             alternative))

      ;; check the next binding from the list
      ((check/unique condition
                     ((variable type ... path) . bindings)
                     #f
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique condition
                       bindings
                       (variable type ... path)
                       bindings/checked
                       bindings/final
                       actions ... alternative))

      ;; the binding is present: add equality check
      ((check/unique (and conditions ...)
                     ((variable type ... path) . bindings)
                     (variable+ type+ ... path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       (bound-identifier=? #'variable #'variable+)
       #'(check/unique (and conditions ... (match/equal? path path+))
                       bindings
                       (variable+ type+ ... path+)
                       bindings/checked
                       bindings/final
                       actions ... alternative))
      
      ;; the binding is absent: go on
      ((check/unique conditions
                     ((variable type ... path) . bindings)
                     (variable+ type+ ... path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique conditions
                       bindings
                       (variable+ type+ ... path+)
                       ((variable type ... path) . bindings/checked)
                       bindings/final
                       actions ... alternative))

      ;; add binding to the "checked" list
      ;; (and possibly start over)
      ((check/unique conditions
                     ()
                     (variable type ... path)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique conditions
                       bindings/checked
                       #f
                       ()
                       ((variable type ... path) . bindings/final)
                       actions ... alternative))
      )))

(define-syntax and-let*
  (lambda (stx)
    (syntax-case stx (::)

      ((_)
       #'#t)

      ((_ ())
       #'#t)

      ((_ () . body)
       #'(let () . body))

      ((_ ((name binding) . rest) . body)
       (identifier? #'name)
       #'(let ((name binding))
           (and name
                (and-let* rest
                  . body))))

      ((_ ((name :: type binding) . rest) . body)
       (identifier? #'name)
       #'(let ((value binding))
           (and (instance? value type)
                value
                (let ((name ::type value))
                  (and-let* rest
                    . body)))))

      ((_ ((name :: type) . rest) . body)
       (identifier? #'name)
       #'(and (instance? name type)
              name
              (let ((name ::type (as type name)))
                (and-let* rest
                  . body))))

      ((_ ((value binding) . rest) . body)
       #'(match binding
           (value
            (and-let* rest
              . body))
           (_ #f)))

      ((_ ((condition) . rest) . body)
       #'(and condition
              (and-let* rest . body)))

      ((_ ((value * ... expression) . rest) . body)
       (identifier? #'value)
       #'(call-with-values (lambda () expression)
           (lambda args
             (match args
               (`(,value ,* ... . ,_)
                (and value
                     (and-let* rest . body)))
               (_ #f)))))

      ((_ ((value ... expression) . rest) . body)
       #'(call-with-values (lambda () expression)
           (lambda args
             (match args
               (`(,value ... . ,_)
                (and-let* rest . body))
               (_ #f)))))

      )))

(define-syntax match-let*
  (lambda (stx)
    (syntax-case stx ()
      ((_ ((pattern value) . rest) . body)
       (identifier? #'pattern)
       #'(let ((pattern value))
           (match-let* rest . body)))
      
      ((_ ((pattern::type value) . rest) . body)
       #'(match value
           (pattern
            (match-let* rest . body))
           (_
            (error "Value failed to match pattern: "'value 'pattern))))
      
      ((_ ((pattern value) . rest) . body)
       #'(match value
           (pattern
            (match-let* rest . body))
           (_
            (error "Value failed to match pattern: "'value 'pattern))))
      ((_ () . body)
       #'(let () . body)))))

(define-syntax lambda*
  (lambda (stx)
    (syntax-case stx ()
      ((_ args . body)
       (identifier? #'args)
       #'(lambda args . body))

      ((_ args . body)
       #'(%lambda* args #;req () #;opt () #;kw ()
                     #;destruct () body)))))

(define-syntax %lambda*
  (lambda (stx)
    (syntax-case stx (:= ::)
            
      ((_ () (req ...) (opt ...) (kw ...) (pat ...) (:: type . body))
       #'(lambda (req ... #!optional opt ... #!key kw ...) :: type
            (match-let* (pat ...) . body)))
      
      ((_ tail (req ...) (opt ...) (kw ...) (pat ...) (:: type . body))
       (identifier? #'tail)
       #'(lambda (req ... #!optional opt ... #!key kw ... #!rest tail) :: type
            (match-let* (pat ...) . body)))

      ((_ () (req ...) (opt ...) (kw ...) (pat ...) body)
       #'(lambda (req ... #!optional opt ... #!key kw ...)
           (match-let* (pat ...) . body)))
      
      ((_ tail (req ...) (opt ...) (kw ...) (pat ...) body)
       (identifier? #'tail)
       #'(lambda (req ... #!optional opt ... #!key kw ... #!rest tail)
           (match-let* (pat ...) . body)))
      
      ;; keyword arguments:
      
      ((_ (key pattern :: type := init . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))

       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym :: type init))
                       (pat ... (pattern sym)) body)))

      ((_ (key pattern :: type . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))
       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym :: type #!null))
                       (pat ... (pattern sym)) body)))
      
      ((_ (key pattern := init . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))
       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym init))
                       (pat ... (pattern sym)) body)))

      ((_ (key pattern . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))
       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym))
                       (pat ... (pattern sym)) body)))

      ;; optional arguments:
      
      ((_ (var :: type := init . rest) req (opt ...) kw pat body)
       (identifier? #'var)
       #'(%lambda* rest req (opt ... (var :: type init)) kw pat body))

      ((_ (pattern :: type := init . rest) req (opt ...) kw (pat ...) body)
       #'(%lambda* rest req (opt ... (var :: type init)) kw
                     (pat ... (pattern var)) body))

      ((_ (var := init . rest) req (opt ...) kw pat body)
       (identifier? #'var)
       #'(%lambda* rest req (opt ... (var init)) kw pat body))

      ((_ (pattern := init . rest) req (opt ...) kw (pat ...) body)
       #'(%lambda* rest req (opt ... (var init)) kw
                     (pat ... (pattern var)) body))

      ;; required arguments:
      
      ((_ (var :: type . rest) (req ...) opt kw pat body)
       (identifier? #'var)
       #'(%lambda* rest (req ... var :: type) opt kw pat body))

      ((_ (var . rest) (req ...) opt kw pat body)
       (identifier? #'var)
       #'(%lambda* rest (req ... var) opt kw pat body))

      ((_ (pattern . rest) (req ...) opt kw (pat ...) body)
       #'(%lambda* rest (req ... var) opt kw
                     (pat ... (pattern var)) body))
      
      )))


(define-syntax define*
  (syntax-rules (is ::)
    ((_ (is arg special?) . body)
     (define* (special? arg) . body))

    ((_ (is arg-1 related-to? arg-2) . body)
     (define* (related-to? arg-1 arg-2) . body))

    ((_ ((head . tail) . args) . body)
     (define* (head . tail) (lambda* args . body)))

    ((_ (name . args) . body)
     (define name (lambda* args . body)))
    
    ))

(define-syntax-rule (with-procedure-properties ((name value) ...)
                       procedure)
  (let ((proc procedure))
    (set-procedure-property! proc 'name value)
    ...
    proc))

(e.g.
  (call-with-input-string "java.util.Map[KeyType ValueType]" read)
===> ($bracket-apply$ java.util.Map KeyType ValueType))

(define-syntax-rule (specialize generic-type concrete-types ...)
  ($bracket-apply$ generic-type concrete-types ...))

(define-syntax mapping
  (syntax-rules (::)
    ((mapping (object::key-type)::value-type default)
     (let* ((entries ::java.util.Map ((specialize java.util.HashMap 
                                                  key-type value-type)))
            (getter (lambda (object::key-type)::value-type
                      (if (entries:containsKey object)
                          (entries:get object)
                          default))))
       (set! (setter getter) (lambda (arg value)
                               (entries:put arg value)))
       (with-procedure-properties ((table entries))
          getter)))

    ((mapping (object::key-type) default)
     (mapping (object::key-type)::java.lang.Object
               default))

    ((mapping (object)::value-type default)
     (mapping (object::java.lang.Object)::value-type
               default))

    ((mapping (object) default)
     (mapping (object::java.lang.Object)::java.lang.Object
              default))
    ))

(define-syntax define-mapping
  (syntax-rules (::)
    ((define-mapping (mapping-name object::key-type)::value-type
       default)
     (define-early-constant mapping-name
       (with-procedure-properties ((name 'mapping-name))
         (mapping (object::key-type)::value-type default))))

    ((define-mapping (mapping-name object::key-type) default)
     (define-mapping (mapping-name object::key-type)
       ::java.lang.Object
       default))

    ((define-mapping (mapping-name object)::value-type default)
     (define-mapping (mapping-name object::java.lang.Object)
       ::value-type
       default))

    ((define-mapping (mapping-name object) default)
     (define-mapping (mapping-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

(define (keys dict)
  (let ((table ::java.util.Map (procedure-property dict 'table)))
    (table:keySet)))

(define (inverse function)
  (procedure-property function 'inverse))

(set! (setter inverse)
      (lambda (function value)
        (set! (procedure-property function 'inverse) value)))

(define-syntax bimapping
  (syntax-rules (::)
    ((bimapping (object::key-type)::value-type default)
     (let* ((entries (make-hash-table[key-type value-type]))
            (inverse-entries (make-hash-table[value-type key-type]))
            (getter (lambda (object)
                      (hash-ref entries object
                                (lambda () default))))
            (inverse-getter (lambda (object)
                              (hash-ref inverse-entries object
                                        (lambda ()
                                          (hash-ref entries object
                                                    (lambda () default)))))))
       (set! (setter getter) (lambda (arg value)
                               (entries:put arg value)
                               (inverse-entries:put value arg)))
       (set! (setter inverse-getter) (lambda (arg value)
                                       (entries:put arg value)
                                       (inverse-entries:put value arg)))
       (set-procedure-property! inverse-getter 'table inverse-entries)
       (set-procedure-property! inverse-getter 'inverse getter)
       (with-procedure-properties ((table entries)
                                   (inverse inverse-getter))
          getter)))
    ((bimapping (object::key-type) default)
     (bimapping (object::key-type)::java.lang.Object
               default))

    ((bimapping (object)::value-type default)
     (bimapping (object::java.lang.Object)::value-type
               default))

    ((bimapping (object) default)
     (bimapping (object::java.lang.Object)::java.lang.Object
              default))
    ))

(define-syntax define-bimapping
  (syntax-rules (::)
    ((define-bimapping (bimapping-name object::key-type)::value-type
       default)
     (define-early-constant bimapping-name
       (with-procedure-properties ((name 'bimapping-name))
         (bimapping (object::key-type)::value-type default))))

    ((define-bimapping (bimapping-name object::key-type) default)
     (define-bimapping (bimapping-name object::key-type)
       ::java.lang.Object
       default))

    ((define-bimapping (bimapping-name object)::value-type default)
     (define-bimapping (bimapping-name object::java.lang.Object)
       ::value-type
       default))

    ((define-bimapping (bimapping-name object) default)
     (define-bimapping (bimapping-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

(define-syntax attribute
  (syntax-rules (::)
    ((attribute (object::key-type)::value-type default)
     (let ((table ::java.util.Map
                  ((specialize java.util.WeakHashMap
                               key-type value-type))))
       (define (create table::java.util.WeakHashMap)
         (let ((getter ::procedure
                       (lambda (object::key-type)::value-type
                         (if (table:contains-key object)
                             (table:get key)
                             default))))
           (set! (setter getter)
                 (lambda (arg::key-type value::value-type)
                   (table:put arg value)))
           (with-procedure-properties ((table table)
                                       (clone (lambda ()
                                                (create (copy table)))))
            getter)))

       (create table)))

    ((attribute (object::key-type) default)
     (attribute (object::key-type)::java.lang.Object
               default))

    ((attribute (object)::value-type default)
     (attribute (object::java.lang.Object)::value-type
               default))

    ((attribute (object) default)
     (attribute (object::java.lang.Object)::java.lang.Object
               default))
    ))

;; attribute+ is like attribute but it stores the default
;; value for every enquired object
(define-syntax attribute+
  (syntax-rules (::)
    ((attribute+ (object::key-type)::value-type default)
     (let ((table ::java.util.Map
                  ((specialize java.util.WeakHashMap
                                    key-type value-type))))
       (define (create table::java.util.WeakHashMap)
         (let ((getter ::procedure
                       (lambda (object::key-type)::value-type
                         (if (table:contains-key object)
                             (table:get object)
                             (let ((value default))
                                (table:put object value)
                                value)))))
           (set! (setter getter)
                 (lambda (arg::key-type value::value-type)
                   (table:put arg value)))
           (with-procedure-properties ((table table)
                                       (clone (lambda ()
                                                (create (copy table)))))
              getter)))

       (create table)))

    ((attribute+ (object::key-type) default)
     (attribute+ (object::key-type)::java.lang.Object
                default))

    ((attribute+ (object)::value-type default)
     (attribute+ (object::java.lang.Object)::value-type
                default))

    ((attribute+ (object) default)
     (attribute+ (object::java.lang.Object)::java.lang.Object
                default))
    ))

(define-syntax define-attribute
  (syntax-rules (::)
    ((define-attribute (attribute-name object::key-type)
       ::value-type
       default)
     (define-early-constant attribute-name
       (with-procedure-properties
        ((name 'attribute-name))
        (attribute (object::key-type)::value-type default))))

    ((define-attribute (attribute-name object::key-type) default)
     (define-attribute (attribute-name object::key-type)
       ::java.lang.Object
       default))

    ((define-attribute (attribute-name object)::value-type default)
     (define-attribute (attribute-name object::java.lang.Object)
       ::value-type
       default))

    ((define-attribute (attribute-name object) default)
     (define-attribute (attribute-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

(define-syntax define-attribute+
  (syntax-rules (::)
    ((define-attribute+ (attribute-name object::key-type)
       ::value-type
       default)
     (define-early-constant attribute-name
       (with-procedure-properties
        ((name 'attribute-name))
        (attribute+ (object::key-type)::value-type default))))

    ((define-attribute+ (attribute-name object::key-type) default)
     (define-attribute+ (attribute-name object::key-type)
       ::java.lang.Object
       default))

    ((define-attribute+ (attribute-name object)::value-type
       default)
     (define-attribute+ (attribute-name object::java.lang.Object)
       ::value-type
       default))

    ((define-attribute+ (attribute-name object) default)
     (define-attribute+ (attribute-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

(define-syntax-rule (unset! (mapping object))
  (let ((table ::java.util.Map (procedure-property mapping 'table)))
    (table:remove object)))

(define (reset! mapping)::void
  (let ((table ::java.util.Map (procedure-property mapping 'table)))
    (table:clear)))

(define-syntax-rule (assigned? (mapping key))
  (let ((table ::java.util.Map (procedure-property mapping 'table)))
    (table:contains-key key)))

(define-syntax-rule (update! (mapping object) expression)
  (let ((value expression))
    (unless (equal? (mapping object) value)
      (set! (mapping object) value))))

(define-syntax curried
  (lambda (stx)
    (syntax-case stx (:: :=)

      ((_ kw (key arg :: type := value . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (key arg :: type . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (key arg := value . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg) (curried kw args body)))
      
      ((_ kw (key arg . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg) (curried kw args body)))

      ((_ kw (arg :: type := value . args) body)
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (arg :: type . args) body)
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (arg := value . args) body)
       #'(kw (arg) (curried kw args body)))
      
      ((_ kw (arg . args) body)
       #'(kw (arg) (curried kw args body)))
      
      ((_ kw () body)
       #'body)
      )))

(define-syntax curried-application
  (lambda (stx)
    (syntax-case stx (:: :=)
      ((_ procedure)
       #'procedure)

      ((_ procedure key arg :: type := value args ...)
       (keyword? (syntax->datum #'key))      
       #'(curried-application (procedure arg) args ...))

      ((_ procedure key arg :: type args ...)
       (keyword? (syntax->datum #'key))
       #'(curried-application (procedure arg) args ...))

      ((_ procedure key arg := value args ...)
       (keyword? (syntax->datum #'key))
       #'(curried-application (procedure arg) args ...))

      ((_ procedure key arg args ...)
       (keyword? (syntax->datum #'key))
       #'(curried-application (procedure arg) args ...))
      
      ((_ procedure arg :: type := value args ...)
       #'(curried-application (procedure arg) args ...))

      ((_ procedure arg :: type args ...)
       #'(curried-application (procedure arg) args ...))

      ((_ procedure arg := value args ...)
       #'(curried-application (procedure arg) args ...))

      ((_ procedure arg args ...)
       #'(curried-application (procedure arg) args ...))
      )))

(define-syntax cache
  (syntax-rules (::)
    ((cache args::type body)
     (let* ((cached (curried attribute+ args body))
            (invoker (lambda* args::type
                                (curried-application cached . args))))
       (with-procedure-properties ((cache cached))
         invoker)))
    ((cache args body)
     (let* ((cached (curried attribute+ args body))
            (invoker (lambda* args
                                (curried-application cached . args))))
       (with-procedure-properties ((cache cached))
         invoker)))))
    
(define-syntax define-cache
  (syntax-rules (::)
    ((define-cache (name . args)::type body)
     (define-early-constant name
       (cache args::type body)))

    ((define-cache (name . args) body)
     (define-early-constant name
       (cache args body)))
    ))

(define (invalidate! cache . point)
  (let ((table ::java.util.Map (procedure-property cache 'table)))
    (match point
      ('() (table:clear))
      (`(,point) (table:remove point))
      (`(,head . ,tail)
       (apply invalidate! (cache head) tail)))))

(define (invalidate-cache! invoker . point)
  (apply invalidate! (procedure-property invoker 'cache) point))

(define-object (immutable-pair car cdr)

  (define (setCar value)
    (error "The pair is immutable: " (this)))

  (define (setCdr value)
    (error "The pair is immutable: "(this)))
  (pair car cdr))

(define-cache (hash-cons head tail)
  (immutable-pair head tail))

(define-syntax maps
  (syntax-rules (to:)
    ((_ input-types to: output-type + ...)
     procedure)))

(define-syntax !maps
  (syntax-rules (to:)
    ((_ input-types to: output-type + ...)
     procedure)))

(define-alias EnumSet java.util.EnumSet)

(define-syntax-rule (list-of type)
  list)

(define-syntax-rule (set-of type)
  (specialize java.util.Set type))

(define-syntax-rule (EnumSetOf type)
  (specialize java.util.EnumSet type))

(define-syntax-rule (vector-of type)
  vector)

(define-syntax-rule (sequence-of type)
  sequence)

(define-syntax-rule (array-of type)
  (specialize type))

(define-syntax-rule (parameter-of type)
  (specialize parameter type))

(define-syntax subtype-of
  (syntax-rules ()
    ((subtype-of supertype . _)
     supertype)))

(define-syntax-rule (either type ...)
  java.lang.Object)

(define-syntax-rule (maybe type)
  (either type #!null))

(define-syntax-rule (Values type ...)
  java.lang.Object)

(define-syntax-rule (unquote x)
  java.lang.Object)

(define (any satisfying? elements)
  (escape-with return
    (for x in elements
      (let ((result (satisfying? x)))
	(when result
	  (return result))))
    #f))

(e.g.
 (any even? '(1 2 3)))

(define (none satisfying? elements)
  (not (any satisfying? elements)))

(e.g.
 (none odd? '(2 4 6)))

(define (any. satisfying? elements)
  (match elements
    (`(,h . ,t)
     (or (satisfying? h)
	 (any. satisfying? t)))
    ('()
     #f)
    (x
     (satisfying? x))))
(e.g.
 (any. zero? '(3 2 1 . 0)))

(define (every satisfying? elements)::boolean
  (escape-with return
    (for x in elements
      (unless (satisfying? x)
	(return #f)))
    #t))

(e.g.
 (every even? '(2 4 6)))

(define (every. satisfying? elements)
  (match elements
    (`(,h . ,t)
     (and (satisfying? h)
	  (every. satisfying? t)))
    ('()
     #t)
    (x
     (satisfying? x))))

(e.g.
 (every. even? '(2 4 6 . 8)))

(define (only cool? stuff)
  (let* ((result (cons #f '()))
	 (cone result))
    (for x in stuff
      (when (cool? x)
	(set-cdr! cone (cons x '()))
	(set! cone (cdr cone))))
    (cdr result)))

(e.g.
 (only even? '(1 2 3 4 5 6))
 ===> (2 4 6))

(define (fold-left f x0 . xs*)
  
  (define (fold-left1 xs::java.util.List)
    (for x in xs
      (set! x0 (f x0 x)))
    x0)

  (define (fold-left2 xs1::java.util.List xs2::java.util.List)
    (let ((xi1 ::java.util.Iterator (xs1:listIterator))
	  (xi2 ::java.util.Iterator (xs2:listIterator)))
      (let loop ((xo x0))
	(if (and (xi1:hasNext) (xi2:hasNext))
	    (loop (f xo (xi1:next) (xi2:next)))
	    xo))))

  (define (fold-left3 xs1::java.util.List
		      xs2::java.util.List
		      xs3::java.util.List)
    (let ((xi1 ::java.util.Iterator (xs1:listIterator))
	  (xi2 ::java.util.Iterator (xs2:listIterator))
	  (xi3 ::java.util.Iterator (xs3:listIterator)))
      (let loop ((xo x0))
	(if (and (xi1:hasNext) (xi2:hasNext) (xi3:hasNext))
	    (loop (f xo (xi1:next) (xi2:next) (xi3:next)))
	    xo))))

  (define (fold-left* . xs*)
    (let ((iterators (map (lambda (x::java.util.List)
			    (x:listIterator))
			  xs*)))
      (let loop ((xo x0))
	(if (every (lambda (it::java.util.Iterator)
		     (it:hasNext))
		   iterators)
	    (loop
	     (apply
	      f xo
	      (map (lambda (it::java.util.Iterator)
		     (it:next))
		   iterators)))
	    xo))))
  (cond
   ((null? xs*) x0)
   ((null? (cdr xs*)) (fold-left1 (car xs*)))
   ((null? (cddr xs*)) (fold-left2 (car xs*)
				   (cadr xs*)))
   ((null? (cdddr xs*)) (fold-left3 (car xs*)
				    (cadr xs*)
				    (caddr xs*)))
   (else (apply fold-left* xs*))))

(e.g.
 (fold-left (lambda (a b) `(,a + ,b)) 'e '(a b c d))
 ===> ((((e + a) + b) + c) + d))

(define (fold-right f x0 . xs*)
  (define (fold-right1 f x0 xs)
    (if (null? xs)
	x0
	(f (car xs) (fold-right1 f x0 (cdr xs)))))

  (define (fold-right2 f x0 xs xs2)
    (if (or (null? xs) (null? xs2))
	x0
	(f (car xs) (car xs2)
	   (fold-right2 f x0 (cdr xs) (cdr xs2)))))

  (define (fold-right* f x0 . xs*)
    (if (any null? xs*)
	x0
	(apply f (fold-right1
		  (lambda (x y)
		    (cons (car x) y))
		  (list (apply fold-right* f x0 (map cdr xs*)))
		  xs*))))
  (cond
   ((null? xs*) x0)
   ((null? (cdr xs*)) (fold-right1 f x0 (car xs*)))
   ((null? (cddr xs*)) (fold-right2 f x0 (car xs*) (cadr xs*)))
   (else (apply fold-right* f x0 xs*))))

(e.g.
 (fold-right (lambda (a b) `(,a + ,b)) 'e '(a b c d))
 ===> (a + (b + (c + (d + e)))))

(define (nothing . _)::void (values))

(define (never . _)::boolean #f)

(define (always . _) ::boolean #t)

(define (negation proc)
  (lambda args
    (not (apply proc args))))

(define (find satisfying-element?::(maps (,a) to: boolean) in::sequence)
  (escape-with return
    (for-each (lambda (x)
		(when (satisfying-element? x)
		  (return x)))
	      in)
    #!null))

(e.g.
 (find even? '(1 2 3)) ===> 2)

(define (map! f inout . in*)
  (cond
   ((isnt inout list?)
    (cond 
     ((null? in*)
      (for i from 0 below (length inout)
	   (set! (inout i) (f (inout i))))
      inout)
     ((null? (cdr in*))
      (escape-with return
	(let ((i 0)
	      (n (length inout)))
	  (for x in (cdr in*)
	    (set! (inout i) (f (inout i) x))
	    (set! i (+ i 1))
	    (when (is i >= n)
	      (return inout)))
	  (return inout))))
     (else
      (let ((n (length inout))
	    (its (map (lambda (l::java.util.List)
			(l:listIterator))
		      in*)))
	(escape-with return
	  (for i from 0 below n
	       (if (every (lambda (it::java.util.Iterator)
			    (it:hasNext)) its)
		   (set! (inout i)
		     (apply f (inout i)
			    (map (lambda (it::java.util.Iterator)
				   (it:next)) its)))
		   (return inout)))
	  (return inout))))))
   ((null? in*)
    (let loop ((tip inout))
      (if (pair? tip)
	  (begin
	    (set! (car tip) (f (car tip)))
	    (loop (cdr tip)))
	  inout)))
   ((null? (cdr in*))
    (let loop ((tip1 inout)
	       (tip2 (car in*)))
      (if (and (pair? tip1) (pair? tip2))
	  (begin
	    (set! (car tip1) (f (car tip1) (car tip2)))
	    (loop (cdr tip1) (cdr tip2)))
	  inout)))
   ((null? (cddr in*))
    (let loop ((tip1 inout)
		  (tip2 (car in*))
		  (tip3 (cadr in*)))
	 (if (and (pair? tip1) (pair? tip2) (pair? tip3))
	     (begin
	       (set! (car tip1) (f (car tip1) (car tip2) (car tip3)))
	       (loop (cdr tip1) (cdr tip2) (cdr tip3))
	       inout))))
   (else
    (let loop ((tip inout)
	       (tips in*))
	 (if (and (pair? tip) (every pair? tips))
	     (begin
	       (set! (car tip) (apply f (car tip) (map car tips)))
	       (loop (cdr tip) (map! cdr tips)))
	     inout)))))

(define (only. satisfying? elements . moreso)
  (cond ((null? elements)
	 (apply values '() moreso))
	((pair? elements)
	 (let ((result (cons (car elements) (map car moreso))))
	   (cond
	    ((apply satisfying? result)
	     (map! list result)
	     (let ((tips (map values result)))
	       (let loop ((elements (cdr elements))
			  (moreso (map cdr moreso)))
		 (cond
		  ((null? elements)
		   (apply values result))
		  ((pair? elements)
		   (when (apply satisfying? (car elements)
				(map car moreso))
		     (map! (lambda (tip elem)
			     (set-cdr! tip (cons (car elem) '()))
			     (cdr tip))
			   tips (cons elements moreso)))
		   (loop (cdr elements)
			 (map cdr moreso)))
		  ((apply satisfying? elements moreso)
		   (map! (lambda (tip item)
			   (set-cdr! tip item)
			   tip)
			 tips (cons elements moreso))
		   (apply values result))
		  (else
		   (apply values result))))))
	    (else
	     (apply only. satisfying? (cdr elements)
		    (map cdr moreso))))))
	((apply satisfying? elements moreso)
	 (apply values elements moreso))
	(else
	 (apply values '() (map (lambda _ '()) moreso)))))

(e.g. (only. even? '(2 . 3)) ===> (2))

(e.g. (only. even? '(3 . 2)) ===> 2)

(e.g. (only. even? 2) ===> 2)

(e.g. (only. even? 3) ===> ())

(e.g. (only. (is (+ _ _) even?)
	     '(1 2 3 4 . 5) '(2 4 6 8 . 9))
      ===>    (  2   4 . 5)  (  4   8 . 9))

(define (concatenate list-of-lists)
  (apply append list-of-lists))

(e.g.
 (concatenate '((a b) (c) (d e f)))
 ===> (a b c d e f))

(define (append-map f l . ls)
  (if (null? ls)
    (concatenate (map f l))
   (concatenate (apply map f ls))))

(define (current-working-directory)::string
  (let ((working-directory ::java.io.File (java.io.File ".")))
    (working-directory:getAbsolutePath)))

(define (current-time-ms)::long
  (java.lang.System:currentTimeMillis))

(define-alias hypotenuse java.lang.Math:hypot)

(define-simple-class set (java.util.HashSet)
  ((toString)::String
   (let ((builder ::java.lang.StringBuilder (java.lang.StringBuilder)))
     (builder:append "[set")
     (for item in (this)
       (builder:append " ")
       (cond
	((or (string? item) (String? item))
	 (builder:append "\"")
	 (builder:append (item:toString))
	 (builder:append "\""))
	((char? item)
	 (builder:append "#\\")
	 (builder:append (as char item)))
	(else
	 (builder:append (item:toString)))))
     (builder:append "]")
     (builder:toString))))

(define* (is element in collection)
  (if (instance? collection java.util.Set)
      (let ((set ::java.util.Set (as java.util.Set collection)))
	(set:contains element))
      (any (is _ equal? element) collection)))

(define (empty? x)::boolean
  (or (and (is x gnu.lists.LList?)
	   (isnt x gnu.lists.Pair?))
      (and-let* ((x ::java.util.Collection))
	(x:isEmpty))
      (and-let* (((procedure? x))
		 (table ::java.util.Collection (procedure-property x 'table)))
	(empty? table))))

(define (union set . sets)
  (define (list-union a b)
    (fold-left (lambda (set element)
		 (if (is element in set)
		     set
		     `(,element . ,set)))
	       a b))
  (if (and (instance? set java.util.Set)
	   (instance? set java.lang.Cloneable))
      (with-compile-options
       warn-unknown-member: #f
       (let ((clone ::java.util.Set (set:clone)))
	 (for collection ::java.util.Collection in sets
	      (clone:addAll collection))
	 clone))
      (fold-left list-union set sets)))

(define (union! set::java.util.Set . sets)
  (for collection ::java.util.Collection in sets
       (set:addAll collection))
  set)

(e.g.
 (union '(a b c) '(b c d e))
 ===> (e d a b c))

(define (intersection set . sets)
  (define (list-intersection a b)
    (only (is _ in b) a))
  (if (and (instance? set java.util.Set)
	   (instance? set java.lang.Cloneable))
      (with-compile-options
       warn-unknown-member: #f
       (let ((clone ::java.util.Set (set:clone)))
	 (for collection ::java.util.Collection in sets
	      (clone:retainAll collection))
	 clone))
      (fold-left list-intersection set sets)))

(e.g.
 (intersection '(a b c) '(b c d) '(c d e))
 ===> (c))

(define (difference set . sets)
  (define (list-difference a b)
    (fold-left (lambda (set element)
		 (if (is element in set)
		     (only (isnt _ equal? element) set)
		     set))
	       a b))
  (if (and (instance? set java.util.Set)
	   (instance? set java.lang.Cloneable))
      (with-compile-options
       warn-unknown-member: #f
       (let ((clone ::java.util.Set (set:clone)))
	 (for collection ::java.util.Collection in sets
	      (clone:removeAll collection))
	 clone))
      (fold-left list-difference set sets)))

(e.g.
 (difference '(a b c) '(b c d))
 ===> (a))

(define (subset? a b)
  (if (instance? b java.util.Set)
      (let ((set ::java.util.Set (as java.util.Set b)))
	(set:containsAll a))
      (every (is _ in b) a)))

(e.g.
 (is '(a b) subset? '(b a c)))

(define (same-sets? a b)
  (and (is a subset? b)
       (is b subset? a)))

(e.g.
 (same-sets? '(a b c) '(b a c)))

(define-simple-class SharedThreadLocation (gnu.mapping.ThreadLocation)

  (location-name ::gnu.mapping.Symbol)
  (default-value)
  
  ((setWithSave value) access: 'synchronized
   (let* ((old-location (invoke-special gnu.mapping.ThreadLocation (this) 'get))
	  (new-location (gnu.mapping.SharedLocation
			 location-name
			 #!null
			 (java.lang.System:currentTimeMillis))))
     (invoke-special gnu.mapping.ThreadLocation (this) 'set new-location)
     (new-location:set value)
     old-location))
  
  ((setRestore old-location) access: 'synchronized
   (invoke-special gnu.mapping.ThreadLocation (this) 'set old-location))
  
  ((set value) access: 'synchronized
   (let ((location ::gnu.mapping.SharedLocation
		   (invoke-special gnu.mapping.ThreadLocation
				   (this) 'get)))
     (if location
	 (location:set value)
	 (let ((new-location (gnu.mapping.SharedLocation
			      location-name
			      #!null
			      (java.lang.System:currentTimeMillis))))
	   (invoke-special gnu.mapping.ThreadLocation (this) 'set new-location)
	   (new-location:set value)))))
  
  ((get) access: 'synchronized
   (let ((location ::gnu.mapping.SharedLocation
		   (invoke-special gnu.mapping.ThreadLocation
				   (this) 'get)))
     (if location
	 (location:get)
	 default-value)))
  
  ((*init* name ::gnu.mapping.Symbol value)
   (set! location-name name)
   (set! default-value value)
   (let ((new-location (gnu.mapping.SharedLocation
			location-name
			#!null
			(java.lang.System:currentTimeMillis))))
     (invoke-special gnu.mapping.ThreadLocation (this) 'set new-location)
     (new-location:set value))))

(define (make-shared-parameter name init #!optional (converter #!null))
  (unless (eq? converter #!null)
    (set! init (converter init)))
  (let* ((loc (SharedThreadLocation:new name init))
         (conv ::gnu.mapping.Procedure
               (if (or (eq? converter #!null)
                       (gnu.mapping.Procedure? converter))
                   converter
                   (lambda (x) (converter x)))))
    (gnu.mapping.LocationProc:new loc conv)))

(define-syntax define-parameter
  (syntax-rules (::)
    
    ((_ (parameter-name) :: type initial-value)
     (define-early-constant parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name) :: type)
     (define-early-constant parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name #!null)))
    
    ((_ (parameter-name) initial-value)
     (define-early-constant parameter-name :: parameter
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name))
     (define-early-constant parameter-name :: parameter
       (make-shared-parameter 'parameter-name #!null)))
    ))

(define-syntax define-parameter+
  (syntax-rules (::)
    
    ((_ (parameter-name) :: type initial-value)
     (define parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name) :: type)
     (define parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name #!null)))
    
    ((_ (parameter-name) initial-value)
     (define parameter-name :: parameter
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name))
     (define parameter-name :: parameter
       (make-shared-parameter 'parameter-name #!null)))
    ))

(define-syntax parameterize/update-sources
  (lambda (stx)
    (syntax-case stx ()
      ((_ ((param source) ...) body + ...)
       (with-syntax (((previous-value ...)
		      (generate-temporaries
		       #'(source ...))))
	 #'(parameterize ((param source) ...)
	     (let ((previous-value source) ...)
	       (try-finally
		(begin body + ...)
		(begin
		  (when (eqv? previous-value source)
		    (set! source (param)))
		  ...)))))))))

(define-syntax otherwise
  (syntax-rules ()
    ((_)
     #f)
    ((_ value)
     value)
    ((_ default . precedents)
     (or (otherwise . precedents) default))))

(define-syntax-rule (begin/or clause ...)
  (let ((result #f))
    (set! result (or clause result))
    ...
    result))

(define-syntax-rule (begin/and clause ...)
  (let ((result #t))
    (set! result (and clause result))
    ...
    result))

(define (memoize proc)
  (let ((table ::java.util.Map (java.util.HashMap)))
    (with-procedure-properties ((table table))
      (lambda args
        (if (table:contains-key args)
            (apply values (table:get args))
            (call-with-values (lambda () (apply proc args))
              (lambda result
                (table:put args result)
                (apply values result))))))))

(define-syntax-rule (define/memoized (name . args) . body)
  (define name (memoize (lambda args . body))))


(define-object (InputPortLineIterator port::InputPort)
  ::(specialize java.util.Iterator string)
  (define next-line ::(maybe (either string gnu.lists.EofClass)) #!null)

  (define (hasNext) ::boolean
    (unless next-line
      (set! next-line (read-line port)))
    (isnt next-line eof-object?))

  (define (next)
    (unless next-line
      (set! next-line (read-line port)))
    (unless (string? next-line)
      (throw (java.util.NoSuchElementException)))
    (let ((result next-line))
      (set! next-line #!null)
      result)))

(define-object (InputPortLines port::InputPort)
  ::(specialize java.lang.Iterable string)
  (define (iterator)::(specialize java.util.Iterator string)
    (InputPortLineIterator port)))

(define* (lines port ::InputPort := (current-input-port))
  ::(specialize java.lang.Iterable string)
  (InputPortLines port))
