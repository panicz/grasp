* The GRASP editor

GRASP is an extensible structural code editor for languages
that are based on s-expressions.

GRASP represents s-expressions as nestable boxes, such as
this one:

#+BEGIN_SRC
╭        ╭     ╮                      ╮
│ define │ ! n │                      │
│        ╰     ╯                      │
│   ╭    ╭        ╮                 ╮ │
│   │ if │ <= n 0 │                 │ │
│   │    ╰        ╯                 │ │
│   │                               │ │
│   │       1                       │ │
│   │                               │ │
│   │       ╭     ╭   ╭       ╮ ╮ ╮ │ │
│   │       │ * n │ ! │ - n 1 │ │ │ │ │
╰   ╰       ╰     ╰   ╰       ╯ ╯ ╯ ╯ ╯
#+END_SRC

The boxes can be edited using keyboard, but also using touch
interface/mouse pointer.

Most importantly, users can define their own extensions,
which occupy rectangular area, and present themselves and
behave in a custom (user-defined) way (this feature is
sometimes called /interactive visual syntax/, and has been
explained by Leif Andersen in [[https://www.youtube.com/watch?v=8htgAxJuK5c][this video]]).

Moreover, some of those extensions can be /maximized/,
playing the role of an entire application.

GRASP is not a single program. Instead it is a family of
programs that share a common structure (and most of their
code), and that can be run in various environments,
including (at the moment of writing) terminal, desktop and
Android. These programs are called /clients/ or /frontends/
of GRASP.

This document presents the complete source code for GRASP,
but more importantly, it instructs its readers how to define
new interactive extensions.

** About this document

This document is a literate program written in [[https://www.gnu.org/software/emacs/][Emacs]]
[[https://orgmode.org/][org-mode]]. It contains snippets that are assembled to produce
the actual program.

In order to extract the application code from this file, one
should execute the command ~M-x org-babel-tangle~ from
Emacs. The command will generate (or regenerate, as needed)
all the required files, and it can also be run from command
line using Emacs' batch mode:

#+BEGIN_SRC bash :tangle no
emacs --batch grasp.org -l org --eval "(org-babel-tangle)"
#+END_SRC

The files generated from this file will begin with
the following ~<<header>>~:

#+NAME: header
#+BEGIN_SRC scheme :tangle no
;; Note: this file was generated from the ~grasp.org~
;; document, which also serves as the project's documentation.
;; 
;; Please do not edit this file directly, as all the changes
;; will be overwritten after code regeneration, and modify
;; the ~grasp.org~ file instead.

#+END_SRC

The document assumes that the Reader has some familiarity
with the Scheme programming language, but if you're
completely new to Scheme, don't let that assumption scare
you off, especially if you're familiar with modern Object
Oriented languages such as Java or C#. The mainstream
languages tend to have more complex and rigid syntax, while
the syntax of Scheme is much simpler and more flexible.

Also, if you find something to be unclear, or have an idea
how this text could be improved, feel free to file an issue
or open a pull request.

** The language used for developing GRASP

GRASP is written in Kawa, which is a little known language
based on Scheme that runs on the Java Virtual Machine.

Kawa is an interesting language, because it extends Scheme
with the type system of Java, which means in particular
that:
- it is possible to use existing Java classes from within
  Kawa code
- it is possible to define new Java classes from Kawa
- it supports type annotations of variables and methods

Being a Scheme, Kawa provides good support for extending the
syntax of the language via the mechanism called /macros/.

As a matter of fact, it is a common adage among Lisp and
Scheme programmers that in order to build a program, it is
usually most convenient to first construct a language suited
for building that program - which is exactly what we're
going to do in the first chapter of this book.

***** Technical remarks

Since the 6th revision of the Scheme language specification
([[https://www.r6rs.org/][R6RS]]) the reader of the Scheme language became
case-sensitive, which means that symbols ~foo~, ~Foo~ and
~FOO~ are considered distinct.

Kawa Scheme implements this properly. However, during
compilation of a ~.scm~ file the Kawa compiler can generate
many ~.class~ files, whose names are derived from the names
of classes defined in the ~.scm~ file, as well as the name
of the ~.scm~ file itself.

This can cause trouble on case-insensitive file systems
(which in practice means mainly the machines running under
the Windows operating system). For this reason it is
discouraged to name files and classes with names that only
differ with their case.

(This restriction does not apply to names introduced by
the ~lambda~ and ~let~ forms, i.e. function parameters
and local variables.)

The code snippets from this chapter will be placed in the
~language/extensions.scm~ file.

#+BEGIN_SRC scheme :tangle language/extensions.scm :mkdirp yes :noweb yes
<<header>>
(module-name (language extensions))
;; mind that, for some reason, importing ANY module from this
;; one causes the compiler to break, probably because of the
;; way macroexpander is implemented in Kawa. This could likely
;; be solved by splitting this module into a bunch of smaller
;; ones, to enforce the proper staging, but that would only
;; complicate things

#+END_SRC

*** Simple macros

The basic facility for defining macros is called
~syntax-rules~, which allows to express syntactic
transformations in terms of one or more /rewrite-rules/,
where each rule consists of a pattern and a template.

It is typically used in the following way:

#+BEGIN_SRC scheme :tangle no

;; note that this is not a valid code
(define-syntax <defined-keyword>
  (syntax-rules (<keywords> ...)
    (<pattern-1> <template-1>)
    (<pattern-2> <template-2>)
    ...))

#+END_SRC

where ~<keywords>~ are a list of symbols that are meant to
be treated as literals rather than variables inside patterns
(this should become clearer later).

**** The ~define-syntax-rule~ macro

We are going to start by defining a simplified version of
itself that is only going to be used when we have a simple
transform consisting of a single rewrite rule:

#+BEGIN_SRC scheme :tangle language/extensions.scm :comment link

(define-syntax define-syntax-rule
  (syntax-rules ()
    ((define-syntax-rule (<keyword> . <arguments>)
       <substitution>)
     (define-syntax <keyword>
       (syntax-rules ()
         ((<keyword> . <arguments>)
          <substitution>))))))

#+END_SRC

While it may yet be unclear why the above macro can be useful,
consider that if we had it available, we could have defined it
in terms of itself in the following way:

#+BEGIN_SRC scheme :tangle no

(define-syntax-rule (define-syntax-rule <keyword> . <arguments>)
  (define-syntax <keyword>
    (syntax-rules ()
      ((<keyword> . <arguments>)
       <substitution>))))

#+END_SRC

Of course, if we had the ~define-syntax-rule~ form
available, there would be no need for defining it!

**** The ~comment~ macro

We can now use it for defining our first utility macro,
namely ~comment~ - which discards all of its arguments.

#+BEGIN_SRC scheme :tangle language/extensions.scm :comment org

(define-syntax-rule (comment . <anything>)
  (values))

#+END_SRC

This macro allows us to include some invalid code inside
program text, without the risk of crashing the program. For
example, we could include the content of the first snippet
from this section inside our ~comment~ form:

#+BEGIN_SRC scheme :tangle language/extensions.scm

;; this code is valid, even though the code
;; inside the ~comment~ form is not - that's
;; because it will be discarded according to
;; our earlier definition of the ~comment~
;; macro!
(comment
 (define-syntax <defined-keyword>
   (syntax-rules (<keywords> ...)
    (<pattern-1> <template-1>)
    (<pattern-2> <template-2>)
    ...)))

#+END_SRC

**** The ~assert~ macro

An assertion is a belief about a certain state of
affairs. In the context of programming assertions are often
expressed using the ~assert~ construct.

Since it is important to us to discover any false beliefs
that we might have, the typical interpretation of asserting
a false belief is to raise an error and stop the program:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (assert proposition)
  (or proposition
    (error "Assertion failed: "'proposition)))

#+END_SRC

**** The ~e.g.~ macro

Another simple and very useful macro is intended to be used
for writing examples of functions that we're going to be
using during the development.

The macro is going to use two helper function parameters,
namely ~(valid-example)~ and ~(invalid-example)~, which are
going to specify how to react to examples that are,
accordingly, valid and invalid. Those functions are going to
take three arguments:
1. the source expression of the example
2. the actual result of the expression
3. (optionally) the expected result of the expression

By default, the ~invalid-example~ function is going to
report an error, and the ~valid-example~ function is going
to return its second argument.

The functions are going to be defined using the [[https://srfi.schemers.org/srfi-39/srfi-39.html][SRFI-39
parameter objects]], so that the user would be able to tweak
their behavior (for example, to count the number of evaluated
examples)

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define invalid-example
  (make-parameter
    (lambda (expression result . expectation)
      (if (pair? expectation)
        (error "while evaluating\n\n  "
               expression
               "\n\nexpected:\n\n  "
               (car expectation)
               "\n\ngot:\n\n  "
               result)
        (error "expected "expression" to be non-#false")))))

(define valid-example
  (make-parameter
    (lambda (expression result . expectation)
      result)))

#+END_SRC

This time, we're actually going to be using multiple clauses,
so we'll use ~syntax-rules~ instead of ~define-syntax-rules~?

#+BEGIN_SRC scheme :tangle language/extensions.scm
(define-syntax e.g.
  (syntax-rules (===>)
    
    ((_ expression ===> value)
     (let ((result expression)
           (source 'expression)
           (expectation 'value))
       (if (equal? result expectation)
          ((valid-example) source result expectation)
          ((invalid-example) source result expectation))))

    ((_ expression)
     (let ((result expression)
           (source 'expression))
       (if result
         ((valid-example) source result)
         ((invalid-example) source result))))

    ((_ expression ===> value ...)
     (let ((source 'expression)
           (expectation '(value ...)))
       (call-with-values (lambda () expression)
         (lambda results
           (if (equal? results '(value ...))
             ((valid-example) source results expectation)
             ((invalid-example) source results expectation))))))
    ))

#+END_SRC

As you can see, there are three rules in our ~e.g.~ macro.
The first one corresponds to the usages such as

#+BEGIN_SRC scheme :tangle language/extensions.scm

(e.g. (+ 2 2) ===> 4)

(e.g. (append '(a b c) '(d e)) ===> (a b c d e))

#+END_SRC

where some expected output is provided for some given input.

The second rule corresponds to the usages of /predicates/, i.e.
functions whose value is (typically) either true or false, as in

#+BEGIN_SRC scheme :tangle language/extensions.scm

(e.g. (even? 4))

(e.g. (pair? (cons 1 2)))

#+END_SRC

This case makes the examples involving predicates somewhat
shorter and more natural to read. It also fits nicely with
Scheme's idea that everything else than ~#false~ is considered
true in the context of a conditional. (Kawa also provides
another value that is considered false in the context of
conditionals, namely ~#!null~, which corresponds to the
JVM's concept of ~null~).

The last rule allows to express examples involving functions
that are capable of returning multiple values:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(e.g. (values 1 2 3) ===> 1 2 3)

(e.g. (values) ===>)

#+END_SRC

**** The ~is~ and ~isnt~ macros

Scheme is consistent in its usage of prefix notation.
There are situations, however, when it would be handy
to have infix, or even postfix notation available.

This can be done, of course, using the prefix notation.

More specifically, we may want to transform

#+BEGIN_SRC scheme :tangle no

(is 2 < 3)

#+END_SRC

to

#+BEGIN_SRC scheme :tangle no

(< 2 3)

#+END_SRC

and 

#+BEGIN_SRC scheme :tangle no

(is 2 even?)

#+END_SRC

to

#+BEGIN_SRC scheme :tangle no

(even? 2)

#+END_SRC

Moreover, if we already decide to use ~is~ in this way, it
opens for us an opportunity to also use it for constructing
functions, so that

#+BEGIN_SRC scheme :tangle no

(is (length _) < 3)

#+END_SRC

is equivalent to

#+BEGIN_SRC scheme :tangle no

(lambda (x) (< (length x) 3))

#+END_SRC

The ~is~ operator - and its negated version ~isnt~ - has
been described at length in the [[https://srfi.schemers.org/srfi-156/srfi-156.html][SRFI-156]] document.

Its implementation is non-trivial, because it has to be able
to extract the ~_~ literal symbol from arbitrarily nested
expressions (and it needs to account for the possibility of
encountering nested occurrences of the ~is~ and ~isnt~
operators).

For this reason - if you're not familiar with advanced macro
programming in Scheme - it's OK to skip the analysis of the
~extract-_~ helper macro. Othewise enjoy.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax infix/postfix
  (syntax-rules ()
    
    ((infix/postfix x somewhat?)
     (somewhat? x))

    ((infix/postfix left related-to? right)
     (related-to? left right))

    ((infix/postfix left related-to? right . likewise)
     (let ((right* right))
       (and (infix/postfix left related-to? right*)
            (infix/postfix right* . likewise))))))

(define-syntax extract-_
  (syntax-rules (_ is isnt quote
                    quasiquote unquote
                   unquote-splicing)
    ;; ok, it's a bit rough, so it requires an explanation.
    ;; the macro operates on sequences of triples
    ;;
    ;;   (<remaining-expr> <arg-list> <processed-expr>) +
    ;;
    ;; where <remaining-expr> is being systematically
    ;; rewritten to <processed-expr>. When the _ symbol
    ;; is encountered, it is replaced with a fresh "arg"
    ;; symbol, which is appended to both <arg-list>
    ;; and <processed-expr>.
    ;;
    ;; The goal is to create a lambda where each
    ;; consecutive _ is treated as a new argument
    ;; -- unless there are no _s: then we do not
    ;; create a lambda, but a plain expression.
    ;;
    ;; The nested "is" and "isnt" operators are treated
    ;; specially, in that the _s within those operators are
    ;; not extracted.
    ;;
    ;; Similarly, the _ isn't extracted from quoted forms,
    ;; and is only extracted from quasi-quoted forms if
    ;; it appears on unquoted positions.

    ;; The support for quasiquote modifies the tuples
    ;; to have the form
    ;;
    ;;   (<remaining-expr> <arg-list> <processed-expr> . qq*) +
    ;;
    ;; where qq* is a sequence of objects that expresses
    ;; the nesting level of the 'quasiquote' operator
    ;; (i.e. quasiquote inside quasiquote etc.)

    ;; The macro consists of the following cases:
    
    ;; fin case with no _s
    ((extract-_ fin (() () body))
     (fin (infix/postfix . body)))

    ;; fin case with some _s -- generate a lambda
    ((extract-_ fin (() args body))
     (lambda args
       (with-compile-options
        warn-unknown-member: #f
        (fin (infix/postfix . body)))))

    ;; treat 'is' and 'isnt' operators specially and
    ;; don't touch their _s
    ((extract-_ fin (((is . t) . rest) args (body ...)) . *)
     (extract-_ fin (rest args (body ... (is . t))) . *))

    ((extract-_ fin (((isnt . t) . rest) args (body ...)) . *)
     (extract-_ fin (rest args (body ... (isnt . t))) . *))

    ;; same with 'quote'
    ((extract-_ fin (('literal . rest) args (body ...)) . *)
     (extract-_ fin (rest args (body ... 'literal)) . *))

    ;; when 'quasiquote' is encountered, we increase the
    ;; level of quasiquotation (the length of the qq* sequence)
    ((extract-_ fin
                (((quasiquote x) . rest) args body . qq*) . *)
     (extract-_ fin
                ((x) () (quasiquote) qq . qq*)
                (rest args body) . *))

    ;; on the other hand, for 'unquote' and
    ;; 'unquote-splicing', we decrease the nesting level
    ;; (i.e. we consume one element from the qq* sequence)
    ((extract-_ fin
                (((unquote x) . rest) args body qq . qq*) . *)
     (extract-_ fin
                ((x) () (unquote) . qq*)
                (rest args body qq . qq*) . *))

    ((extract-_ fin
                (((unquote-splicing x) . rest) args body
                 qq . qq*) . *)
     (extract-_ fin
                ((x) () (unquote-splicing) . qq*)
                (rest args body qq . qq*) . *))

    ;; push/unnest nested expression for processing
    ((extract-_ fin (((h . t) . rest) args body . qq) . *)
     (extract-_ fin ((h . t) () () . qq)
                (rest args body . qq) . *))

    ;; unquote in the tail position
    ((extract-_ fin
                ((unquote x) args (body ...) qq . qq*) . *)
     (extract-_ fin
                ((x) args (body ... unquote) . qq*) . *))
    
    ;; generate a new arg for the _ in the head position
    ((extract-_ fin ((_ . rest) (args ...) (body ...)) . *)
     (extract-_ fin (rest (args ... arg) (body ... arg)) . *))

    ;; rewrite the term in the head position to the back
    ;; of the processed terms
    ((extract-_ fin ((term . rest) args (body ...) . qq) . *)
     (extract-_ fin (rest args (body ... term) . qq) . *))

    ;; _ in the tail position
    ((extract-_ fin
                (_ (args ...) (body ...) . qq)
                (rest (args+ ...) (body+ ...) . qq+) . *)
     (extract-_ fin
                (rest (args+ ... args ... arg)
                      (body+ ... (body ... . arg)) . qq+) . *))

    ;; pop/nest back processed expression
    ;; ('last' is an atom; most likely (), but can also
    ;; be some value, e.g. in the case of assoc list literals)
    ((extract-_ fin
                (last (args ...) (body ...) . qq)
                (rest (args+ ...) (body+ ...) . qq+) . *)
     (extract-_ fin (rest (args+ ... args ...)
                          (body+ ... (body ... . last))
                          . qq+) . *))
    ))

(define-syntax-rule (identity-syntax form)
  form)

(define-syntax-rule (is . something)
  (extract-_ identity-syntax (something () ())))

(define-syntax-rule (isnt . something)
  (extract-_ not (something () ())))

#+END_SRC

*** Control structures

The Scheme language is known for its use of recursive
functions and continuations to express iteration and
other form of control structures.

Unfortunately Kawa, being bound to the JVM, does not
implement proper tail recursion in generale case and has a
limited support for continuations. For this reason programs
written in Kawa tend to utilize control structures known
from more traditional languages.

**** The ~while~ loop

The ~while~ loop may not feel particularly needed in Scheme,
because it is more idiomatic to just use the named-~let~
construct. However, it is sometimes convenient to use it to
rewrite some algorithms from more mainsteam languages.

(Mind however, that I never use Scheme's ~do~ syntax, and I
consider it to be evil and horrible, and that if you ever
submit a pull-request containing a use of ~do~, I will most
certainly reject it).

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (while condition actions ...)
  (let ()
    (define (loop)
      (when condition
        actions ... (loop)))
    (loop)))

#+END_SRC

**** Escaping

If you're familiar with languages with control structures
derived from C, such as C#, JavaScript, C++, PHP or Java,
you know that it is possible to exit a ~while~ loop using
the ~break~ statement - just like it is possible to exit
from a function using the ~return~ statement.

Scheme doesn't have that, but instead it has a construct
known as ~call-with-current-continuation~, or ~call/cc~ for
short. It is fun, because after a continuation has been
captured, it can be passed around and invoked multiple
times.

Due to the limitations of the JVM Kawa doesn't have that.
It does provide the ~call/cc~ function, but its capabilities
are limited to breaking/returning, and the context cannot be
reentered. (This type of continuations is sometimes called
/escape continuations/).

It makes it harder to write puzzling programs, which isn't
necessarily a bad thing. The following ~escape-with~ macro
arguably makes the intent slightly clearer (and it doesn't
use the bad word /continuation/ which means nothing to
anyone except a bunch of nerds):

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (escape-with label . commands)
  (call/cc (lambda (label) . commands)))

#+END_SRC

With that macro, we can introduce our own ~break~ statement
(and name it however we like) and use it like this:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(e.g.
  (let ((x 0))
    (escape-with break
      (while #t
        (set! x (+ x 1))
        (when (is x >= 5)
          (break))))
    x) ===> 5)

#+END_SRC

**** Parallellism

Before discussing the ~for~ loop, it's worth to say a few
words about Kawa's approach to interfacing with threads.
And it's pretty simple: Kawa provides a special form called
~future~, which takes a single expression and starts
evaluating it in a new thread, returning a promise.  In
order to obtain the value of the expression (possibly
waiting until it becomes available), one needs to invoke the
~force~ operator on that promise (which is the same operator
that is used in Scheme along with ~delay~ to implement lazy
evaluation).

So, if we have a few sub-programs that we want to run in
parallel, we could define the following helper macro that
blocks the current thread until all the sub-programs
terminate:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax concurrently
  (lambda (stx)
    (syntax-case stx ()
      ((concurrently actions ...)
       (with-syntax (((futures ...)
                      (generate-temporaries #'(actions ...))))
         #'(let ((futures (future actions)) ...)
             (force futures)
             ...))))))

#+END_SRC

The above macro is defined in terms of the ~syntax-case~
macro system rather than ~syntax-rules~, because it is
required to generate temporary identifiers using the
~generate-temporaries~ funcion.

**** The ~for~ loop

The advantage of Kawa over most other Scheme implementations
is its polymorphic behavior: functions such as ~map~ or
~for-each~ can work on any sort of Java collections, not
only on lists. So Kawa doesn't have to provide different
versions of those functions, such as ~hash-for-each~,
~vector-for-each~ etc.

Yet the interface of the ~for-each~ function is somewhat
cumbersome, requiring the user to provide a ~lambda~
expression as its first argument.

Which is why it can be more convenient to have a ~for~
syntax that desugars to a ~for-each~ when iterating over
a collection.

Moreover, having such syntax creates an opportunity to
provide different styles of iteration, including doing things
in parallel, or iterating over a collection in reverse, or
iterating over a range of numbers (without allocating array
of numbers or creating coroutines):

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define (par-for-each function collection)
  (let ((futures ::java.util.List
                 (java.util.ArrayList)))
    (for-each (lambda (x)
                (futures:add (future (function x))))
              collection)
    (for-each (lambda (f)
                (force f))
              futures)
    (futures:clear)))

(define-syntax for
  (syntax-rules (in from to below by
                    in-reverse
                    in-parallel ::)

    ((_ var :: type in-reverse collection . actions)
     (let ((it ::java.util.ListIterator (collection:listIterator
                                         (length collection))))
       (while (it:hasPrevious)
         (let ((var ::type (it:previous)))
           . actions))))

    ((_ var in-reverse collection . actions)
     (let ((it ::java.util.ListIterator (collection:listIterator
                                         (length collection))))
       (while (it:hasPrevious)
         (let ((var (it:previous)))
           . actions))))

    ((_ var :: type in-parallel collection . actions)
     (par-for-each (lambda (var :: type) . actions) collection))

    ((_ var in-parallel collection . actions)
     (par-for-each (lambda (var) . actions) collection))
    
    ((_ var :: type in collection . actions)
     (for-each (lambda (var :: type) . actions) collection))

    ((_ (vars ...) in collection . actions)
     (for-each (lambda (var)
                 (apply (lambda (vars ...) . actions) var))
               collection))
    
    ((_ var in collection . actions)
     (for-each (lambda (var) . actions) collection))

    ((_ var::type from start to end by increment actions ...)
     (let loop ((var::type start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var increment))))))
    
    ((_ var from start to end by increment actions ...)
     (let loop ((var start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var increment))))))

    ((_ var::type from start below end by increment actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var increment))))))
    
    ((_ var from start below end by increment actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var increment))))))

    ((_ var::type from start to end actions ...)
     (let loop ((var start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var 1))))))
    
    ((_ var from start to end actions ...)
     (let loop ((var start))
       (if (is var <= end)
           (begin
             actions ...
             (loop (+ var 1))))))

    ((_ var::type from start below end actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var 1))))))
    
    ((_ var from start below end actions ...)
     (let loop ((var start))
       (if (is var < end)
           (begin
             actions ...
             (loop (+ var 1))))))
    ))
#+END_SRC

Note that in the above snippet, the ~::~ symbol appeared.
It is used in Kawa for specifying types of variables. Kawa's
reader treats the sequence of two consecutive colons as a
separate token:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(e.g.
  (call-with-input-string "(a::b::c)" read)
  ===> (a :: b :: c))

(e.g.
  (call-with-input-string "(:::::)" read)
  ===> (:: :: :))

#+END_SRC

If you analyze this macro, you'll notice that there are
always two variants of each clause -- one that includes
the ~::type~ and one that omits it.


*** Input/output operations

Kawa Scheme lacks certain port operations that are present
in other Scheme implementations, so we make up for this
shoritcoming.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-alias InputPort gnu.kawa.io.InPort)

(define-alias OutputPort gnu.kawa.io.OutPort)

(define-alias EndOfFile gnu.lists.EofClass)

(define (with-output-to-string proc::(maps () to: ,a))::string
  (call-with-output-string
    (lambda (port::OutputPort)
      (parameterize ((current-output-port port))
	(proc)))))

(define (with-output-to-port port::OutputPort proc::(maps () to: ,a))::,a
  (parameterize ((current-output-port port))
    (proc)))

(define (with-input-from-string s::string proc::(maps () to: ,a))::,a
  (call-with-input-string s
    (lambda (port::InputPort)::,a
      (parameterize ((current-input-port port))
	(proc)))))

(define (with-input-from-port port::InputPort proc::(maps () to: ,a))::,a
  (parameterize ((current-input-port port))
    (proc)))

(define (print . messages)
  (for message in messages
    (display message))
  (newline))

#+END_SRC

*** Defining classes and interfaces

As mentioned earlier, Kawa provides some means of defining
new JVM classes. In particular, there are two special
forms - ~define-class~ and ~define-simple-class~ - that
can be used for that purpose.

The ~define-simple-class~ form is more rudimentary and
allows to define JVM classes directly, whereas the
~define-class~ form somehow supports multiple inheritance,
and in addition to defining a class, also defines an
interface.

The exact syntax of those forms can be found in the
[[https://www.gnu.org/software/kawa/Defining-new-classes.html][Defining new classes]] section of Kawa documentation.

The syntax is fairly complicated, and for that reason
GRASP never uses those forms directly. Instead it uses
three derived forms, namely -- ~define-interface~,
~define-object~ and ~define-type~.

**** The ~define-interface~ macro

One of the fundamental achievements of the Java programming
language is that it popularized the notion of /interface/,
which allows to express certain design ideas in abstract,
without providing particular implementation details.

While Kawa's ~define-simple-class~ macro allows to define
interfaces, it only allows doing that in a very clumsy way.

Therefore, GRASP provides the ~define-interface~ macro,
which simplifies the definition of interfaces.

It is used in the following way:

#+BEGIN_SRC scheme :tangle no

(define-interface InterfaceName (SuperInterfaces ...)
  (method-name argument-types ...) :: return-value-type
  ...)

#+END_SRC

The definition uses a helper macro ~interface-definition~,
which isn't meant to be used directly - it allows to wrap
the triples ~prototype :: return-type~ in an additional pair
of parentheses, as required by the ~define-simple-class~
form.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (define-interface name (supers ...) prototypes ...)
  (interface-definition name (supers ...) (prototypes ...) ()))

(define-syntax interface-definition
  (syntax-rules (::)
    ((_ name supers () methods)
     (define-simple-class name supers interface: #t . methods))
    
    ((_ name supers (method :: result . rest) (methods ...))
     (interface-definition
      name supers rest
      (methods ... (method :: result #!abstract))))
    ))

#+END_SRC

We are going to see many instances of the ~define-interface~
macro in the sequel of the text.

**** The ~define-object~ macro

The syntax of ~define-class~ and ~define-simple-class~ forms
is very complex and somewhat arbitrary. Because of this, GRASP
uses a wrapper that simplifies the definition of new classes.

It is used in the following way:

#+BEGIN_SRC scheme :tangle no

(define-object (ClassName constructor-args ...)::ImplementedInterface
  (define slot-name ::type init-value)
  ...
  (define (method-name method-args ...) :: return-value-type
    method-body ...)
  ...
  (SuperClass superclass-args ...)
  initialization-code
  ...)

#+END_SRC

As you can see, it restricts the way classes can be defined by:
- only allowing a single constructor
- only allowing to provide a single interface

The second limitation isn't problematic in practice, because
it's always possible to agregate multiple interfaces
together into a new interface.

The ~define-object~ form deliberately resembles defining a
function with nested definitions, thus reinforcing the idea
that "an object is an environment that implements an
interface".

The ~define-object~ macro delegates all the actual work to
the ~object-definition~ helper macro:

#+BEGIN_SRC  scheme :tangle language/extensions.scm

(define-syntax delegate
  (syntax-rules (::)
    ((delegate (method . params) :: type object)
     (delegate (method . params) object))

    ((delegate (method) object args ...)
     (invoke object 'method args ...))

    ((delegate (method param :: type . params) object args ...)
     (delegate (method . params) object args ... param))

    ((delegate (method param . params) object args ...)
     (delegate (method . params) object args ... param))))

(define-syntax object-definition
  (lambda (stx)
    (syntax-case stx (::
                      define
                      define-private
                      define-static
                      delegate)
      
      ((object-definition (object-name . args)
                          (arg :: type . rest)
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          spec)
       #'(object-definition (object-name . args)
                            rest
                            supers
                            (slots ... (arg :: type))
                            methods
                            (initializers
                             ...
                             (slot-set! (this) 'arg arg))
                            spec))

      ((object-definition (object-name . args)
                          (arg . rest)
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          spec)
       #'(object-definition (object-name . args)
                            rest
                            supers
                            (slots ... (arg))
                            methods
                            (initializers
                             ...
                             (slot-set! (this) 'arg arg))
                            spec))

      ((object-definition (object-name . args)
                          rest
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          spec)
       (identifier? #'rest)
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (rest::list))
                            methods
                            (initializers
                             ...
                             (slot-set! (this) 'rest rest))
                            spec))
      
      ((object-definition (object-name . args)
                          ()
                          (supers ...)
                          slots
                          methods
                          initializers
                          (:: type . spec))
       #'(object-definition (object-name . args)
                            ()
                            (supers ... type)
                            slots
                            methods
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((define-private (method . params)
                             . body)
                           . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods
                             ...
                             ((method . params)
                              access: 'private . body))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define-private slot :: type value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot :: type access: 'private))
                            methods
                            (initializers 
                             ... 
                             (set! slot value))
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define-private slot value)
                          . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot access: 'private))
                            methods
                            (initializers 
                             ... 
                             (set! slot value))
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((define-static (method . params)
                             . body)
                           . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods
                             ...
                             ((method . params)
                              allocation: 'static . body))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          initializers
                          ((define-static slot :: type value)
                          . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot :: type allocation: 'static init: value))
                            methods
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          initializers
                          ((define-static slot value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot allocation: 'static init: value))
                            methods
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((define (method . params) . body) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods ... ((method . params) . body))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((delegate (method . params)::type object) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods ... ((method . params)::type 
                                          (delegate (method . params) object)))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          slots
                          (methods ...)
                          initializers
                          ((delegate (method . params) object) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            slots
                            (methods ... ((method . params) 
                                          (delegate (method . params) object)))
                            initializers
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define slot :: type value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots
                             ...
                             (slot :: type))
                            methods
                            (initializers
                             ...
                             (set! slot value))
                            spec))

      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          initializers
                          ((define slot :: type) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot :: type))
                            methods
                            initializers
                            spec))
      
      ((object-definition (object-name . args)
                          ()
                          supers
                          (slots ...)
                          methods
                          (initializers ...)
                          ((define slot value) . spec))
       #'(object-definition (object-name . args)
                            ()
                            supers
                            (slots ... (slot))
                            methods
                            (initializers
                             ...
                             (set! slot value))
                            spec))

      ((object-definition (object-name)
                          ()
                          (supers ...)
                          (slots ...)
                          (methods ...)
                          ()
                          ())
       #'(define-simple-class object-name (supers ...)
           slots ... methods ...))

      ((object-definition (object-name . args)
                          ()
                          (supers ...)
                          slots
                          (methods ...)
                          (initializers ...)
                          ())
       #'(object-definition (object-name)
                            ()
                            (supers ...)
                            slots
                            (methods
                             ...
                             ((*init* . args)
                              initializers ...))
                            ()
                            ()))

      ((object-definition (object-name . args)
                          ()
                          (supers ...)
                          slots
                          (methods ...)
                          (initializers ...)
                          ((super . args*) . init))
       #'(object-definition (object-name)
                            ()
                            (supers ... super)
                            slots
                            (methods
                             ...
                             ((*init* . args)
                              (invoke-special super (this)
                                              '*init*
                                              . args*)
                              initializers ...
                              . init))
                            ()
                            ()))
      )))

(define-syntax-rule (define-object (object-name . args) . spec)
  (object-definition (object-name . args)
                     #;args
                     args
                     #;supers
                     ()
                     #;slots
                     ()
                     #;methods
                     ()
                     #;initializers
                     ()
                     #;spec
                     spec))

#+END_SRC

**** The ~define-type~ macro

When Java first came out, it tried to pursue the idea that
/everything is an object/ - where the word /object/ is
understood as something that has its identity, class,
methods and properties. But even from its earliest version
it failed to maintain that illusion, because - for
performance reason - it provided a set of primitive types
which were not objects in the above sense. But even putting
performace reasons aside, programmers had the urge to
introduce the notion of /value objects/ that didn't have
their unique identity, and were just simple carriers of
information.

Eventually Java came up with syntactic support for this
/kind of objects/ in the form of records, and it further
extends this support.

(It may be instructive to watch a talk by Brian Goetz about
/Project Valhalla/ to see how parting from the idea that
/everything is an object/ helped unlock certain performance
benefits, in addition to just writing simpler and more
maintainable code.)

In the meantime, GRASP comes with its own capability
of defining records, using the ~define-type~ macro.

Fundamentally, using the macro defines a new class whose
identity is based on the equality of its fields, whose
hash method only depends its fields, which can be trivially
cloned by cloning all of its fields, and whose string
representation consists of its type name and the names
and values of all of its fields.

In addition, we are going to allow the users of the macro
to provide the /default values/ to some particular fields.

We would like the record definitions to be used in the
following way:

#+BEGIN_SRC scheme :tangle no

(define-type (TypeName field1-name: field1-type
                       field2-name: field2-type := initializer
                       ...)

#+END_SRC

Kawa reader treats symbols that end with a colon as /keywords/
(that are typically used as named arguments to functions).

Keywords are not a part of the standard Scheme, but they
were described in the [[https://srfi.schemers.org/srfi-88/srfi-88.html][SRFI-88]] document and are fairly
widespread among the practical Scheme implementations.

But as we have seen before, the ~define-simple-class~ form
requires slots to be named using symbols. Therefore we need
a way to convert between symbols and keywords:


#+BEGIN_SRC scheme :tangle language/extensions.scm

(define (keyword->symbol kw)
  (string->symbol (keyword->string kw)))

(define (symbol->keyword s)
  (string->keyword (symbol->string s)))

#+END_SRC

Of course, in order to be able to call arbitrary Scheme
functions during macro expansion, we need to resort to the
~syntax-case~ macro system.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (define-type (type-name . fields))
  (type-definition type-name fields #;slots () #;initializers (begin)))

(define-syntax type-definition
  (lambda (stx)
    (syntax-case stx (:=)
      ((_ type-name () ((slot-symbol . slot-spec) ...) (initializers ...))
       #'(define-simple-class type-name (java.lang.Cloneable)
           (slot-symbol . slot-spec)
           ...
           ((assign source ::type-name)::void
            (set! slot-symbol (slot-ref source 'slot-symbol))
            ...)

           ((clone)::java.lang.Object
            (let ((copy (type-name)))
              (invoke copy 'assign (this))
              copy))

           ((prettyPrint port ::OutputPort)::void
            (kawa.lib.kawa.pprint:pprintStartLogicalBlock "[" #f "]" port)
            (try-finally
              (begin
               (display 'type-name port)
               (kawa.lib.kawa.pprint:pprintNewline 'miser port)
               (begin
                (write-char #\space port)
                (kawa.lib.kawa.pprint:pprintNewline 'fill port)
                (write 'slot-symbol port)
                (write-char #\: port)
                (write-char #\space port)
                (kawa.lib.kawa.pprint:pprintNewline 'linear port)
                (cond ((string? slot-symbol)
                       (write slot-symbol port))
                      ((java.util.Collection? slot-symbol)
                       (kawa.lib.kawa.pprint:pprintStartLogicalBlock "[" #f "]" port)
                       (try-finally
                        (for item in slot-symbol
                         (kawa.lib.kawa.pprint:pprint item port))
                        (kawa.lib.kawa.pprint:pprintEndLogicalBlock "]" port)))
                      (else
                       (kawa.lib.kawa.pprint:pprint slot-symbol port))))
               ...)
             (kawa.lib.kawa.pprint:pprintEndLogicalBlock "]" port)))

           ((toString)::java.lang.String
            (call-with-output-string 
              (lambda (port ::OutputPort) 
                (invoke (this) 'prettyPrint port))))

           ((equals another ::java.lang.Object)::boolean
            (and (instance? another type-name)
                 (let ((another ::type-name (as type-name another)))
                    (and (equal? slot-symbol (slot-ref another 
                                                       'slot-symbol))
                         ...))))

           ((hashCode)::int
            (let ((hash ::int (invoke 'type-name 'hashCode)))
              (set! hash (+ (* hash 31) (invoke slot-symbol 'hashCode)))
              ...
              hash))
             
           ((*init*)
            (initializers ... (values)))
          ))

      ((_ type-name (slot-keyword slot-type := value . fields)
          (slot-definitions ...) (initializers ...))
       (keyword? (syntax->datum #'slot-keyword))
       (with-syntax ((slot-symbol
                      (datum->syntax
                       stx
                       (keyword->symbol
                         (syntax->datum #'slot-keyword)))))
         #'(type-definition type-name fields
            (slot-definitions ... (slot-symbol type: slot-type))
            (initializers ... (set! slot-symbol value)))))

      ((_ type-name (slot-keyword slot-type . fields)
        (slot-definitions ...) initializers)
       (keyword? (syntax->datum #'slot-keyword))
       (with-syntax ((slot-symbol (datum->syntax
                                   stx
                                   (keyword->symbol
                                     (syntax->datum #'slot-keyword)))))
         #'(type-definition type-name fields
            (slot-definitions ... (slot-symbol type: slot-type))
            initializers)))
      )))

#+END_SRC

The above definition resorts to the ~copy~ procedure, which
hasn't yet been defined. For certain reasons (that will
hopefully become clearer later), the ~copy~ procedure is
defined in the following way:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define (clonable? object)::boolean
  (or (instance? object java.lang.Cloneable)
      (and (procedure? object)
	   (procedure? (procedure-property object 'clone)))))

(define (copy object)
  (cond
   ((instance? object java.util.WeakHashMap)
    (let* ((hash-map ::java.util.WeakHashMap object)
	   (cloned ::java.util.WeakHashMap
		   (java.util.WeakHashMap)))
      (for key in (hash-map:keySet)
	(let ((value (hash-map:get key)))
	  (cloned:put key value)))
      cloned))
   
   ((instance? object java.lang.Cloneable)
    (with-compile-options
     warn-unknown-member: #f
     (let ((clonable ::java.lang.Cloneable object))
       (clonable:clone))))
   
   ((procedure? object)
    (let ((clone (procedure-property object 'clone)))
      (if (procedure? clone)
	  (clone)
	  (error "Unable to clone procedure "object))))
   
   ((pair? object)
    (cons (copy (car object)) (copy (cdr object))))

   ((or (null? object)
	(number? object)
	(boolean? object))
    object)
   
   (else
    (error "Unable to clone "object" "(object:getClass)))))

#+END_SRC

Once a new type is defined, it can be instantiated by typing

#+BEGIN_SRC scheme :tangle no

(TypeName field1-name: field1-value
          field2-name: field2-value
                       ...)

#+END_SRC

This works largely because of the way Kawa treats keyword
arguments in object constructors. To find out more, read the
[[https://www.gnu.org/software/kawa/Allocating-objects.html][Allocating objects]] section of the Kawa reference manual.

Of course, someone could ask why won't we (just) use the
Scheme's ~define-record-type~ facility for, uhm, defining
record types, to which we would respond:
- which one? (R6RS and R7RS both come with incompatible
  syntax)
- because they all suck

*** Pattern matching

Pattern matching is a technique that allows to conditionally
destrucutre compound data types and operate on their parts.

Pioneered in functional languages, it has recently been
paving its way into the mainstream languages.

In Lisp and Scheme, pattern matching can be thought of as an
operation that is the opposite of quasiquotation.

But in our case, we would like to be able to destructure not
only lists, but also records defined with our ~define-type~
macro.

During the process of pattern matching, a need for testing
for object's equality is going to appear. Scheme programmers
are familiar with a number of concepts of equality,
including ~eq?~, ~eqv?~, ~equal?~, ~=~, ~string=?~ and so
on. The we need to ask: which type of equality should we
choose in our pattern matcher?

One idea would be to introduce a parameter (like we did for
the ~e.g.~ macro). But we will go with another one, namely:
we'll introduce an interface called ~Matchable~ and a new
predicate called ~match/equal?~:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-interface Matchable ()
  (matches? x)::boolean)

(define (match/equal? a b)
  (or (equal? a b)
      (and (Matchable? a)
           (let ((a ::Matchable a))
             (a:matches? b)))))

#+END_SRC

**** The ~match~ macro

The main interface of pattern matcher is the ~match~ macro,
which is going to invoke a helper form, called
~match/evaluated~, which in turn calls the ~match-clause~
(which is the heart of our matcher). 

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (match expression (pattern actions* ... value) ...)
  (let ((evaluated expression))
    (match/evaluated evaluated (pattern actions* ... value) ...)))

(define-syntax match/evaluated
  (syntax-rules (::)
    ((match/evaluated value)
     ;; This behavior is unspecified, and an "unspecified"
     ;; value would also be fine here.
     (error 'no-matching-pattern value))

    ((match/evaluated value (pattern::type actions ...) final-clause)
     (match-clause ((pattern::type value))
                   (and)
                   ()
                   actions ...
                   (with-compile-options
                    warn-unreachable: #f
                    (match/evaluated value final-clause))))
    
    ((match/evaluated value (pattern actions ...) final-clause)
     (match-clause ((pattern value))
                   (and)
                   ()
                   actions ...
                   (with-compile-options
                    warn-unreachable: #f                   
                    (match/evaluated value final-clause))))
    
    ((match/evaluated value (pattern::type actions ...) . clauses)
     (match-clause ((pattern::type value))
                   (and)
                   ()
                   actions ...
                   (match/evaluated value . clauses)))
    
    ((match/evaluated value (pattern actions ...) . clauses)
     (match-clause ((pattern value))
                   (and)
                   ()
                   actions ...
                   (match/evaluated value . clauses)))
    ))

(define-syntax match-clause
  (lambda (stx)
    (syntax-case stx (quasiquote
                      unquote quote unquote-splicing
                      and _ list %typename :: $lookup$)
      ((match-clause () condition bindings actions ... alternative)
       #'(check/unique condition bindings #f () ()
                       actions ... alternative))

      ((match-clause (((list items ...) root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((`(,items ...) root) . rest)
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause (((list items ... . last) root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((`(,items ... . ,last) root) . rest)
                       condition
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`,pattern::type root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((pattern::type root) . rest)
                       condition
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`,pattern root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause ((pattern root) . rest)
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause ((,value::type root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions
                        ...
                        (instance? root type)
                        (match/equal? value root))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((,value root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions ... (match/equal? value root))
                       bindings
                       actions ... alternative))

      ((match-clause ((,@predicate root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions ... (predicate root))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((_::type root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (conditions ... (instance? root type))
                       bindings
                       actions ... alternative))

      ((match-clause ((_ root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       condition
                       bindings
                       actions ... alternative))

      ((match-clause ((variable ::type root) . rest)
                     (conditions ...)
                     bindings
                     actions ... alternative)
       (identifier? #'variable)
       #'(match-clause rest
                       (conditions ... (instance? root type))
                       ((variable ::type root) . bindings)
                       actions ... alternative))
      
      ((match-clause ((variable root) . rest)
                     condition
                     bindings
                     actions ... alternative)
       (identifier? #'variable)
       #'(match-clause rest
                       condition
                       ((variable root) . bindings)
                       actions ... alternative))

      ((match-clause (('datum root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ... (match/equal? root 'datum))
                       bindings
                       actions ... alternative))

      ((match-clause ((object:key root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ... (match/equal? root
                                                         object:key))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`(left::type . right) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause ((`left::type (car root))
                        (`right (cdr root)) . rest)
                       (and conditions ... (pair? root))
                       bindings
                       actions ... alternative))
      
      ((match-clause ((`(left . right) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause ((`left (car root)) (`right (cdr root)) . rest)
                       (and conditions ... (pair? root))
                       bindings
                       actions ... alternative))

      ((match-clause ((`datum root) . rest)
                     conditions
                     bindings
                     actions ... alternative)
       #'(match-clause (('datum root) . rest)
                        conditions
                       bindings
                       actions ... alternative))
      
      ((match-clause (((_ . fields) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause (((%typename . fields) root) . rest)
                       (and conditions ...)
                       bindings
                       actions ... alternative))
      
      ((match-clause (((%typename type) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       #'(match-clause rest
                       (and conditions ...)
                       bindings
                       actions ... alternative))

      ((match-clause (((%typename type key pat . etc) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       (and (keyword? (syntax->datum #'key))
            (identifier? #'type))
       (with-syntax ((name (datum->syntax
                            stx
                            (keyword->symbol (syntax->datum #'key)))))
         #'(match-clause (((%typename type . etc) root)
                          (pat (field (as type root) 'name)) . rest)
                         (and conditions ...)
                         bindings
                         actions ... alternative)))

      ((match-clause (((typename . fields) root) . rest)
                     (and conditions ...)
                     (bindings ...)
                     actions ... alternative)
       (and (identifier? #'typename) (identifier? #'root))
       #'(match-clause (((%typename typename . fields) root) . rest)
                       (and conditions ... (instance? root typename))
                       (bindings ... (root ::typename root))
                       actions ... alternative))

      
      ((match-clause (((typename . fields) root) . rest)
                     (and conditions ...)
                     bindings
                     actions ... alternative)
       (identifier? #'typename)
       #'(match-clause (((%typename typename . fields) root) . rest)
                       (and conditions ... (instance? root typename))
                       bindings
                       actions ... alternative))

      ((match-clause ((literal root) . rest)
                     (and conditions ...)
                     bindings
                     actions ...)
       #'(match-clause rest
                       (and conditions ... (match/equal? literal root))
                       bindings
                       actions ...))
      )))

#+END_SRC

As we can see, the final rule of the ~match-clause~ macro
invokes the ~check/unique~ macro, which checks whether all
objects that are bound to the same identifier in the macro's
pattern are ~match/equal?~ (the complexity of the test is
quadratic, but since human-readable patterns are usually
very small, this isn't a problem in practice):

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax check/unique
  (lambda (stx)
    "add equality checks for repeated identifiers in patterns and remove them from bindings"
    (syntax-case stx (and)
      ((check/unique condition #;unchecked ()
                     #;currently-checked #f
                     #;checked ()
                     #;final bindings actions ... alternative)
       #'(if condition
             (let bindings actions ...)
             alternative))

      ;; check the next binding from the list
      ((check/unique condition
                     ((variable type ... path) . bindings)
                     #f
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique condition
                       bindings
                       (variable type ... path)
                       bindings/checked
                       bindings/final
                       actions ... alternative))

      ;; the binding is present: add equality check
      ((check/unique (and conditions ...)
                     ((variable type ... path) . bindings)
                     (variable+ type+ ... path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       (bound-identifier=? #'variable #'variable+)
       #'(check/unique (and conditions ... (match/equal? path path+))
                       bindings
                       (variable+ type+ ... path+)
                       bindings/checked
                       bindings/final
                       actions ... alternative))
      
      ;; the binding is absent: go on
      ((check/unique conditions
                     ((variable type ... path) . bindings)
                     (variable+ type+ ... path+)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique conditions
                       bindings
                       (variable+ type+ ... path+)
                       ((variable type ... path) . bindings/checked)
                       bindings/final
                       actions ... alternative))

      ;; add binding to the "checked" list
      ;; (and possibly start over)
      ((check/unique conditions
                     ()
                     (variable type ... path)
                     bindings/checked
                     bindings/final
                     actions ... alternative)
       #'(check/unique conditions
                       bindings/checked
                       #f
                       ()
                       ((variable type ... path) . bindings/final)
                       actions ... alternative))
      )))

#+END_SRC

**** The ~and-let*~ macro

One of the earliest SRFI documents is [[https://srfi.schemers.org/srfi-2/srfi-2.html][SRFI-2]] by Oleg
Kiselyov, which introduces the ~and-let*~ macro. While its
name isn't particularly appealing, it is very useful for
practical programming.

That being said, the presence of pattern matching and type
annotations makes it even more useful. Therefore, we provide
our own implementaiton of that macro, which provides exactly
those features (and also supports multiple values):

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax and-let*
  (lambda (stx)
    (syntax-case stx (::)

      ((_)
       #'#t)

      ((_ ())
       #'#t)

      ((_ () . body)
       #'(let () . body))

      ((_ ((name binding) . rest) . body)
       (identifier? #'name)
       #'(let ((name binding))
           (and name
                (and-let* rest
                  . body))))

      ((_ ((name :: type binding) . rest) . body)
       (identifier? #'name)
       #'(let ((value binding))
           (and (instance? value type)
                value
                (let ((name ::type value))
                  (and-let* rest
                    . body)))))

      ((_ ((name :: type) . rest) . body)
       (identifier? #'name)
       #'(and (instance? name type)
              name
              (let ((name ::type (as type name)))
                (and-let* rest
                  . body))))

      ((_ ((value binding) . rest) . body)
       #'(match binding
           (value
            (and-let* rest
              . body))
           (_ #f)))

      ((_ ((condition) . rest) . body)
       #'(and condition
              (and-let* rest . body)))

      ((_ ((value * ... expression) . rest) . body)
       (identifier? #'value)
       #'(call-with-values (lambda () expression)
           (lambda args
             (match args
               (`(,value ,* ... . ,_)
                (and value
                     (and-let* rest . body)))
               (_ #f)))))

      ((_ ((value ... expression) . rest) . body)
       #'(call-with-values (lambda () expression)
           (lambda args
             (match args
               (`(,value ... . ,_)
                (and-let* rest . body))
               (_ #f)))))

      )))

#+END_SRC

**** The ~match-let*~ macro

Ideally, we'd like to have pattern matching available in all
core binding forms, such as ~lambda~, ~let~ or ~let*~, the
way it has been done for Guile in [[https://github.com/plande/grand-scheme][The Grand Scheme Glossary]],
and the way it has been described in [[https://srfi.schemers.org/srfi-201/srfi-201.html][SRFI-201]].

Unfortunately, this seems impossible without patching Kawa.
So instead we are just going to provide the ~match-let*~ syntax.

#+BEGIN_SRC  scheme :tangle language/extensions.scm

(define-syntax match-let*
  (lambda (stx)
    (syntax-case stx ()
      ((_ ((pattern value) . rest) . body)
       (identifier? #'pattern)
       #'(let ((pattern value))
           (match-let* rest . body)))
      
      ((_ ((pattern::type value) . rest) . body)
       #'(match value
           (pattern
            (match-let* rest . body))
           (_
            (error "Value failed to match pattern: "'value 'pattern))))
      
      ((_ ((pattern value) . rest) . body)
       #'(match value
           (pattern
            (match-let* rest . body))
           (_
            (error "Value failed to match pattern: "'value 'pattern))))
      ((_ () . body)
       #'(let () . body)))))

#+END_SRC

*** Optional and keyword arguments

Kawa provides syntax for optional and keyword arguments in
the style similar to Common Lisp and DSSSL: it allows 3
/special keywords/ inside of ~lambda~ parameter list, namely
~#!optional~, ~#!key~ and ~#!rest~.

On the other hand, in the above type definition, we only
used one special symbol, namely ~:=~, for assigning default
value to type constructors.

Consider a function that we'd want to use in the following
way:

#+BEGIN_SRC scheme :tangle no

(copy! data from: source to: destination)

#+END_SRC

If we wanted to define a function to be usable in that way,
we'd have to write it as something like this:

#+BEGIN_SRC scheme :tangle no

(define (copy! data #!key (from default-source) (to default-target))
  ...)

#+END_SRC

which isn't nice, because it break the symmetry between
function's definition and its usage. Moreover, if we want
our keywords to be prepositions, we need to use them as
argument names, which is awkward.

It would be more desirable to be able to write that
definition as

#+BEGIN_SRC scheme :tangle no

(define (copy! data from: source := default-source 
                    to: destination := default-target)
  ...)

#+END_SRC

Unfortunately, unlike some other Scheme implementations,
Kawa does not allow us to override its core forms.

For this reason, we're going to introduce two new special
forms, namely ~lambda*~ and ~define*~, that will enable the
improved syntax. They will also allow to perform
destructuring of the arguments of the defined functions.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax lambda*
  (lambda (stx)
    (syntax-case stx ()
      ((_ args . body)
       (identifier? #'args)
       #'(lambda args . body))

      ((_ args . body)
       #'(%lambda* args #;req () #;opt () #;kw ()
                     #;destruct () body)))))

(define-syntax %lambda*
  (lambda (stx)
    (syntax-case stx (:= ::)
            
      ((_ () (req ...) (opt ...) (kw ...) (pat ...) (:: type . body))
       #'(lambda (req ... #!optional opt ... #!key kw ...) :: type
            (match-let* (pat ...) . body)))
      
      ((_ tail (req ...) (opt ...) (kw ...) (pat ...) (:: type . body))
       (identifier? #'tail)
       #'(lambda (req ... #!optional opt ... #!key kw ... #!rest tail) :: type
            (match-let* (pat ...) . body)))

      ((_ () (req ...) (opt ...) (kw ...) (pat ...) body)
       #'(lambda (req ... #!optional opt ... #!key kw ...)
           (match-let* (pat ...) . body)))
      
      ((_ tail (req ...) (opt ...) (kw ...) (pat ...) body)
       (identifier? #'tail)
       #'(lambda (req ... #!optional opt ... #!key kw ... #!rest tail)
           (match-let* (pat ...) . body)))
      
      ;; keyword arguments:
      
      ((_ (key pattern :: type := init . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))

       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym :: type init))
                       (pat ... (pattern sym)) body)))

      ((_ (key pattern :: type . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))
       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym :: type #!null))
                       (pat ... (pattern sym)) body)))
      
      ((_ (key pattern := init . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))
       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym init))
                       (pat ... (pattern sym)) body)))

      ((_ (key pattern . rest) req opt (kw ...) (pat ...) body)
       (keyword? (syntax->datum #'key))
       (with-syntax ((sym (datum->syntax stx
                            (keyword->symbol
                             (syntax->datum #'key)))))
         #'(%lambda* rest req opt (kw ... (sym))
                       (pat ... (pattern sym)) body)))

      ;; optional arguments:
      
      ((_ (var :: type := init . rest) req (opt ...) kw pat body)
       (identifier? #'var)
       #'(%lambda* rest req (opt ... (var :: type init)) kw pat body))

      ((_ (pattern :: type := init . rest) req (opt ...) kw (pat ...) body)
       #'(%lambda* rest req (opt ... (var :: type init)) kw
                     (pat ... (pattern var)) body))

      ((_ (var := init . rest) req (opt ...) kw pat body)
       (identifier? #'var)
       #'(%lambda* rest req (opt ... (var init)) kw pat body))

      ((_ (pattern := init . rest) req (opt ...) kw (pat ...) body)
       #'(%lambda* rest req (opt ... (var init)) kw
                     (pat ... (pattern var)) body))

      ;; required arguments:
      
      ((_ (var :: type . rest) (req ...) opt kw pat body)
       (identifier? #'var)
       #'(%lambda* rest (req ... var :: type) opt kw pat body))

      ((_ (var . rest) (req ...) opt kw pat body)
       (identifier? #'var)
       #'(%lambda* rest (req ... var) opt kw pat body))

      ((_ (pattern . rest) (req ...) opt kw (pat ...) body)
       #'(%lambda* rest (req ... var) opt kw
                     (pat ... (pattern var)) body))
      
      )))


(define-syntax define*
  (syntax-rules (is ::)
    ((_ (is arg special?) . body)
     (define* (special? arg) . body))

    ((_ (is arg-1 related-to? arg-2) . body)
     (define* (related-to? arg-1 arg-2) . body))

    ((_ ((head . tail) . args) . body)
     (define* (head . tail) (lambda* args . body)))

    ((_ (name . args) . body)
     (define name (lambda* args . body)))
    
    ))

#+END_SRC


*** Hash tables, mappings and attributes

#+BEGIN_QUOTE
    Associative arrays are THE most useful single 
    data structure. Period.

    -- Brian W. Kernighan
#+END_QUOTE

It is widely known the name /LISP/ stands for /LISt
Processing/, and that singly linked lists are the data
structure best integrated with that language.

And although all dialects of Lisp in widespread use provide
some support for hash tables, this support usually feels at
best second class. (One exception to this is Clojure, which
comes with an excellent implementation of immutable hash
tables that are tightly integrated with the language. But
GRASP isn't written in Clojure.)

Because of this, Lisp programmers often use associative
arrays for associating keys with valuse, which is quite
lame with its linear search complexity.

The terms /hash table/ and /associative array/ both point to
certain implementation details of the data structure under
discussion. Even the traditional names of Scheme functions
used for dealing with that data structure, such as
~hash-set!~ or ~hash-table-ref~ underline this fact, which
is mostly irrelevant from the point of view of people who
read and write programs.

In a sense, a hash table is just a function, which
associates a set of keys with corresponding values. What may
seem slightly awkward, is that this function can be mutable.

Therefore, we should use a regular function invocation
syntax for accessing a /hash table/, and it would also be
desirable to use Scheme's regular assingment (~set!~)
operator for assigning a particular value to a function at a
particular point.

This can be achieved using [[https://srfi.schemers.org/srfi-17/srfi-17.html][SRFI-17: Generalized ~set!~]],
which has been proposed by Per Bothner, who also happens
to be the creator of Kawa.

Instead of using a technical name such as /hash table/,
we are going to use a more semantic name, i.e. ~mapping~.

We wish to use it in the following way:

#+BEGIN_SRC scheme :tangle no
(define-mapping (name key::key-type)::value-type
  default-expression)
#+END_SRC

where ~default-expression~ is an arbitrary Scheme
expression, so it can either provide some default value,
some actual mapping, or throw an error for an unassigned
key.

Therefore, we could define a function that computes
a /Fibonacci/ sequence in the following way:

#+BEGIN_SRC scheme :tangle no

(define-mapping (fib n::integer)::integer
  (+ (fib (- n 1)) (fib (- n 2))))

(set! (fib 0) 1)
(set! (fib 1) 1)

#+END_SRC

**** Procedure properties

Kawa Scheme provides a mechanism similar to the Lisp's
/property lists/, but instead of associating properties with
symbols, it associates them with procedures. Hence they are
called /procedure properties/, and they are accessed using
the ~(procedure-property <procedure> <symbol>)~ procedure,
and modified using the ~(set-procedure-property! <procedure>
<symbol> <value>)~. An entire list of all defined procedure
properties can be accessed using the ~(procedure-properties
<procedure>)~ function. See the [[https://www.gnu.org/software/kawa/Procedure-properties.html][Procedure properties]] section
of the Kawa manual for more information.

Since this interface is somewhat clumsy, it is convenient
to define the following macro for augmenting a procedure
with properties:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (with-procedure-properties ((name value) ...)
                       procedure)
  (let ((proc procedure))
    (set-procedure-property! proc 'name value)
    ...
    proc))

#+END_SRC

**** The ~mapping~ and ~define-mapping~ macros

Kawa has a limited support for Java's generic types (see the
section [[https://www.gnu.org/software/kawa/Parameterized-Types.html][Parameterized Types]] in Kawa manual), and the
counterpart of Java's ~java.util.Map<KeyType, ValueType>~ in
Kawa is ~java.util.Map[KeyType ValueType]~, which Kawa's
reader reads as ~($bracket-apply$ java.util.map KeyType
ValueType)~:

#+BEGIN_SRC scheme :tangle language/extensions.scm

  (e.g.
    (call-with-input-string "java.util.Map[KeyType ValueType]" read)
  ===> ($bracket-apply$ java.util.Map KeyType ValueType))

#+END_SRC

Since GRASP does not support some of Kawa's reader
extensions, including the one above, we are not using it in
GRASP's source code in order to make it editable in GRASP.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (specialize generic-type concrete-types ...)
  ($bracket-apply$ generic-type concrete-types ...))

#+END_SRC

Here are the definitions of the ~mapping~ and ~define-mapping~ macros:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax mapping
  (syntax-rules (::)
    ((mapping (object::key-type)::value-type default)
     (let* ((entries ::java.util.Map ((specialize java.util.HashMap 
                                                  key-type value-type)))
            (getter (lambda (object::key-type)::value-type
                      (if (entries:containsKey object)
                          (entries:get object)
                          default))))
       (set! (setter getter) (lambda (arg value)
                               (entries:put arg value)))
       (with-procedure-properties ((table entries))
          getter)))

    ((mapping (object::key-type) default)
     (mapping (object::key-type)::java.lang.Object
               default))

    ((mapping (object)::value-type default)
     (mapping (object::java.lang.Object)::value-type
               default))

    ((mapping (object) default)
     (mapping (object::java.lang.Object)::java.lang.Object
              default))
    ))

#+END_SRC

Once ~mapping~ is defined, defining ~define-mapping~ is
fairly straightforward. The main difficulty is that we need
to account for users omitting key and value type specifier:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax define-mapping
  (syntax-rules (::)
    ((define-mapping (mapping-name object::key-type)::value-type
       default)
     (define-early-constant mapping-name
       (with-procedure-properties ((name 'mapping-name))
         (mapping (object::key-type)::value-type default))))

    ((define-mapping (mapping-name object::key-type) default)
     (define-mapping (mapping-name object::key-type)
       ::java.lang.Object
       default))

    ((define-mapping (mapping-name object)::value-type default)
     (define-mapping (mapping-name object::java.lang.Object)
       ::value-type
       default))

    ((define-mapping (mapping-name object) default)
     (define-mapping (mapping-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

#+END_SRC

Mind however, that associating keys with values isn't the
only capability of a hash table: it is a collection, which
means that we iterate over its elements. In our case, we can
obtain an iterable set of (assigned) keys of mapping by using
the ~keys~ function:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define (keys dict)
  (let ((table ::java.util.Map (procedure-property dict 'table)))
    (table:keySet)))

#+END_SRC

**** Inverse functions and two-directional mapping

Sometimes the need emerges to define a /bidirectional mapping/,
i.e. a pair of dictionaries, such that the keys of the first one
are the values of the second, and vice-versa.

In such cases, one mapping is an /inverse/ of another.

The concept of an /inverse function/ is commonly used in
mathematics, but automatic derivation of inverse functions
from function definitions can generally be a difficult
problem.

What seems to be a much simpler solution is to push the
burden onto the user:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define (inverse function)
  (procedure-property function 'inverse))

(set! (setter inverse)
      (lambda (function value)
        (set! (procedure-property function 'inverse) value)))

#+END_SRC

Once we have it in place, we can use it to define bidirectional
mappings:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax bimapping
  (syntax-rules (::)
    ((bimapping (object::key-type)::value-type default)
     (let* ((entries (make-hash-table[key-type value-type]))
            (inverse-entries (make-hash-table[value-type key-type]))
            (getter (lambda (object)
                      (hash-ref entries object
                                (lambda () default))))
            (inverse-getter (lambda (object)
                              (hash-ref inverse-entries object
                                        (lambda ()
                                          (hash-ref entries object
                                                    (lambda () default)))))))
       (set! (setter getter) (lambda (arg value)
                               (entries:put arg value)
                               (inverse-entries:put value arg)))
       (set! (setter inverse-getter) (lambda (arg value)
                                       (entries:put arg value)
                                       (inverse-entries:put value arg)))
       (set-procedure-property! inverse-getter 'table inverse-entries)
       (set-procedure-property! inverse-getter 'inverse getter)
       (with-procedure-properties ((table entries)
                                   (inverse inverse-getter))
          getter)))
    ((bimapping (object::key-type) default)
     (bimapping (object::key-type)::java.lang.Object
               default))

    ((bimapping (object)::value-type default)
     (bimapping (object::java.lang.Object)::value-type
               default))

    ((bimapping (object) default)
     (bimapping (object::java.lang.Object)::java.lang.Object
              default))
    ))

(define-syntax define-bimapping
  (syntax-rules (::)
    ((define-bimapping (bimapping-name object::key-type)::value-type
       default)
     (define-early-constant bimapping-name
       (with-procedure-properties ((name 'bimapping-name))
         (bimapping (object::key-type)::value-type default))))

    ((define-bimapping (bimapping-name object::key-type) default)
     (define-bimapping (bimapping-name object::key-type)
       ::java.lang.Object
       default))

    ((define-bimapping (bimapping-name object)::value-type default)
     (define-bimapping (bimapping-name object::java.lang.Object)
       ::value-type
       default))

    ((define-bimapping (bimapping-name object) default)
     (define-bimapping (bimapping-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

#+END_SRC

**** Attributes

Object-oriented programming traditionally uses the term
/property/ to refer to variables that /belong to/ a
particular object. This is a very good name, because it
indicates that those variables are essential for describing
that object.

But the English vocabulary contains yet another term that is
used for describing objects, namely - /attribute/.

An attribute is something that does not belong to an
object - instead, it is something that someone /attributes/
(well, duh) to that object. For example, while an object's
mass or size can be its property, its position on the screen
is its attribute (because it can be rendered multiple times
from different points of view and on many screens).

Technically, we are going to represent attributes using
/weak hash tables/. Other than that, they are going to use
the same interface (and a very similar implementation) as we
did in case of ~mapping~.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax attribute
  (syntax-rules (::)
    ((attribute (object::key-type)::value-type default)
     (let ((table ::java.util.Map
                  ((specialize java.util.WeakHashMap
                               key-type value-type))))
       (define (create table::java.util.WeakHashMap)
         (let ((getter ::procedure
                       (lambda (object::key-type)::value-type
                         (if (table:contains-key object)
                             (table:get key)
                             default))))
           (set! (setter getter)
                 (lambda (arg::key-type value::value-type)
                   (table:put arg value)))
           (with-procedure-properties ((table table)
                                       (clone (lambda ()
                                                (create (copy table)))))
            getter)))

       (create table)))

    ((attribute (object::key-type) default)
     (attribute (object::key-type)::java.lang.Object
               default))

    ((attribute (object)::value-type default)
     (attribute (object::java.lang.Object)::value-type
               default))

    ((attribute (object) default)
     (attribute (object::java.lang.Object)::java.lang.Object
               default))
    ))

;; attribute+ is like attribute but it stores the default
;; value for every enquired object
(define-syntax attribute+
  (syntax-rules (::)
    ((attribute+ (object::key-type)::value-type default)
     (let ((table ::java.util.Map
                  ((specialize java.util.WeakHashMap
                                    key-type value-type))))
       (define (create table::java.util.WeakHashMap)
         (let ((getter ::procedure
                       (lambda (object::key-type)::value-type
                         (if (table:contains-key object)
                             (table:get object)
                             (let ((value default))
                                (table:put object value)
                                value)))))
           (set! (setter getter)
                 (lambda (arg::key-type value::value-type)
                   (table:put arg value)))
           (with-procedure-properties ((table table)
                                       (clone (lambda ()
                                                (create (copy table)))))
              getter)))

       (create table)))

    ((attribute+ (object::key-type) default)
     (attribute+ (object::key-type)::java.lang.Object
                default))

    ((attribute+ (object)::value-type default)
     (attribute+ (object::java.lang.Object)::value-type
                default))

    ((attribute+ (object) default)
     (attribute+ (object::java.lang.Object)::java.lang.Object
                default))
    ))

(define-syntax define-attribute
  (syntax-rules (::)
    ((define-attribute (attribute-name object::key-type)
       ::value-type
       default)
     (define-early-constant attribute-name
       (with-procedure-properties
        ((name 'attribute-name))
        (attribute (object::key-type)::value-type default))))

    ((define-attribute (attribute-name object::key-type) default)
     (define-attribute (attribute-name object::key-type)
       ::java.lang.Object
       default))

    ((define-attribute (attribute-name object)::value-type default)
     (define-attribute (attribute-name object::java.lang.Object)
       ::value-type
       default))

    ((define-attribute (attribute-name object) default)
     (define-attribute (attribute-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

(define-syntax define-attribute+
  (syntax-rules (::)
    ((define-attribute+ (attribute-name object::key-type)
       ::value-type
       default)
     (define-early-constant attribute-name
       (with-procedure-properties
        ((name 'attribute-name))
        (attribute+ (object::key-type)::value-type default))))

    ((define-attribute+ (attribute-name object::key-type) default)
     (define-attribute+ (attribute-name object::key-type)
       ::java.lang.Object
       default))

    ((define-attribute+ (attribute-name object)::value-type
       default)
     (define-attribute+ (attribute-name object::java.lang.Object)
       ::value-type
       default))

    ((define-attribute+ (attribute-name object) default)
     (define-attribute+ (attribute-name object::java.lang.Object)
       ::java.lang.Object
       default))
    ))

#+END_SRC

As you can see, we have defined two kinds of attributes, one
simply called ~attribute~, and another ~attribute+~. The
difference between the two is that if we ask for an
attribute that is not present in the table, ~attribute+~
will store the resut of evaluating the ~default~ form.

**** Other operations on mappings

Here we provide a bunch of functions and macros for
removing all or some elements of a mapping:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (unset! (mapping object))
  (let ((table ::java.util.Map (procedure-property mapping 'table)))
    (table:remove object)))

(define (reset! mapping)::void
  (let ((table ::java.util.Map (procedure-property mapping 'table)))
    (table:clear)))

(define-syntax-rule (assigned? (mapping key))
  (let ((table ::java.util.Map (procedure-property mapping 'table)))
    (table:contains-key key)))

#+END_SRC

We also provide the ~update!~ macro, which adds a key-value
pair to a mapping only when it is different from the current
value. This allows to save space in case someone tries to
add a default value to the mapping.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax-rule (update! (mapping object) expression)
  (let ((value expression))
    (unless (equal? (mapping object) value)
      (set! (mapping object) value))))

#+END_SRC

*** Currying and caching

Hash tables can be used for other purposes than attributing
properties to objects. In particular, they can be used for
caching the results of functions.

The thing is that while mappings and attributes were
both functions of a single argument, Scheme functions
can in general take more than one argument.

In case of caching, this means that we need to create
multi-level hash tables. This can be achieved by means
of syntactic currying:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax curried
  (lambda (stx)
    (syntax-case stx (:: :=)

      ((_ kw (key arg :: type := value . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (key arg :: type . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (key arg := value . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg) (curried kw args body)))
      
      ((_ kw (key arg . args) body)
       (keyword? (syntax->datum #'key))
       #'(kw (arg) (curried kw args body)))

      ((_ kw (arg :: type := value . args) body)
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (arg :: type . args) body)
       #'(kw (arg::type) (curried kw args body)))

      ((_ kw (arg := value . args) body)
       #'(kw (arg) (curried kw args body)))
      
      ((_ kw (arg . args) body)
       #'(kw (arg) (curried kw args body)))
      
      ((_ kw () body)
       #'body)
      )))

(define-syntax curried-application
  (lambda (stx)
    (syntax-case stx (:: :=)
      ((_ procedure)
       #'procedure)

      ((_ procedure key arg :: type := value args ...)
       (keyword? (syntax->datum #'key))      
       #'(curried-application (procedure arg) args ...))

      ((_ procedure key arg :: type args ...)
       (keyword? (syntax->datum #'key))
       #'(curried-application (procedure arg) args ...))

      ((_ procedure key arg := value args ...)
       (keyword? (syntax->datum #'key))
       #'(curried-application (procedure arg) args ...))

      ((_ procedure key arg args ...)
       (keyword? (syntax->datum #'key))
       #'(curried-application (procedure arg) args ...))
      
      ((_ procedure arg :: type := value args ...)
       #'(curried-application (procedure arg) args ...))

      ((_ procedure arg :: type args ...)
       #'(curried-application (procedure arg) args ...))

      ((_ procedure arg := value args ...)
       #'(curried-application (procedure arg) args ...))

      ((_ procedure arg args ...)
       #'(curried-application (procedure arg) args ...))
      )))

#+END_SRC

Having currying in place, we can use it for defining cache:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax cache
  (syntax-rules (::)
    ((cache args::type body)
     (let* ((cached (curried attribute+ args body))
            (invoker (lambda* args::type
                                (curried-application cached . args))))
       (with-procedure-properties ((cache cached))
         invoker)))
    ((cache args body)
     (let* ((cached (curried attribute+ args body))
            (invoker (lambda* args
                                (curried-application cached . args))))
       (with-procedure-properties ((cache cached))
         invoker)))))
    
(define-syntax define-cache
  (syntax-rules (::)
    ((define-cache (name . args)::type body)
     (define-early-constant name
       (cache args::type body)))

    ((define-cache (name . args) body)
     (define-early-constant name
       (cache args body)))
    ))

(define (invalidate! cache . point)
  (let ((table ::java.util.Map (procedure-property cache 'table)))
    (match point
      ('() (table:clear))
      (`(,point) (table:remove point))
      (`(,head . ,tail)
       (apply invalidate! (cache head) tail)))))

(define (invalidate-cache! invoker . point)
  (apply invalidate! (procedure-property invoker 'cache) point))

#+END_SRC

We can use the cache defined that way to implement /hash
consing/:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-object (immutable-pair car cdr)

  (define (setCar value)
    (error "The pair is immutable: " (this)))

  (define (setCdr value)
    (error "The pair is immutable: "(this)))
  (pair car cdr))

(define-cache (hash-cons head tail)
  (immutable-pair head tail))

#+END_SRC

*** Generic types

Kawa's support for generic types is very limited.  It
provides some syntax for using Java's generics, but very
little beyond that. Moreover, the type of a procedure is
simply ~procedure~, regardless of its argument types or
result type (which is probably unthinkable to people
accustomed to languages such as ML or Haskell, as well
as some modern main-stream languages).

Fortunately, expressions in type positions are also
macro-expanded, which allows us to invent arbitrary
notations for expressing various properties of types
that we define.

For example, we can define the following macro to
express a type signature of a procedure:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax maps
  (syntax-rules (to:)
    ((_ input-types to: output-type + ...)
     procedure)))

#+END_SRC

we can also define an identical macro to designate a
procedure that is meant to be mutable (like ~attribute~
or ~mapping~)

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax !maps
  (syntax-rules (to:)
    ((_ input-types to: output-type + ...)
     procedure)))

#+END_SRC

Likewise, we can define similar trivial macros to designate
things like enum sets, uniform lists, sets, arrays, vectors,
sequences, parameters, subtypes, variant types, optional
types and multiple values. We also redefine the ~unquote~
operator outside of the ~quasiquote~ context to designate
a type variable (rather than syntax error):

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-alias EnumSet java.util.EnumSet)

(define-syntax-rule (list-of type)
  list)

(define-syntax-rule (set-of type)
  (specialize java.util.Set type))

(define-syntax-rule (EnumSetOf type)
  (specialize java.util.EnumSet type))

(define-syntax-rule (vector-of type)
  vector)

(define-syntax-rule (sequence-of type)
  sequence)

(define-syntax-rule (array-of type)
  (specialize type))

(define-syntax-rule (parameter-of type)
  (specialize parameter type))

(define-syntax subtype-of
  (syntax-rules ()
    ((subtype-of supertype . _)
     supertype)))

(define-syntax-rule (either type ...)
  java.lang.Object)

(define-syntax-rule (maybe type)
  (either type #!null))

(define-syntax-rule (Values type ...)
  java.lang.Object)

(define-syntax-rule (unquote x)
  java.lang.Object)

#+END_SRC

*** Basic functions

There is a number of functions that are commonly known among
schemers and functional programmers (via libraries such as
[[https://srfi.schemers.org/srfi-1/srfi-1.html][SRFI-1]] or Haskell Prelude) for operating on sequences.

We provide our own variants of those functions here. Some of
them were adapted to operate on arbitrary Java collections,
and others are generalized to operate on improper lists (their
names end with the ~.~ (dot) character).

The function commonly known as ~filter~ in SRFI-1 and
Haskell prelude is named ~only~, because the name ~filter~
is ambiguous.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define (any satisfying? elements)
  (escape-with return
    (for x in elements
      (let ((result (satisfying? x)))
	(when result
	  (return result))))
    #f))

(e.g.
 (any even? '(1 2 3)))

(define (none satisfying? elements)
  (not (any satisfying? elements)))

(e.g.
 (none odd? '(2 4 6)))

(define (any. satisfying? elements)
  (match elements
    (`(,h . ,t)
     (or (satisfying? h)
	 (any. satisfying? t)))
    ('()
     #f)
    (x
     (satisfying? x))))
(e.g.
 (any. zero? '(3 2 1 . 0)))

(define (every satisfying? elements)::boolean
  (escape-with return
    (for x in elements
      (unless (satisfying? x)
	(return #f)))
    #t))

(e.g.
 (every even? '(2 4 6)))

(define (every. satisfying? elements)
  (match elements
    (`(,h . ,t)
     (and (satisfying? h)
	  (every. satisfying? t)))
    ('()
     #t)
    (x
     (satisfying? x))))

(e.g.
 (every. even? '(2 4 6 . 8)))

(define (only cool? stuff)
  (let* ((result (cons #f '()))
	 (cone result))
    (for x in stuff
      (when (cool? x)
	(set-cdr! cone (cons x '()))
	(set! cone (cdr cone))))
    (cdr result)))

(e.g.
 (only even? '(1 2 3 4 5 6))
 ===> (2 4 6))

(define (fold-left f x0 . xs*)
  
  (define (fold-left1 xs::java.util.List)
    (for x in xs
      (set! x0 (f x0 x)))
    x0)

  (define (fold-left2 xs1::java.util.List xs2::java.util.List)
    (let ((xi1 ::java.util.Iterator (xs1:listIterator))
	  (xi2 ::java.util.Iterator (xs2:listIterator)))
      (let loop ((xo x0))
	(if (and (xi1:hasNext) (xi2:hasNext))
	    (loop (f xo (xi1:next) (xi2:next)))
	    xo))))

  (define (fold-left3 xs1::java.util.List
		      xs2::java.util.List
		      xs3::java.util.List)
    (let ((xi1 ::java.util.Iterator (xs1:listIterator))
	  (xi2 ::java.util.Iterator (xs2:listIterator))
	  (xi3 ::java.util.Iterator (xs3:listIterator)))
      (let loop ((xo x0))
	(if (and (xi1:hasNext) (xi2:hasNext) (xi3:hasNext))
	    (loop (f xo (xi1:next) (xi2:next) (xi3:next)))
	    xo))))

  (define (fold-left* . xs*)
    (let ((iterators (map (lambda (x::java.util.List)
			    (x:listIterator))
			  xs*)))
      (let loop ((xo x0))
	(if (every (lambda (it::java.util.Iterator)
		     (it:hasNext))
		   iterators)
	    (loop
	     (apply
	      f xo
	      (map (lambda (it::java.util.Iterator)
		     (it:next))
		   iterators)))
	    xo))))
  (cond
   ((null? xs*) x0)
   ((null? (cdr xs*)) (fold-left1 (car xs*)))
   ((null? (cddr xs*)) (fold-left2 (car xs*)
				   (cadr xs*)))
   ((null? (cdddr xs*)) (fold-left3 (car xs*)
				    (cadr xs*)
				    (caddr xs*)))
   (else (apply fold-left* xs*))))

(e.g.
 (fold-left (lambda (a b) `(,a + ,b)) 'e '(a b c d))
 ===> ((((e + a) + b) + c) + d))

(define (fold-right f x0 . xs*)
  (define (fold-right1 f x0 xs)
    (if (null? xs)
	x0
	(f (car xs) (fold-right1 f x0 (cdr xs)))))

  (define (fold-right2 f x0 xs xs2)
    (if (or (null? xs) (null? xs2))
	x0
	(f (car xs) (car xs2)
	   (fold-right2 f x0 (cdr xs) (cdr xs2)))))

  (define (fold-right* f x0 . xs*)
    (if (any null? xs*)
	x0
	(apply f (fold-right1
		  (lambda (x y)
		    (cons (car x) y))
		  (list (apply fold-right* f x0 (map cdr xs*)))
		  xs*))))
  (cond
   ((null? xs*) x0)
   ((null? (cdr xs*)) (fold-right1 f x0 (car xs*)))
   ((null? (cddr xs*)) (fold-right2 f x0 (car xs*) (cadr xs*)))
   (else (apply fold-right* f x0 xs*))))

(e.g.
 (fold-right (lambda (a b) `(,a + ,b)) 'e '(a b c d))
 ===> (a + (b + (c + (d + e)))))

(define (nothing . _)::void (values))

(define (never . _)::boolean #f)

(define (always . _) ::boolean #t)

(define (negation proc)
  (lambda args
    (not (apply proc args))))

(define (find satisfying-element?::(maps (,a) to: boolean) in::sequence)
  (escape-with return
    (for-each (lambda (x)
		(when (satisfying-element? x)
		  (return x)))
	      in)
    #!null))

(e.g.
 (find even? '(1 2 3)) ===> 2)

(define (map! f inout . in*)
  (cond
   ((isnt inout list?)
    (cond 
     ((null? in*)
      (for i from 0 below (length inout)
	   (set! (inout i) (f (inout i))))
      inout)
     ((null? (cdr in*))
      (escape-with return
	(let ((i 0)
	      (n (length inout)))
	  (for x in (cdr in*)
	    (set! (inout i) (f (inout i) x))
	    (set! i (+ i 1))
	    (when (is i >= n)
	      (return inout)))
	  (return inout))))
     (else
      (let ((n (length inout))
	    (its (map (lambda (l::java.util.List)
			(l:listIterator))
		      in*)))
	(escape-with return
	  (for i from 0 below n
	       (if (every (lambda (it::java.util.Iterator)
			    (it:hasNext)) its)
		   (set! (inout i)
		     (apply f (inout i)
			    (map (lambda (it::java.util.Iterator)
				   (it:next)) its)))
		   (return inout)))
	  (return inout))))))
   ((null? in*)
    (let loop ((tip inout))
      (if (pair? tip)
	  (begin
	    (set! (car tip) (f (car tip)))
	    (loop (cdr tip)))
	  inout)))
   ((null? (cdr in*))
    (let loop ((tip1 inout)
	       (tip2 (car in*)))
      (if (and (pair? tip1) (pair? tip2))
	  (begin
	    (set! (car tip1) (f (car tip1) (car tip2)))
	    (loop (cdr tip1) (cdr tip2)))
	  inout)))
   ((null? (cddr in*))
    (let loop ((tip1 inout)
		  (tip2 (car in*))
		  (tip3 (cadr in*)))
	 (if (and (pair? tip1) (pair? tip2) (pair? tip3))
	     (begin
	       (set! (car tip1) (f (car tip1) (car tip2) (car tip3)))
	       (loop (cdr tip1) (cdr tip2) (cdr tip3))
	       inout))))
   (else
    (let loop ((tip inout)
	       (tips in*))
	 (if (and (pair? tip) (every pair? tips))
	     (begin
	       (set! (car tip) (apply f (car tip) (map car tips)))
	       (loop (cdr tip) (map! cdr tips)))
	     inout)))))

(define (only. satisfying? elements . moreso)
  (cond ((null? elements)
	 (apply values '() moreso))
	((pair? elements)
	 (let ((result (cons (car elements) (map car moreso))))
	   (cond
	    ((apply satisfying? result)
	     (map! list result)
	     (let ((tips (map values result)))
	       (let loop ((elements (cdr elements))
			  (moreso (map cdr moreso)))
		 (cond
		  ((null? elements)
		   (apply values result))
		  ((pair? elements)
		   (when (apply satisfying? (car elements)
				(map car moreso))
		     (map! (lambda (tip elem)
			     (set-cdr! tip (cons (car elem) '()))
			     (cdr tip))
			   tips (cons elements moreso)))
		   (loop (cdr elements)
			 (map cdr moreso)))
		  ((apply satisfying? elements moreso)
		   (map! (lambda (tip item)
			   (set-cdr! tip item)
			   tip)
			 tips (cons elements moreso))
		   (apply values result))
		  (else
		   (apply values result))))))
	    (else
	     (apply only. satisfying? (cdr elements)
		    (map cdr moreso))))))
	((apply satisfying? elements moreso)
	 (apply values elements moreso))
	(else
	 (apply values '() (map (lambda _ '()) moreso)))))

(e.g. (only. even? '(2 . 3)) ===> (2))

(e.g. (only. even? '(3 . 2)) ===> 2)

(e.g. (only. even? 2) ===> 2)

(e.g. (only. even? 3) ===> ())

(e.g. (only. (is (+ _ _) even?)
	     '(1 2 3 4 . 5) '(2 4 6 8 . 9))
      ===>    (  2   4 . 5)  (  4   8 . 9))

(define (concatenate list-of-lists)
  (apply append list-of-lists))

(e.g.
 (concatenate '((a b) (c) (d e f)))
 ===> (a b c d e f))

(define (append-map f l . ls)
  (if (null? ls)
    (concatenate (map f l))
   (concatenate (apply map f ls))))

(define (current-working-directory)::string
  (let ((working-directory ::java.io.File (java.io.File ".")))
    (working-directory:getAbsolutePath)))

(define (current-time-ms)::long
  (java.lang.System:currentTimeMillis))

(define-alias hypotenuse java.lang.Math:hypot)

#+END_SRC

*** Sets

In theory, a set could be represented by a mapping whose
keys are the elements of the set, and whose values
are ~boolean~ values, i.e. either ~#true~ or ~#false~.

On the other hand, sets are often considered to be the most
fundamental concept of mathematics, with a distinct and well
known set of operations, such as ~union~, ~intersection~
or ~difference~.

Our implementation of sets piggybacks on that provided by
Java. But in the spirit of SRFI-1, we also allow to treat
lists as sets.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-simple-class set (java.util.HashSet)
  ((toString)::String
   (let ((builder ::java.lang.StringBuilder (java.lang.StringBuilder)))
     (builder:append "[set")
     (for item in (this)
       (builder:append " ")
       (cond
	((or (string? item) (String? item))
	 (builder:append "\"")
	 (builder:append (item:toString))
	 (builder:append "\""))
	((char? item)
	 (builder:append "#\\")
	 (builder:append (as char item)))
	(else
	 (builder:append (item:toString)))))
     (builder:append "]")
     (builder:toString))))

(define* (is element in collection)
  (if (instance? collection java.util.Set)
      (let ((set ::java.util.Set (as java.util.Set collection)))
	(set:contains element))
      (any (is _ equal? element) collection)))

(define (empty? x)::boolean
  (or (and (is x gnu.lists.LList?)
	   (isnt x gnu.lists.Pair?))
      (and-let* ((x ::java.util.Collection))
	(x:isEmpty))
      (and-let* (((procedure? x))
		 (table ::java.util.Collection (procedure-property x 'table)))
	(empty? table))))

(define (union set . sets)
  (define (list-union a b)
    (fold-left (lambda (set element)
		 (if (is element in set)
		     set
		     `(,element . ,set)))
	       a b))
  (if (and (instance? set java.util.Set)
	   (instance? set java.lang.Cloneable))
      (with-compile-options
       warn-unknown-member: #f
       (let ((clone ::java.util.Set (set:clone)))
	 (for collection ::java.util.Collection in sets
	      (clone:addAll collection))
	 clone))
      (fold-left list-union set sets)))

(define (union! set::java.util.Set . sets)
  (for collection ::java.util.Collection in sets
       (set:addAll collection))
  set)

(e.g.
 (union '(a b c) '(b c d e))
 ===> (e d a b c))

(define (intersection set . sets)
  (define (list-intersection a b)
    (only (is _ in b) a))
  (if (and (instance? set java.util.Set)
	   (instance? set java.lang.Cloneable))
      (with-compile-options
       warn-unknown-member: #f
       (let ((clone ::java.util.Set (set:clone)))
	 (for collection ::java.util.Collection in sets
	      (clone:retainAll collection))
	 clone))
      (fold-left list-intersection set sets)))

(e.g.
 (intersection '(a b c) '(b c d) '(c d e))
 ===> (c))

(define (difference set . sets)
  (define (list-difference a b)
    (fold-left (lambda (set element)
		 (if (is element in set)
		     (only (isnt _ equal? element) set)
		     set))
	       a b))
  (if (and (instance? set java.util.Set)
	   (instance? set java.lang.Cloneable))
      (with-compile-options
       warn-unknown-member: #f
       (let ((clone ::java.util.Set (set:clone)))
	 (for collection ::java.util.Collection in sets
	      (clone:removeAll collection))
	 clone))
      (fold-left list-difference set sets)))

(e.g.
 (difference '(a b c) '(b c d))
 ===> (a))

(define (subset? a b)
  (if (instance? b java.util.Set)
      (let ((set ::java.util.Set (as java.util.Set b)))
	(set:containsAll a))
      (every (is _ in b) a)))

(e.g.
 (is '(a b) subset? '(b a c)))

(define (same-sets? a b)
  (and (is a subset? b)
       (is b subset? a)))

(e.g.
 (same-sets? '(a b c) '(b a c)))

#+END_SRC

*** Parameters

Parameters seem to be a mechanism fairly unique to Scheme,
although in some ways it resembles Scala's /implicits/, and
has recently been considered for inclusion in Java, under
the name of /scoped values/ (see [[https://openjdk.org/jeps/446][JEP 446]]). Its heritage
traces back to the notion of /dynamic scoping/ in early
LISP, which has been preserved as /special variables/ in
Common Lisp.

Kawa provides parameters, but they cannot be shared between
threads.

Because of that, the developers of GRASP had to implement a
variant of parameters whose instant value is shared between
theads.

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-simple-class SharedThreadLocation (gnu.mapping.ThreadLocation)

  (location-name ::gnu.mapping.Symbol)
  (default-value)
  
  ((setWithSave value) access: 'synchronized
   (let* ((old-location (invoke-special gnu.mapping.ThreadLocation (this) 'get))
	  (new-location (gnu.mapping.SharedLocation
			 location-name
			 #!null
			 (java.lang.System:currentTimeMillis))))
     (invoke-special gnu.mapping.ThreadLocation (this) 'set new-location)
     (new-location:set value)
     old-location))
  
  ((setRestore old-location) access: 'synchronized
   (invoke-special gnu.mapping.ThreadLocation (this) 'set old-location))
  
  ((set value) access: 'synchronized
   (let ((location ::gnu.mapping.SharedLocation
		   (invoke-special gnu.mapping.ThreadLocation
				   (this) 'get)))
     (if location
	 (location:set value)
	 (let ((new-location (gnu.mapping.SharedLocation
			      location-name
			      #!null
			      (java.lang.System:currentTimeMillis))))
	   (invoke-special gnu.mapping.ThreadLocation (this) 'set new-location)
	   (new-location:set value)))))
  
  ((get) access: 'synchronized
   (let ((location ::gnu.mapping.SharedLocation
		   (invoke-special gnu.mapping.ThreadLocation
				   (this) 'get)))
     (if location
	 (location:get)
	 default-value)))
  
  ((*init* name ::gnu.mapping.Symbol value)
   (set! location-name name)
   (set! default-value value)
   (let ((new-location (gnu.mapping.SharedLocation
			location-name
			#!null
			(java.lang.System:currentTimeMillis))))
     (invoke-special gnu.mapping.ThreadLocation (this) 'set new-location)
     (new-location:set value))))

(define (make-shared-parameter name init #!optional (converter #!null))
  (unless (eq? converter #!null)
    (set! init (converter init)))
  (let* ((loc (SharedThreadLocation:new name init))
         (conv ::gnu.mapping.Procedure
               (if (or (eq? converter #!null)
                       (gnu.mapping.Procedure? converter))
                   converter
                   (lambda (x) (converter x)))))
    (gnu.mapping.LocationProc:new loc conv)))

(define-syntax define-parameter
  (syntax-rules (::)
    
    ((_ (parameter-name) :: type initial-value)
     (define-early-constant parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name) :: type)
     (define-early-constant parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name #!null)))
    
    ((_ (parameter-name) initial-value)
     (define-early-constant parameter-name :: parameter
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name))
     (define-early-constant parameter-name :: parameter
       (make-shared-parameter 'parameter-name #!null)))
    ))

(define-syntax define-parameter+
  (syntax-rules (::)
    
    ((_ (parameter-name) :: type initial-value)
     (define parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name) :: type)
     (define parameter-name :: parameter[type]
       (make-shared-parameter 'parameter-name #!null)))
    
    ((_ (parameter-name) initial-value)
     (define parameter-name :: parameter
       (make-shared-parameter 'parameter-name initial-value)))

    ((_ (parameter-name))
     (define parameter-name :: parameter
       (make-shared-parameter 'parameter-name #!null)))
    ))

#+END_SRC

Sometimes, when the value of a parameter comes from another
location, and the value of the parameter has been mutated,
it may be desirable to propagate the change to the original
location, which can be achieved with the
~parameterize/update-sources~ macro:

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax parameterize/update-sources
  (lambda (stx)
    (syntax-case stx ()
      ((_ ((param source) ...) body + ...)
       (with-syntax (((previous-value ...)
		      (generate-temporaries
		       #'(source ...))))
	 #'(parameterize ((param source) ...)
	     (let ((previous-value source) ...)
	       (try-finally
		(begin body + ...)
		(begin
		  (when (eqv? previous-value source)
		    (set! source (param)))
		  ...)))))))))

#+END_SRC

where ~try-finally~ is Kawa's (non-reentrable) counterpart
of ~dynamic-wind~ that can be found in some Scheme
implementations.

*** Miscellaneous macros, classes and functions

#+BEGIN_SRC scheme :tangle language/extensions.scm

(define-syntax otherwise
  (syntax-rules ()
    ((_)
     #f)
    ((_ value)
     value)
    ((_ default . precedents)
     (or (otherwise . precedents) default))))

(define-syntax-rule (begin/or clause ...)
  (let ((result #f))
    (set! result (or clause result))
    ...
    result))

(define-syntax-rule (begin/and clause ...)
  (let ((result #t))
    (set! result (and clause result))
    ...
    result))

(define (memoize proc)
  (let ((table ::java.util.Map (java.util.HashMap)))
    (with-procedure-properties ((table table))
      (lambda args
        (if (table:contains-key args)
            (apply values (table:get args))
            (call-with-values (lambda () (apply proc args))
              (lambda result
                (table:put args result)
                (apply values result))))))))

(define-syntax-rule (define/memoized (name . args) . body)
  (define name (memoize (lambda args . body))))

(define-object (InputPortLineIterator port::InputPort)
  ::(specialize java.util.Iterator string)
  (define next-line ::(maybe (either string EndOfFile)) #!null)

  (define (hasNext) ::boolean
    (unless next-line
      (set! next-line (read-line port)))
    (isnt next-line eof-object?))

  (define (next)
    (unless next-line
      (set! next-line (read-line port)))
    (unless (string? next-line)
      (throw (java.util.NoSuchElementException)))
    (let ((result next-line))
      (set! next-line #!null)
      result)))

(define-object (InputPortLines port::InputPort)
  ::(specialize java.lang.Iterable string)
  (define (iterator)::(specialize java.util.Iterator string)
    (InputPortLineIterator port)))

(define* (lines port ::InputPort := (current-input-port))
  ::(specialize java.lang.Iterable string)
  (InputPortLines port))

#+END_SRC


*** Ending remarks

The language extensions described in this chapter are not
perfect. For example, the type signatures for collections
and optional elements are clearly a hoax. Moreover, the
classes that can be defined using the ~define-object~ form
cannot contain inner classes. We don't provide syntax for
defining anonymous classes. It would also be desirable to be
able to define /callable/ classes, whose instances could be
invoked just like regular functions.

There are probably many other things that could be improved.
Such improvements would require either modifying the host
Kawa compiler, or implementing a programming language
completely from scratch.

We hope that over time we'll be able to improve those areas.
Or maybe - if you enjoy the aesthetics of this language -
you'll be willing to contribute and, for example, implement
more decent type checking for the language.

** The architecture of GRASP

So far, reading this text may have seen a bit like reading a
grammar book or a dictionary: it didn't seem to have any
specific topic, or /thing it is about/.

In this part we're going to finally tackle the actual subject
of this book, namely -- the GRASP editor.

GRASP is designed to run in many different environments.
And while the code for things like handling input and
rendering graphics is going to be different in all of its
environments, the core architecture will be shared among
them.

The code snippets from this chapter will be placed in the
~editor/architecture.scm~ file.

#+BEGIN_SRC scheme :tangle editor/architecture.scm :mkdirp yes :noweb yes
<<header>>
(module-name (editor architecture))
(import (language extensions))
#+END_SRC

*** An overview

Every interactive program needs to be able to gather user
input, use it to modify some internal state, and present at
least some part of that state back to the user.

Most of the input comes from the following two sources:
- keyboard
- pointing device (such as a mouse or a touch screen)

Some other sources of input are also possible (such as
microphone or accelerometer), but we're not going to worry
about them for now.

All input is going to be passed to a singleton object called
~main~. The ~main~ object keeps a reference to an object
that satisfies the ~Application~ interface, and passes all
of the received input to that object.

The reason for that indirection is that GRASP isn't just a
code editor, but is also an application platform: some of
the user-defined /interactive visual syntactic extensions/
can serve as actual applications.

The reference is assigned during the initialization of
GRASP.  Normally this is done by interpreting the
~assets/init.scm~ script that is bundled with the ~.jar~ /
~.apk~ file that is used for GRASP's distribution (they're
both ~.zip~ files), but it could also be done by passing
additional parameter through the command line.

An ~Application~ must be capable of receiving user input,
rendering itself to the screen and getting
maximized/unmaximized (and therefore resized).

As to user input, it can either be a typed key, or some kind
of pointer (mouse, pencil, finger).

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Interactive ()
  ;; by convention, the function that reacted to the input
  ;; ought to return #true
  (tap! finger::byte #;at x::real y::real)::boolean
  (press! finger::byte #;at x::real y::real)::boolean
  (second-press! finger::byte #;at x::real y::real)::boolean
  (double-tap! finger::byte x::real y::real)::boolean
  (long-press! finger::byte x::real y::real)::boolean
  (key-typed! key-code::long)::boolean)

#+END_SRC

You can see that the return type of each method of the
~Interactive~ interface is ~boolean~. This way, the object
informs its caller whether the input has been consumed (if
it hasn't, the caller can decide to handle it for itself).

This may seem irrelevant now, but we'll see that apart from
~Application~ there are many other instances of
~Interactive~ objects in the GRASP code base.

You may also have noticed that there are no events
responsible for handling pointer movements. This is because
they are handled by a separate mechanism - the ~main~ object
contains a map from finger index to objects that implement
the ~Drag~ interface:

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Drag ()
  (move! x::real y::real dx::real dy::real)::void
  (drop! x::real y::real vx::real vy::real)::void)

(define-object (NoDrop)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    #!abstract)

  (define (drop! x::real y::real vx::real vy::real)::void
    (values)))

#+END_SRC

The rendering is done via a single function called
~render!~, which receives a single parameter - a boolean
value that is ~#true~ when the rendered thing is considered
/active/ (or /in focus/) and ~#false~ otherwise.

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Visual ()
  (render! active? ::boolean)::void)

#+END_SRC

Rendering occurs through a global object called ~painter~,
which implements the ~Painter~ interface. It will be
discussed later on.

The application window/frame is always rectangular (i.e. a
~Tile~), so it can be characterized by giving its width and
height.:

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Tile ()
  (width)::real
  (height)::real)

#+END_SRC

as we mentioned before, a we need to be able to set the size
of the application. A ~Tile~ that can be resized is
(hopefully unsurprisingly) called a ~ResizableTile~. It can
be arbitrarily large, but it can declare its own minimal
size (which shouldn't be smaller than the size of the
screen):

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface ResizableTile (Tile)
  (min-width)::real
  (min-height)::real
  (set-size! new-width::real new-height::real anchor::(maybe Object))::void)

#+END_SRC

Now we can specify more formally what we mean by an ~Application~:

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Application (Interactive Visual ResizableTile))
#+END_SRC

In object-oriented programming, it is customary to create a
/null object/, i.e. a trivial object that does nothing
interesting, but can be used as an initial value before the
proper initialization takes place. A null object for
~Application~ might look like this:

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-object (Passive)::Interactive
  (define (tap! finger::byte #;at x::real y::real)::boolean #false)
  (define (press! finger::byte #;at x::real y::real)::boolean #false)
  (define (second-press! finger::byte #;at x::real y::real)::boolean #false)
  (define (double-tap! finger::byte x::real y::real)::boolean #false)
  (define (long-press! finger::byte x::real y::real)::boolean #false)
  (define (key-typed! key-code::long)::boolean #false))

(define-object (NullApplication)::Application
  (define (render! active? ::boolean)::void (values))
  (define-private internal-width ::real 1)
  (define-private internal-height ::real 1)

  (define (width)::real internal-width)
  (define (height)::real internal-height)
  (define (min-width)::real 1)
  (define (min-height)::real 1)
  (define (set-size! new-width::real new-height::real 
                     anchor::(maybe Object))
    ::void
    (set! internal-width (max (min-width) new-width))
    (set! internal-height (max (min-height) new-height)))

  (Passive))

#+END_SRC

**** The ~main~ object

In a sense, GRASP can be thought of as a two-dimensional
extension of a UNIX shell. A shell is sometimes called a
/command line/, and similarly, a GRASP application could be
considered /command surface/.

The entry point to a program written in a language such as C
is - by convention - a ~main~ function. In the case of a
GRASP application the analogous role is played by the ~main~
object.

The ~main~ object serves as a gateway between the host's
input system and the world of GRASP's extensions.

Another such gateway (but for the rendering system)
will be the ~painter~ object. The ~main~ object delegates
input and rendering to its ~application~, and is responsible
for managing ~Drag~ objects

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-object (Main application ::Application)::Application

  (define (set-application! new-application ::Application)
    (set! application new-application))

  (delegate (render! active? ::boolean)::void application)

  (delegate (width)::real application)

  (delegate (height)::real application)

  (delegate (min-width)::real application)

  (delegate (min-height)::real application)

  (delegate (set-size! new-width::real new-height::real 
                       anchor::(maybe Object))
    ::void
    application)

  (define dragging ::(maps (byte) to: Drag)
    (mapping (finger::byte)::Drag #!null))

  (define (drag! finger::byte action::Drag)::void
    (set! (dragging finger) action))

  (define (undrag! finger::byte)::void
    (unset! (dragging finger)))

  (delegate (tap! finger::byte #;at x::real y::real)::boolean application)

  (delegate (press! finger::byte #;at x::real y::real)::boolean application)

  (define (release! finger::byte x::real y::real
		    vx::real vy::real)
    ::boolean
    (and-let* ((drag ::Drag (dragging finger)))
      (drag:drop! x y vx vy)
      (unset! (dragging finger))
      #t))

  (define (move! finger::byte x::real y::real dx::real dy::real)
    ::boolean
    (and-let* ((drag ::Drag (dragging finger)))
      (drag:move! x y dx dy)
      #t))

  (delegate (second-press! finger::byte #;at x::real y::real)::boolean application)

  (delegate (double-tap! finger::byte x::real y::real)::boolean application)

  (delegate (long-press! finger::byte x::real y::real)::boolean application)

  (delegate (key-typed! key-code::long)::boolean application))

(define-early-constant main ::Main (Main (NullApplication)))

#+END_SRC

**** The animation system

GRASP is fundamentally an interactive programming
environment. In order to be able to effectively communicate
with its users, it needs to be able to display animations.

An animation in GRASP is an interface that has exactly one
method - ~advance!)~ - that takes a timestep (a 32-bit
integer that expresses a time step in milliseconds) and
returns a ~boolean~ value that is ~#true~ if the animation
hasn't ended yet.

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Animation ()
  ;; if this method returns #f, it means
  ;; that the animation has ended and can be
  ;; discarded by the animation system
  (advance! timestep/ms::uint)::boolean)

#+END_SRC

**** ~Postponed~ and ~Cancellable~ actions

In the face of GRASP's interactivity, it makes sense to be
able to postpone certain actions, and also - once an action
is scheduled for later execution - to cancel it.

Different execution environments provide different means for
doing that, so it is convenient to be able to do that
using a unified interface:

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface Cancellable ()
  (cancel)::Cancellable)

(define-object (CancellableNothing)::Cancellable
  (define (cancel)::Cancellable
    (this)))

(define-early-constant cancellable-nothing ::Cancellable
  (CancellableNothing))

(define-interface Postponed ()
  (after delay-ms::long action::procedure)::Cancellable)

#+END_SRC

**** The ~TouchEventProcessor~

One place were ~Cancellable~ actions make sense is the
~TouchEventProcessor~, which is responsible for detecting
long press, second press and double tap gestures.

#+BEGIN_SRC scheme :tangle editor/architecture.scm

  (define-type (Position left: real top: real))

  (define-early-constant last-known-pointer-position
    ;; here we initialize 10 values, because Android can support up to
    ;; 10 pointers. That they'll be unused with other clients?  We don't
    ;; care!
    ((array-of Position)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)
     (Position left: 0 top: 0)))

  (define-object (TouchEventProcessor finger::byte
                                      target::Main
                                      run::Postponed)
  
    (define (distance x1::real y1::real x2::real y2::real)::real
      (hypotenuse (- x2 x1) (- y2 y1)))

    (define last-known-position ::Position
      (last-known-pointer-position finger))
  
    (define x0 ::real +nan.0)
    (define y0 ::real +nan.0)

    (define vx ::float 0.0)
    (define vy ::float 0.0)

    (define dx ::real +nan.0)
    (define dy ::real +nan.0)
  
    (define vicinity ::real 1.0)
  
    (define suppressed-presses ::byte 0)
  
    (define press-time-ms ::real -inf.0)
  
    (define release-time-ms ::real -inf.0)

    (define move-time-ms ::real -inf.0)

    (define long-press-time-ms ::real 700)

    (define double-tap-timeout-ms ::real 350)
  
    (define timeout ::Cancellable cancellable-nothing)

    (define (move! x::real y::real time-ms::real)::boolean
      (cond
       ((zero? suppressed-presses)
        (set! timeout (timeout:cancel))
        (let ((delta-ms ::real (- time-ms move-time-ms)))
          (set! dx (- x last-known-position:left))
          (set! dy (- y last-known-position:top))
          (set! vx (/ dx delta-ms))
          (set! vy (/ dy delta-ms))
          (set! last-known-position:left x)
          (set! last-known-position:top y)
          (set! move-time-ms time-ms)
          (target:move! finger x y dx dy)))
     
       ((is (distance x0 y0 x y) > vicinity)
        (set! timeout (timeout:cancel))
        (let ((suppressed ::int suppressed-presses))
          (set! suppressed-presses 0)
          (begin/or
           (if (is suppressed >= 2)
               (target:second-press! finger x0 y0)
               (target:press! finger x0 y0))
           (target:move! finger x0 y0 0 0)
           (target:move! finger x y (- x x0) (- y y0)))))
     
       (else
        #f)))

    (define (press! x::real y::real time-ms::real)::boolean
      (set! timeout (timeout:cancel))
      (set! last-known-position:left x)
      (set! last-known-position:top y)
      (set! vx 0)
      (set! vy 0)
      (set! press-time-ms time-ms)
      (set! move-time-ms time-ms)

      (match suppressed-presses
        (0 (set! suppressed-presses 1)
           (set! x0 x)
           (set! y0 y)
           (set! timeout
                 (run:after
                  long-press-time-ms
                  (lambda ()
                    (set! suppressed-presses 0)
                    (target:long-press! finger x0 y0))))
           #f)
        (1 (cond
            ((is (distance x0 y0 x y) <= vicinity)
             (set! suppressed-presses 2)
             #f)
            (else
             (let ((x0- x0)
                   (y0- y0))
               (set! x0 x)
               (set! y0 y)
               (target:tap! finger x0- y0-)))))))

    (define (release! x::real y::real time-ms::real)::boolean
      (set! timeout (timeout:cancel))
      (match suppressed-presses
        (0 (target:release! finger x y vx vy))
        (1 (set! timeout
                 (run:after
                  double-tap-timeout-ms
                  (lambda ()
                    (set! suppressed-presses 0)
                    (target:tap! finger x0 y0))))
           #f)
        (2 (set! suppressed-presses 0)
           (target:double-tap! finger x y))))

    #;(assert (is finger < (length last-known-pointer-position)))
    )

#+END_SRC

**** The ~Painter~ interface

GRASP is designed to work in a variety of environments,
spanning from high-fidelity vector graphics output
to simple text rendering.

These environments provide very different rendering
capabilities and complexity of programming interfaces.

One of the purposes of GRASP is to provide an interface
that may not have a particularly high fidelity, but that
is easy to use and covers the most common cases.

The definition of the ~Painter~ interface provided here is
probably very far from perfect, and should not be thought of
as engraved in stone. It is perhaps most convenient to think
of the ~Painter~ as a whimsical artist who wears a fancy hat
and long shawl and pretends to know French.

A lot of complication of the ~Painter~ interface stems from
the fact that it's designd to support not only rich visual
environments/graphics APIs, but also character terminals.

By necessity, the specificity of the operations provided by
~Painter~ is determined by the capabilities of terminals,
which, for example, make it easy to draw horizontal and
vertical lines, but drawing skewed lines of varying angles
cannot be done with comparable fidelity.

It is also impossible to draw scalable fonts, or to zoom and
rotate the content of the screen inside terminal. But we
don't want those deficiencies to limit the usability of the
GRASP clients that are capable of rendering scalable vector
graphics.

***** The rendering context

The origin of the coordinate system is the top left corner
of the screen (which agrees with the /textual order/ that is
employed for the code in GRASP). The origin can be shifted
using the ~with-translation~ method. All rendering is done
with respect to the origin, and for example text rendering
naturally flows to the right and downwards.

Likewise, it is possible (and often useful) to limit the
area that can be rendered to using the ~with-clip~
method. The coordinate system can also be uniformly scaled
using ~with-scale~, rotated using ~with-rotation~ and scaled
non-uniformly using ~with-stretch~.

It is also possible to decrease the intensity (opaqueness)
of the rendered fragment using ~with-intensity~, where 0.0
means no rendering, and 1.0 - fully opaque rendering.

***** Fonts and colors

Colors are represented using 32-bit RGBA scheme (red is the
most significant byte, while alpha, i.e. opaqueness is the
least significant byte).

The painter stores two colors in its state: the current
lead color, which is used for rendering font, but also
contours of shapes, and the current fill color, which
is used to fill shapes.

The graphical versions of GRASP are capable of rendering
TrueType fonts. The terminal version, in addition to being
able to render normal text, can also render FIGlet fonts.

In either case, the rendering is done so that the origin
is the top left corner of the text.

***** Rendering routines


#+BEGIN_SRC scheme :tangle editor/architecture.scm

;; Android, Desktop and Terminal/Text use different
;; representations of font. For this reason, we need
;; to coerce it to Object in the interface.
;;
;; The FontProxy object is meant to encode not only
;; the type face, but also its size.
(define-alias FontProxy java.lang.Object)

;; we are going to represent colors as 32-bit numbers
;; using the #xRRGGBBAA format, meaning that the most
;; significant byte is Red, and the least byte significant
;; - Alpha (transparency). So for example 0 is completely
;; trasparent "black", #x000000FF is opaque black,
;; and #xFFFFFFFF is opaque white.
;; 
(define-alias RGBA uint)

(define-type (Extent width: real height: real))

(define-enum LineDecoration (Thick Dashed))

(define-alias LineStyle (EnumSetOf LineDecoration))

(define-interface Painter ()

  (with-translation left ::real top ::real action ::(maps () to: ,a))::,a
  (with-rotation angle/radians ::real action ::(maps () to: ,a))::,a
  (with-clip width ::real height ::real action ::(maps () to: ,a))::,a
  (with-scale scale ::real action ::(maps () to: ,a))::,a
  (with-stretch rightward ::real downward ::real action ::(maps () to: ,a))::,a
  (with-intensity fraction ::real action ::(maps () to: ,a))::,a

  (play! animation::Animation)::void
  (playing? animation::Animation)::boolean
  (stop-playing! animation::Animation)::void

  (set-lead-color! color ::RGBA)::RGBA
  (current-lead-color)::RGBA

  (set-fill-color! color ::RGBA)::RGBA
  (current-fill-color)::RGBA

  (set-font! font ::FontProxy)::FontProxy
  (current-font)::FontProxy
  (draw-text! text ::java.lang.CharSequence)::Extent

  (set-line-style! style ::LineStyle)::LineStyle
  (current-line-style)::LineStyle
  (draw-line! x0 ::real y0 ::real x1 ::real y1 ::real)::void
  (draw-line-rightward! width ::real)::void
  (draw-line-downward! height ::real)::void

  (draw-rounded-rectangle! width ::real height ::real)::void
  (draw-rectangle! width ::real height ::real)::void

  )

#+END_SRC


**** The implementations of GRASP clients

***** The "textual" client

The code snippets from this chapter will be placed in the
~editor/text-painter.scm~ file.

A ~TextPainter~

#+BEGIN_SRC scheme :tangle editor/text-painter.scm :mkdirp yes :noweb yes
<<header>>
(module-name (editor text-painter))
(import (language extensions))
(import (editor architecture))

#+END_SRC

***** The terminal client

The code snippets from this chapter will be placed in the
~grasp-terminal.scm~ file.

#+BEGIN_SRC scheme :tangle grasp-terminal.scm :mkdirp yes :noweb yes
<<header>>
(module-name grasp-terminal)
(module-compile-options main: #t)

(import (language extensions))
(import (editor architecture))
(import (editor text-painter))

#+END_SRC
      
***** The desktop (AWT) client

The code snippets from this chapter will be placed in the
~grasp-awt.scm~ file.

#+BEGIN_SRC scheme :tangle grasp-awt.scm :mkdirp yes :noweb yes
<<header>>
(module-name grasp-awt)
(module-compile-options main: #t)

(import (language extensions))
(import (editor architecture))


#+END_SRC

***** The desktop (JavaFX) client

The code snippets from this chapter will be placed in the
~grasp-fx.scm~ file.

#+BEGIN_SRC scheme :tangle grasp-fx.scm :mkdirp yes :noweb yes
<<header>>
(module-name grasp-fx)
(module-compile-options main: #t)

(import (language extensions))
(import (editor architecture))


#+END_SRC


***** The Android client

The code snippets from this chapter will be placed in the
~grasp-android.scm~ file.

#+BEGIN_SRC scheme :tangle grasp-android.scm :mkdirp yes :noweb yes
<<header>>
(import (language extensions))
(import (editor architecture))

#+END_SRC

*** The editor

*** Document structure

As mentioned at the beginning, the primary representation of
documents in GRASP consists of /nested boxes/ that are
arranged in /textual order/.


The text representation of GRASP documents is based on the
syntax of Scheme. Therefore we need to be able to represent
the following syntactic components:
- lists (and dotted pairs)
- atoms (such as symbols and numbers)
- strings
- whitespace
- line comments
- block comments
- expression comments

Among those expressions, lists, atoms, strings, block
comments and expression comments have a rectangular shape,
so each of them is considered to be a ~Tile~.

Whitespace and line comments are closely related, and in
some sense irregular. 

#+BEGIN_SRC scheme :tangle editor/architecture.scm

(define-interface KeyboardNavigable ()
  ;; likewise, the above functions should return #true
  ;; only if the cursor has actually been moved
  (move-cursor-left!)::boolean
  (move-cursor-right!)::boolean
  (move-cursor-up!)::boolean
  (move-cursor-down!)::boolean)

(define-interface Undoable ()
  (undo!)::boolean
  (redo!)::boolean)

#|
(define-interface Selectable ()
  (expand-selection-left!)::boolean
  (expand-selection-right!)::boolean
  (expand-selection-up!)::boolean
  (expand-selection-down!)::boolean)
|#

#+END_SRC

*** Extensions

*** Combinators

** Building GRASP

*** Building the JVM clients

*** Building the Android client

* Emacs file-local variables

This section contains some variables that are used
internally by Emacs. They are not displayed in the rendered
view.  To learn more, see the [[https://www.gnu.org/software/emacs/manual/html_node/emacs/File-Variables.html][File Variables]] section of the
Emacs manual.

# Local variables:
# mode: org
# fill-column: 60
# indent-tabs-mode: nil
# End:
