* 16.10.2024

#+BEGIN_SRC scheme

  (define/kw (match-highlight pattern ::Indexable
			      at: cursor ::Cursor
			      in: document ::Indexable)
    ::(maybe Highlight)
    (let* ((pattern-index ::int 0)
	   (n ::int (length pattern))
	   (item-index (car cursor))
	   (context (cdr cursor)))
      (match n
	(0 (highlight-space
	    (pattern:part-at 0)
	    (document:part-at item-index)
	    cursor))
	(1 )
	(2 ...)
	(n ...))))

  (define (highlight-space pattern ::Space
			   subject ::Space
			   context ::Cursor)
    ::(maybe Highlight)
    (let ((n (count (isnt _ integer?) pattern:fragments)))
      (if (= n 0)
	 (Highlight start: (recons (subject:first-index)
				   context)
		    end: (recons (subject:last-index)
				 context)
		    type: HighlightType:OtherFinding)
	 (let ((m (count (isnt _ integer?) subject:fragments)))
	   (if (isnt m = n)
	       #!null
	       (match n
		 (1
		  ...)
		 (2
		  ...)
		 (n

		  ...)))))))


  (define (whitespace? space::Space)::boolean
    (every integer? space:fragments))

#+END_SRC

No dobra, to kilka uwag mamy:
1. 


* 15.10.2024

#+BEGIN_SRC scheme

  (define (textual-infix? infix-candidate ::Textual
			  subject ::Textual)
    ::(maybe `(,int . ,int))
    (escape-with return
      (let* ((n ::int (infix-candidate:text-length))
	     (m ::int (subject:text-length))
	     (d ::int (- m n)))
	(when (is n <= m) ;>
	  (for k from 0 below d
	       (escape-with continue
		 (for i from 0 below n
		      (when (isnt (infix-candidate:char-ref i)
				  eq? (subject:char-ref (+ i k)))
			(continue)))
		 (return `(,k . ,(+ k n))))))
	(return #!null))))

#+END_SRC

No to mamy sobie te nasze funkcje do dopasowywania
stringow: prefix-end, suffix-start, infix-start.

Jezeli chcemy znalezc dopasowanie, to:
- jezeli probujemy dopasowac pojedynczy element, to
  wolamy ~infix-start~
- jezeli probujemy dopasowac pierwszy element, to
  wolamy =suffix-start=
- jezeli probujemy dopasowac ostatni element, to
  wolamy =prefix-end=
- jezeli probujemy dopasowac srodkowe elementy,
  to wolamy ~textual=?~
  
No ale ogolnie, to zamysl jest taki, ze wczytujemy
pattern za pomoca funkcji =parse-string=

No dobra, to to juz mamy. I teraz co dalej?

Teraz musimy sprawdzic, czy nasz pattern pasuje
do naszego templejtu.

#+BEGIN_SRC scheme

  (define/kw (next-highlight pattern ::list
			     in: document ::Indexable
			     := (the-document)
			     after: cursor ::Cursor := (the-cursor)
			     context: context ::Cursor := '())
    ::(maybe Highlight)
    ... (match-highlight pattern at: (recons index context)
			 in: document) ...)


  (define/kw (match-highlight pattern ::Indexable
			      at: cursor ::Cursor
			      in: document ::Indexable)
    ::(maybe Highlight)
    (let ((pattern-index ::int 0)
	  (item-index (car cursor))
	  (context (cdr cursor)))
      ;; no dobra, to tutaj bedziemy sobie mieli kolejne
      ;; nowinki:  po pierwsze, musimy sprawdzic, czy
      ;; (document:part-at item-index) to spacja.
      ;; Ogolnie musimy rozwazyc takie przypadki:
      ;; 1. mamy w patternie tylko spacje
      ;;    - w takim przypadku wymagamy, zeby
      ;;     spacja sie znam zgadzala i jezeli spacja
      ;;     jest pusta, to zwracamy
      ;;     (Highlight start: (recons (subject:first-index) cusor)
      ;;                end: (recons (subject:last-index) cursor))


      ))

#+END_SRC

* 13-14.10.2024

#+BEGIN_SRC scheme
  ;; 1. szukamy piereszego i ostatniego fragmentu wzorca,
  ;;    ktory nie jest liczba
  ;; 2. jezeli takiego nie ma, to zwracamy
  ;;    `(,(subject:first-index) . ,(subject:last-index))
  ;; 3. w przeciwnym razie probujemy po kolei dopasowywac
  ;;    poszczegolne nie-liczby do kolejnych elementow
  ;;    patternu, az natrafimy na ostatni
  ;; 4. jezeli cokolwiek w kroku 3 sie nie powiedzie,
  ;;    zwracamy #!null
  ;; 5. w przeciwnym razie zwracamy zakres od poczatku
  ;;    pierwszego dopasowania do konca ostatniego dopasowania
  ;; (pytanie, czy w zwiazku z tym nie powinnismy raczej
  ;; zamiast pary liczb zwracac pare kursorow?)

  (define (match-space pattern ::Space subject ::Space)
    ::(maybe `(,number . ,number))
    (define (match-fragments pattern-fragments ::list
			     subject-fragments ::list)
      ::(maybe number)
      ...)

    (cond 
      ((every number? pattern:fragments)
      `(,(subject:first-index) . ,(subject:last-index)))

      ))


  (define/kw (match-highlight pattern ::list
			      at: index ::int
			      in: document ::Indexable
			      within: context ::Cursor)
    ::(maybe Highlight)
    ;; musimy sobie teraz wymyslic jak to powinno dzialac
    ;; ale chyba z grubsza tak, ze:
    ;; - musimy dopasowac pierwszy element w patternie,
    ;; i na tej podstawie wyznaczymy sobie Highlight:start
    ;; - muisimy tez dopasowac ostatni element w patternie,
    ;; i na tej podstawie mozemy sobie wyznaczyc Highlight:end
    ;; - wszystkie elementy pomiedzy pierwszym a ostatnim
    ;; elementem patternu powinny sie zgadzac
    ;; (czy rowniez powinnismy uwzgledniac spacje?)
    ;; 
    ;; No to moze zacznijmy od przypadku, w ktorym
    ;; (= (length pattern) 1), (car pattern) to atom/regex.
    ;; W takim przypadku sprawdzamy, czy
    ;; (document:part-at index) jest "textual", i probujemy
    ;; zmatchowac pattern za pomoca regex-match-positions.
    ;; Kiedy sie to nam uda, to zwracamy
    ;; (recons* start index context)
    ;; (recons* stop index context)
    ;; 
    ;; mamy jednak do rozwazenia jeszcze prostszy przypadek,
    ;; mianowicie gdy (= (length pattern) 0)  - bo w takim
    ;; przypadku wymagamy, zeby (document:part-at index)
    ;; to bylo Space, i zeby wowczas albo "pattern" byl
    ;; spacja, ktorej fragmenty to same liczby - i
    ;; wowczas jako dopasowanie zwrocimy (chyba?) cala
    ;; spacje, albo w przeciwnym razie szukamy spacji, ktora
    ;; zawiera sekwencje tekstu.


    ...)

#+END_SRC

no dobra, to w sumie sprawa jest ciezka, i moze trzeba by
bylo zaczac od napisania funkcji do matchowania tekstu:

#+BEGIN_SRC scheme

  (define (textual=? a ::Textual b ::Textual)::boolean
    (escape-with return
      (let ((n ::int (a:text-length)))
	(cond
	 ((= n (b:text-length))
	  (for i::int from 0 below n
	       (when (isnt (a:char-ref i) eq?
			   (b:char-ref i))
		 (return #false)))
	  (return #true))
	 (else
	  (return #false))))))

  (define (textual-prefix? prefix-candidate ::Textual
			   subject ::Textual)
    ::(maybe int)
    (escape-with return
      (let ((n ::int (prefix-candidate:text-length))
	    (m ::int (subject:text-length)))
	(cond
	 ((is n <= m) ;>
	  (for i::int from 0 below n
	       (when (isnt (prefix-candidate:char-ref i) eq?
			   (subject:char-ref i))
		 (return #!null)))
	  (return n))
	 (else
	  (return #!null))))))

  (define (textual-suffix? suffix-candidate ::Textual
			   subject ::Textual)
    ::(maybe int)
    (escape-with return
      (let* ((n ::int (suffix-candidate:text-length))
	     (m ::int (subject:text-length))
	     (d ::int (- m n)))
	(cond
	 ((is n <= m) ;>
	  (for i::int from 0 below n
	       (when (isnt (suffix-candidate:char-ref i) eq?
			   (subject:char-ref (+ i d)))
		 (return #!null)))
	  (return d))
	 (else
	  (return #!null))))))

#+END_SRC

* 11.10.2024

To bysmy przepisali funkcje next-match tak, zeby zamiast
predykatu pobierala liste patternow, i probowala
zmatchowac cala liste

#+BEGIN_SRC scheme
  (define/kw (next-match pattern ::list
			 in: document ::Indexable
			 := (the-document)
			 after: cursor ::Cursor := (the-cursor)
			 context: context ::Cursor := '())
    ::(maybe Highlight)
    (escape-with return
      (let* ((current-level ::int (length context))
	     (reference-level ::int (length cursor))
	     (pressure (- reference-level current-level 1))
	     (index (if (is pressure >= 0)
			(let ((initial-index (cursor
					      pressure)))
			  (if (= pressure 0)
			      (document:next-index
			       initial-index)
			      initial-index))
			(document:next-index
			 (document:first-index))))
	     (limit (document:last-index)))
	(while (isnt index eqv? limit)
	  (and-let* ((result ::Highlight (match-highlight
					  pattern
					  at: (recons index context)
					  in: document)))
	    (return result))
	  (when (gnu.lists.LList? item)
	    (let ((result (next-match pattern
				      in: item
				      after: cursor
				      context: (recons
						index
						context))))
	      (when result
		(return result)))))
	;; we skip by two indices to make sure that
	(set! index (document:next-index
		     (document:next-index index))))
      (return #!null)))

  (define/kw (match-highlight pattern ::list
			      at: index ::int
			      in: document ::Indexable
			      within: context ::Cursor)
    ::(maybe Highlight)
    ...)

#+END_SRC


* 10.10.2024

no dobra, mamy jakies prototypy funkcji maczujacych,
ale warto by bylo moze sobie takie funkcje napisac

w sumie to bysmy chcieli obsluzyc takie przypadki:
1. kiedy poszukiwany element jest lista
2. kiedy wyszukiwany element to po prostu ciag znakow
3. kiedy wyszukiwany element jest ciagiem elementow

Plan jest z grubsza taki, ze jak sobie mamy pole tekstowe,
to na jego zawartosci wywolujemy "read-all" (albo "parse"),
i teraz:
- jezeli w wyniku otrzymamy liste jednoelementowa,
5 to jezeli jedyny element jest atomem, to wyszukujemy
  teksty, ktore ow atom zawieraja (i mozemy wymyslic
  tu jakas skladnie wyrazen regularnych)
- jezeli jedyny element jest lista, to probujemy
  zmaczowac liste
- jezeli mamy liste wieloelementowa, to probujemy ja
  po prostu zmaczowac


Z tych rozwazan wylania sie taki obraz, ze tak alismy - pojedynczego
elementu),p


* 09.10.2024

Wydaje sie, ze warto by bylo podejsc do implementacji
z
,perspektywy przykladow.

Rzeczy, ktore bysmy chcieli lapac, to:
- caly atom
- fragment atomu (albo stringu, albo ewentualnie
  komentarza)
- kawalek listy
- cala liste

i teraz albo mozemy zrobic tak, ze zwracamy cala
dopasowana strukture, albo - ze zwracamy jakos
wyrazona dlugosc tej struktury.

Ta druga opcja wydaje sie nieco mniej kosztowna.

No dobra, czyli mamy sobie juz jeden kawalek funkcji
do wyszukiwania. Drugi kawalek, ktory bysmy chcieli znalezc,
to sama funkcja dopasowujaca.

I w sumie rzecz wydaje sie banalna:
- jezeli mamy atom, to szukamy pasujacego atomu
  (i zwracamy dlugosc dopasowania)
- jezeli mamy liste, to probujemy ja rekurencyjnie
  dopasowac, i jezeli sie to uda, zwracamy po prostu
  jej dlugosc

#+BEGIN_SRC scheme

  (define-type (Range start: int end: int))

  (define ((match-string s::string) item::Tile)::(maybe Range)
    ...)

  (define ((match-list l::list) item::Tile)::(maybe Range)
    ...)
  
  (define-type (Match position: Cursor
		      length: int))

  (define/kw (next-match satisfying ::(maps (Tile)
					    to: (maybe Range))
			 in: document ::Indexable
			 := (the-document)
			 after: cursor ::Cursor := (the-cursor)
			 context: context ::Cursor := '())
    ::(maybe Match)
    (escape-with return
      (let* ((current-level ::int (length context))
	     (reference-level ::int (length cursor))
	     (pressure (- reference-level current-level 1))
	     (index (if (is pressure >= 0)
			(let ((initial-index (cursor
					      pressure)))
			  (if (= pressure 0)
			      (document:next-index
			       initial-index)
			      initial-index))
			(document:next-index
			 (document:first-index))))
	     (limit (document:last-index)))
	(while (isnt index eqv? limit)
	  (let ((item (document:part-at index)))
	    (and-let* (((isnt item eq? document))
		       (range ::Range (satisfying item)))
	      (return (Match position: (recons index context)
			     length: value)))
	    (when (gnu.lists.LList? item)
	      (let ((result (next-match pattern
					in: item
					after: cursor
					context: (recons
						  index
						  context))))
		(when result
		  (return result)))))
	  (set! index (document:next-index index)))
	(return #!null))))

#+END_SRC


* 08.10.2024

Dobra, to na razie udalo sie podmienic stare funkcje
na nowe, ale to jeszcze za malo, zeby zaobserwowac
jakiekolwiek roznice w dzialaniu.

To teraz bysmy chcieli zintegrowac te nowa
funkcjonalnosc z mozliwoscia wyszukiwania.

No dobra, to co musimy zrobic?

- po pierwsze, zamiast/obok ~find-next~ dodac funkcje
  ~find-next-match~, ktora pobiera nie funkcje boole'owska,
  tylko funkcje zwracajaca (maybe list)
- po drugie, wyniki dzialania tej funkcji chcielibysmy
  zaisywac do obiektu (the-findings)
- po trzecie, obiekt (the-findings) chcielibysmy doklejac
  do wartosci zwracanej przez (the-highlights)
- po czwarte, chcielibysmy miec mozliwosc centrowania
  na kolejnych znalezionych wartosciach (ale to oczywiscie
  zrobimy w kolejnym etapie)
- po piate, chcielibysmy moc zamieniac znalezione wartosci
  na okreslone patterny (i tutaj sie raczej nie obejdzie
  bez evala)
- po szoste, jak ta funkcjonalnosc bedzie gotowa, to moze
  warto by bylo nagrac jutubowe demo pt.
  "GRASPing Indiana Dan's"

No dobra, ale na razie zastanowmy sie jeszcze moze nieco
nad tym, jak powinien wygladac ten nasz czarodzejski
interfejs do pattern-matchowania.

I otoz pejper "Macro by Example", ktory niedawno przypadkiem
sobie przeczytalismy, dekomponowal sobie patterny w nastepujacy
sposob:
- predykat, ktory mowi nam, czy dany pattern jest spelniony
- funkcje, ktora pobiera pattern i wyrazenie, i zwraca srodowisko
- funkcje, ktora pobiera srodowisko i pattern, i zwraca wyrazenie

I to sie wydaje piekne.

Natomiast u nas problem jest taki, ze chcemy sobie miec te kursory,
i chcemy wiedziec, jak duza porcje tekstu stanowi zmaczowany pattern.

#+BEGIN_SRC scheme

  (define-interface Template ()
    (captures? expression ::Expression)::boolean
    (bindings expression ::Expression)::Environment
    (substitution environment ::Environment)::Expression
    )
  
#+END_SRC

Czy cos takiego?

Nie wiadomo. Bo w zasadzie to jednym aspektem tego
procesu jest wiazanie zmiennych z wartosciami - i tutaj
w rezultacie moglibysmy dostawac jakies odwzorowanie.

Natomiast drugi aspekt jest taki, ze bedziemy konsumowac
jakis kawalek inputu, i fajnie by bylo wiedziec, jaki
kawalek inputu skonsumowalismy.

* 07.10.2024

No dobra, to mamy (niby)obsluzone podswietlanie
dla klienta desktopowego, ale chyba warto by bylo:
1. napisac analogiczny kod dla klienta androidowego
2. zastanowic sie nad klientem terminalowym
   
#+BEGIN_SRC scheme

  (define (draw-text! text::CharSequence
		      font::Font
		      context::Cursor)
    ::void
    (let* ((focused? (and (pair? (the-cursor))
			  (equal? context
				  (cdr (the-cursor)))))
	   (highlights (the-highlights))
	   (highlight-starts
	    ::(list-of Highlight)
	    (only (lambda (highlight::Highlight)
		    (and-let* ((`(,_ . ,,context)
				highlight:start))))
		  highlights))
	   (highlight-ends
	    ::(list-of Highlight)
	    (only (lambda (highlight::Highlight)
		    (and-let* ((`(,_ . ,,context)
				highlight:end))))
		  highlights))
	   (parent ::Traversal (the-traversal))
	   (height ::float font:size)
	   (traversal ::Traversal
		      (Traversal
		       max-line-height: height
		       parent-left: (+ parent:parent-left
				       parent:left)
		       parent-top: (+ parent:parent-top
				      parent:top)
		       parent: parent))	     
	   (segment-start 0)
	   (string-end (text:length)))
      (parameterize ((the-cursor-extent
		      (Extent width: 2
			      height: height))
		     (the-traversal traversal))
	(define (render-fragment! segment-end::int)
	  (let* ((fragment (text:subSequence
			    segment-start
			    segment-end))
		 (width (text-width fragment font)))
	    (set-color! background-color)
	    (canvas:drawRect traversal:left traversal:top
			     (+ traversal:left width)
			     (+ traversal:top height)
			     paint)
	    (set-color! text-color)
	    (canvas:drawText fragment traversal:left
			     (+ traversal:top height)
			     paint)
	    (traversal:expand-by! width)))

	(paint:setTypeface font:face)
	(paint:setTextSize font:size)
	(for i from 0 below string-end
	     (when (and focused? (eqv? (head (the-cursor))
				       i))
	       (render-fragment! i)
	       (set! segment-start i)
	       (mark-cursor! traversal:left traversal:top))

	     (when (any (is (car _:start) eqv? i)
			highlight-starts)
	       (render-fragment! i)
	       (set! segment-start i)
	       (for highlight::Highlight in highligh-starts
		 (when (eqv? (car highlight:start) i)
		   (begin-highlight! highlight:type))))

	     (when (any (is (car _:end) eqv? i)
			highlight-ends)
	       (render-fragment! i)
	       (set! segment-start i)
	       (for highlight::Highlight in highligh-starts
		 (when (eqv? (car highlight:end) i)
		   (end-highlight! highlight:type))))

	     (when (eq? (text:charAt i) #\newline)
	       (render-fragment! i)
	       (traversal:on-end-line #t)
	       (traversal:new-line!)
	       (set! traversal:max-line-height height)
	       (set! segment-start (+ i 1))))
	(render-fragment! string-end)
	(when (and focused? (eqv? (head (the-cursor))
				  string-end))
	  (mark-cursor! traversal:left traversal:top))
	(traversal:on-end-line #f))))

#+END_SRC

No dobra, to sie wydaje, ze wariant dla Androida juz mamy,
i teraz wypadaloby sie zastanowic nad klientem tekstowym
i terminalowym.

No dobra, to widzimy, ze w kliencie tekstowym
znajdziemy 7 uzyc:
- ~draw-custom-box!~
- ~draw-quote-markers!~
- ~draw-quasiquote-markers!~
- ~draw-unquote-markers!~
- ~draw-unquote-splicing-box!~
- ~draw-unquote-splicing-markers!~
- ~draw-string!~

Pierwsze pytanie byloby zatem takie,
czy nie moglibysmy w jakis sposob uogolnic
rysowania tych quote'ow?

Pewnie bysmy mogli. Ale komu by sie chcialo.

(Moze komus sie kiedys bedzie chcialo, ale na pewno
nie mnie i nie teraz).

To zaczniemy moze od poprawy tej funkcji
~draw-string!~.

#+BEGIN_SRC scheme
  (define (draw-string! text::CharSequence
			context::Cursor)
    ::void
    (let* ((focused?
	  (and (pair? (the-cursor))
	       (equal? context
		       (cdr (the-cursor)))))
	   (parent (the-traversal))
	   (highlights (the-highlights))
	   (highlight-starts
	    ::(list-of Highlight)
	    (only (lambda (highlight::Highlight)
		    (and-let* ((`(,_ . ,,context)
				highlight:start))))
		  highlights))
	   (highlight-ends
	    ::(list-of Highlight)
	    (only (lambda (highlight::Highlight)
		    (and-let* ((`(,_ . ,,context)
				highlight:end))))
		  highlights))
	   (traversal ::Traversal
		      (Traversal
		       max-line-height: 1
		       parent-left: (+ parent:parent-left
				       parent:left)
		       parent-top: (+ parent:parent-top
				      parent:top)
		       parent: parent)))

      (define (handle-cursor-and-selection!)
	(for highlight::Highlight in highligh-starts
	  (when (eqv? (car highlight:start)
		      traversal:index)
	    (begin-highlight! highlight:type)))
	(for highlight::Highlight in highligh-starts
	  (when (eqv? (car highlight:end)
		      traversal:index)
	    (end-highlight! highlight:type)))
	(when (and focused? (eqv? traversal:index
				  (car (the-cursor))))
	  (mark-cursor! traversal:left traversal:top)))

      (parameterize ((the-traversal traversal))
	(for c in text
	  (handle-cursor-and-selection!)
	  (cond ((eq? c #\newline)
		 (traversal:on-end-line #t)
		 (traversal:new-line!)
		 (set! traversal:max-line-height 1))
		((eq? c #\return)
		 ;; this seems to solve a bug on Windows/WSL1
		 (set! traversal:index
		       (- traversal:index 1)))
		;; jeszcze chcemy combining-character
		;; po prostu dopisac do biezacego znaku
		(else
		 (put! c traversal:top traversal:left)
		 (traversal:expand-by! 1)))
	  (set! traversal:index (+ traversal:index 1)))
	(handle-cursor-and-selection!)
	(traversal:on-end-line #f))))

#+END_SRC

* 06.10.2024 (komputer, ale i pociag)

No to pierwszy pomysl jest taki, zeby sprobowac przekopiowac
te zmiany, ktore ostatnio napisalismy, do pliku grasp-desktop.scm,
oraz - z odpowiednimi modyfikacjami - do grasp-android.scm.

Natomiast natychmiast rodzi to pytanie, co zrobic z klientem
terminalowym.

Zreszta w sumie nie musimy sie z tym wszystkim az tak spieszyc,
bo teraz mamy przed soba caly tydzien nie-commitowania.

A moze warto by bylo poczynic troche refleksji zwiazanej
z konferencja.

Wydaje sie, ze odbior mojej prezentacji byl bardzo dobry,
ale rowniez ze zainteresowanie samym narzedniem bylo spore.

Ogonie wydaje sie, ze to wydarzenie bylo doskonale pod tym
wzgledem, ze jednoczy rozmaitych freakow, ktorzy po pierwsze
byliby sklonni sprobowac GRASPa, gdyby ich przycisnac,
a po drugie sami sa tworcami narzedzi, i potencjalnie mogliby
owo narzedzie wspoltworzyc.

Stad tez wydaje sie, ze kolejne takie wydarzenie mogloby
byc dobra okazja do zaprezentowania juz w pelni sprawnej
wersji GRASPa (przy czym moze okreslenie "w pelni sprawniej"
nie jest do konca zrozumiale - moze lepiej by bylo po prostu
powiedziec "uzywalnej").

Stad tytul kolejnej prezentacji: "Grazing GRASP", w ktorej
chcielibysmy przedstawic:
- dzialajacy algorytm A*
- dzialajaca przegladarke modulow

Dodatkowo chcielibysmy byc w stanie budowac GRASPa z GRASPa,
miec wyszukiwanie/zastepowanie, suwaki do scrollowania,
nie miec bledow w edycji, miec "wyciaganie obrusa".

Pytanie, czy jestesmy w stanie osiagnac takie cos jeszcze
w tym roku?

Zostalo nam na to 12 tygodni, z czego chyba 4 intensywniejsze.

Czy taki plan mialby sens?
1. skonczyc to wyszukiwanie i zamienianie (zalozmy, ze 2 tygodnie)
2. zajac sie bledami w edycji i ruszaniu kursorem (zalozmy, ze
   4 tygodnie)
3. ????

* 04.10.2024

Dzisiaj Causal Islands, sie za bardzo narobilem.

* 03.10.2024

to plan na dzisiaj jest taki, zeby:
- zrobic slajdy
- przepisac ponizsza funkcje tak, zeby
  zamiast na (the-selection) dzialala
  na (the-highlights)
- zaimplementowac (the-highlights)

#+BEGIN_SRC scheme

  (define (draw-text! text::CharSequence
		      font::Font
		      context::Cursor)
    ::void
    (let* ((focused? (and (pair? (the-cursor))
			  (equal? context
				  (cdr (the-cursor)))))
	   (highlights (the-highlights))
	   (highlight-starts
	    ::(list-of Highlight)
	    (only (lambda (highlight::Highlight)
		    (and-let* ((`(,_ . ,,context)
				highlight:start))))
		  highlights))
	   (highlight-ends
	    ::(list-of Highlight)
	    (only (lambda (highlight::Highlight)
		    (and-let* ((`(,_ . ,,context)
				highlight:end))))
		  highlights))
	   (metrics ::FontMetrics
		    (graphics:getFontMetrics font))
	   (parent ::Traversal (the-traversal))
	   (height ::float (metrics:getHeight))
	   (traversal ::Traversal
		      (Traversal
		       max-line-height: height
		       parent-left: (+ parent:parent-left
				       parent:left)
		       parent-top: (+ parent:parent-top
				      parent:top)
		       parent: parent))	     
	   (segment-start 0)
	   (string-end (text:length)))
      (parameterize ((the-cursor-extent
		      (Extent width: 2
			      height: height))
		     (the-traversal traversal))
	(define (render-fragment! segment-end::int)
	  (let* ((fragment (text:subSequence
			    segment-start
			    segment-end))
		 (width (metrics:stringWidth fragment)))
	    (set-color! background-color)
	    (graphics:fillRect traversal:left
			       traversal:top
			       width height)
	    (set-color! text-color)
	    (graphics:drawString fragment
				 (as float
				     traversal:left)
				 (as float
				     (+ traversal:top
					height)))
	    (traversal:expand-by! width)))

	(graphics:setFont font)
	(for i from 0 below string-end
	     (when (and focused? (eqv? (head (the-cursor)) i))
	       (render-fragment! i)
	       (set! segment-start i)
	       (mark-cursor! traversal:left traversal:top))

	     (when (any (is (car _:start) eqv? i)
			highlight-starts)
	       (render-fragment! i)
	       (set! segment-start i)
	       (for highlight::Highlight in highligh-starts
		 (when (eqv? (car highlight:start) i)
		   (begin-highlight! highlight:type))))

	     (when (any (is (car _:end) eqv? i)
			highlight-ends)
	       (render-fragment! i)
	       (set! segment-start i)
	       (for highlight::Highlight in highligh-starts
		 (when (eqv? (car highlight:end) i)
		   (end-highlight! highlight:type))))

	     (when (eq? (text:charAt i) #\newline)
	       (render-fragment! i)
	       (traversal:on-end-line #t)
	       (traversal:new-line!)
	       (set! traversal:max-line-height height)
	       (set! segment-start (+ i 1))))
	(render-fragment! string-end)
	(when (and focused? (eqv? (head (the-cursor))
				  string-end))
	  (mark-cursor! traversal:left traversal:top))
	(traversal:on-end-line #f))))

  (define (the-highlights)::(list-of Highlight)
    (let-values (((selection-start selection-end)
		  (the-selection)))
      `(,(Highlight start: selection-start
		    end: selection-end
		    type: HighlightType:Selection))))

#+END_SRC


* 30.09-02.10.2024

To dzisiaj tak:
- zrobic slajdy, a przynajmniej zebrac zdjecia
- zaimplementowac kolorowanie wieloma rodzajami
  podswietlen na raz:
  - Selection - odwrocony kolor tekstu
  - CurrentFinding - pomaranczowy (czerwony + zolty)
  - OtherFinding - zolty
  - LikeTarget (tylko dla atomow)
    - w klientach graficznych troche ciemniejszy
    - w kliencie terminalowym troche jasniejszy
      albo pogrubiony

#+BEGIN_SRC scheme
  (define (draw-text! text::CharSequence
		      font::Font
		      context::Cursor)
    ::void
    (let-values (((selection-start selection-end)
		  (the-selection)))
w      (let* ((focused? (and (pair? (the-cursor))
			    (equal? context
				    (cdr (the-cursor)))))
	     (enters-selection-drawing-mode?
	      (and (pair? selection-start)
		   (equal? (tail selection-start)
			   context)))
	     (exits-selection-drawing-mode?
	      (and (pair? selection-end)
		   (equal? (tail selection-end) context)))
	     (metrics ::FontMetrics
		      (graphics:getFontMetrics font))
	     (parent ::Traversal (the-traversal))
	     (height ::float (metrics:getHeight))
	     (traversal ::Traversal
		       (Traversal
			max-line-height: height
			parent-left: (+ parent:parent-left
					parent:left)
			parent-top: (+ parent:parent-top
				       parent:top)
			parent: parent))	     
	     (segment-start 0)
	     (string-end (text:length)))
	(parameterize ((the-cursor-extent
			(Extent width: 2
				height: height))
		       (the-traversal traversal))
	  (define (render-fragment! segment-end::int)
	    (let* ((fragment (text:subSequence
			      segment-start
			      segment-end))
		   (width (metrics:stringWidth fragment)))
	      (set-color! background-color)
	      (graphics:fillRect traversal:left
				 traversal:top
				 width height)
	      (set-color! text-color)
	      (graphics:drawString fragment
				   (as float
				       traversal:left)
				   (as float
				       (+ traversal:top
					  height)))
	      (traversal:expand-by! width)))

	  (graphics:setFont font)
	  (for i from 0 below string-end
	       (when (and focused? (eqv? (head (the-cursor)) i))
		 (render-fragment! i)
		 (set! segment-start i)
		 (mark-cursor! traversal:left traversal:top))

	       (when (and enters-selection-drawing-mode?
			  (eqv? (head selection-start) i))
		 (render-fragment! i)
		 (set! segment-start i)
		 (begin-highlight! HighlightType:Selection))

	       (when (and exits-selection-drawing-mode?
			  (eqv? (head selection-end) i))
		 (render-fragment! i)
		 (set! segment-start i)
		 (end-highlight! HighlightType:Selection))

	       (when (eq? (text:charAt i) #\newline)
		 (render-fragment! i)
		 (traversal:on-end-line #t)
		 (traversal:new-line!)
		 (set! traversal:max-line-height height)
		 (set! segment-start (+ i 1))))
	  (render-fragment! string-end)
	  (when (and focused? (eqv? (head (the-cursor))
				    string-end))
	    (mark-cursor! traversal:left traversal:top))
	  (traversal:on-end-line #f)))))
#+END_SRC

No to mamy sobie takie cudo. I co?

Ogolnie ten algorytm dziala tak, ze najpierw wyliczamy
selekcje, ktora ma postac:
~(kursor-poczatkowy, kurso-koncowy)~,

Nastepnie okreslamy, czy biezacy tekst jest wprowadzany
w tryb rysowania selekcji, albo wyprowadzany z tego
trybu, poprzez porownanie przyrownanie lodygi kursora
poczatkowego i koncowego do aktualnego kontekstu.

I wowczas iterujemy po stringu znak po znaku,
i po kazdym znaku sprawdzamy, czy dochodzi do zmiany
trybu - a jesli tak, wywolujemy stosowna metode
paintera.

No i teraz tak: zamiast jednego kursora poczatkowego
i jednego kursora koncowego mielibysmy liste kursorow
poczatkowych i koncowych

Zamiast ~(the-selection)~ bysmy mieli funkcje
~(the-highlights)~, ktora zwracalaby liste elementow
typu Highlight. I sposrod nich szukalibysmy takich,
ktorych start mialby taki sam suffix, jak biezacy
kontekst, oraz takich, ktorych end mialby taki sam suffix.


* 29.09.2024

Po drodze pojawil sie jeszcze taki pomysl, zeby
stworzyc w paintingu alias na java.lang.Object
jako FontImplementation, dzieli czemu moglibysmy
usunac nieco boilerplate'u.

Ale to co najwyzej zrobimy w przyszlosci, a tymczasem
bysmy sie zajeli usunieciem z paintera 
~enter/exit-selection-drawing-mode!~

OK, to teraz nalezaloby:

1. zmodyfikowac implementacje nowych funkcji
(we wszystkich implementacjach paitnera) tak, zeby
obslugiwaly wszystkie typy podswietlen

2. zmodyfikowac uzycia tych funkcji, tak zeby mogly
przyjmowac potencjalnie wiele elementow typu Highlight
(tzn. konkretnie chodzi tutaj przede wszystkim o funkcje
"draw-text!" w klientach graficznych, oraz draw-string!
i te zwiazane z quasiquote'ami w klientach tekstowych)

3. zintegrowac wyszukiwanie z wyswietlaniem, w takim sensie,
ze jak sie cos wpisze w pole tekstowe, to bysmy chcieli,
zeby po pierwsze znaleziony pattern byl podswietlany,
a po drugie zeby dalo sie poruszac kamera pomiedzy nastepnym
i poprzednim.

No ale tak ogolniej, to wyglada na to, ze mamy taki grafik:
- poniedzialek (jutro) - commit na wtorek + slajdy?, faktura
- wtorek - Piti do weta - commit na srode, Pola na kokardki
- sroda - basen + wystep Poli u babci + wyjazd do rodzicow (spakowac sie!)
- czwartek - pociagiem do Berlina, duzo czasu na commity
- piatek - prezentacja
- sobota - konferencja
- niedziela - powrot



* 28.09.2024

No to teraz plan jest taki:
1. dodac enuma Highlight do modulu painting
2. przerobic ~enter/exit-selection-drawing-mode!~
   na ~begin/end-highlight!~
3. zmodyfikowac interfejs funkcji tak, zeby
   mogl przyjmowac wiele rodzajow podswietlen
   (i tutaj trzeba jeszcze sporo przemyslec)
4. zmodyfikowac definicje funkcji tak, zeby
   zamiast jednego podswietlenia przyjmowal
   wiele podswietlen
5. zintegrowac wyswietlanie z wynikami
   wyszukiwania
   - w szczegolnosci, nasza funkcja powinna
     zamiast kursorow zwracac pary kursorow


a w szerszej perspektywie:
- wyszukiwanie
- serializacja zmian
- wszystkie funkcje do edycji dokumentow
  (zamknij, nowy)

* 27.09.2024

Garsc wnioskow ze wczorajszej analizy:
1. na pewno chcemy przeksztalcic
   ~enter-selection-drawing-mode!~
   oraz
   ~exit-selection-drawing-mode!~
   w cos innego,
   na przyklad
   ~begin-highlight! mode~
   oraz
   ~end-highlight! mode~

2. w tej chwili selekcja w terminalu dziala tak,
   ze odwraca kolor tla i kolor tekstu, natomiast
   selekcja w klientach graficznych ustawia
   okreslone kolory

3. byc moze "mode" powinien byc jednym z elementow
   skonczonego zbioru (enuma?)

   Ale jakie uzycia przychodza nam do glowy?
   Moze na przyklad: Highlight
   Selection - odwrocenie tekstu i tla
   CurrentFinding - pomaranczowy
   OtherFinding - zolty
   LikeTarget

   MarkerOrange
   MarkerPink
   MarkerGreen
   MarkerRed
   MarkerBlue

   Mo dobra. Na razie zrobmy

#+BEGIN_SRC scheme

  (define-enum Highlight
    (Selection
     CurrentFinding
     OtherFinding
     #;LikeTarget))

#+END_SRC

To bysmy sprobowali wymyslic (jutro albo pojutrze)
jak zaimplementowac nowe metody w painterze i usunac
stare.

* 26.09.2024

No dobra, to wyglada na to, ze chcemy chyba
ogolnie przyjac nieco inna strategie obslugi
podswietlania: chcielibysmy miec cos w rodzaju

#+BEGIN_SRC scheme
(define-type (Highlight start: Cursor end: Cursor color: uint))
#+END_SRC

i miec sobie sekwencje

#+BEGIN_SRC scheme
(define-parameter (the-highlights) ::(sequence-of Highlight) '())
#+END_SRC

I tak jak mamy sobie

#+BEGIN_SRC scheme
  (define (draw-text! text::CharSequence
		      font::Font
		      context::Cursor)
    ::void
    (let-values (((selection-start selection-end) (the-selection)))
      (let* ((focused? (and (pair? (the-cursor))
			    (equal? context (cdr (the-cursor)))))
	     (enters-selection-drawing-mode?
	      (and (pair? selection-start)
		   (equal? (tail selection-start) context)))
	     (exits-selection-drawing-mode?
	      (and (pair? selection-end)
		   (equal? (tail selection-end) context)))
	     (metrics ::FontMetrics (graphics:getFontMetrics font))
	     (parent ::Traversal (the-traversal))
	     (height ::float (metrics:getHeight))
	     (traversal ::Traversal
		       (Traversal
			max-line-height: height
			parent-left: (+ parent:parent-left
					parent:left)
			parent-top: (+ parent:parent-top
				       parent:top)
			parent: parent))	     
	     (segment-start 0)
	     (string-end (text:length)))
	(parameterize ((the-cursor-extent (Extent width: 2
						  height: height))
		       (the-traversal traversal))
	  (define (render-fragment! segment-end::int)
	    (let* ((fragment (text:subSequence segment-start
					       segment-end))
		   (width (metrics:stringWidth fragment)))
	      (set-color! background-color)
	      (graphics:fillRect traversal:left traversal:top
				 width height)
	      (set-color! text-color)
	      (graphics:drawString fragment (as float traversal:left)
				   (as float (+ traversal:top height)))
	      (traversal:expand-by! width)))

	  (graphics:setFont font)
	  (for i from 0 below string-end
	       (when (and focused? (eqv? (head (the-cursor)) i))
		 (render-fragment! i)
		 (set! segment-start i)
		 (mark-cursor! traversal:left traversal:top))

	       (when (and enters-selection-drawing-mode?
			  (eqv? (head selection-start) i))
		 (render-fragment! i)
		 (set! segment-start i)
		 (enter-selection-drawing-mode!))

	       (when (and exits-selection-drawing-mode?
			  (eqv? (head selection-end) i))
		 (render-fragment! i)
		 (set! segment-start i)
		 (exit-selection-drawing-mode!))

	       (when (eq? (text:charAt i) #\newline)
		 (render-fragment! i)
		 (traversal:on-end-line #t)
		 (traversal:new-line!)
		 (set! traversal:max-line-height height)
		 (set! segment-start (+ i 1))))
	  (render-fragment! string-end)
	  (when (and focused? (eqv? (head (the-cursor)) string-end))
	    (mark-cursor! traversal:left traversal:top))
	  (traversal:on-end-line #f)))))
#+END_SRC

albo

#+BEGIN_SRC scheme
  (define (draw-string! text::CharSequence
			context::Cursor)
    ::void
    (let-values (((selection-start selection-end)
		  (the-selection))
		 ((parent) (the-traversal)))
      (let ((focused?
	     (and (pair? (the-cursor))
		  (equal? context
			  (cdr (the-cursor)))))
	    (enters-selection-drawing-mode?
	     (and (pair? selection-start)
		  (equal? (tail selection-start)
			  context)))
	    (exits-selection-drawing-mode?
	     (and (pair? selection-end)
		  (equal?
		   (tail selection-end)
		   context)))
	    (traversal ::Traversal
		       (Traversal
			max-line-height: 1
			parent-left: (+ parent:parent-left
					parent:left)
			parent-top: (+ parent:parent-top
				       parent:top)
			parent: parent)))

	(define (handle-cursor-and-selection!)
	  (when (and enters-selection-drawing-mode?
		     (eqv? traversal:index (head selection-start)))
	    (enter-selection-drawing-mode!))
	  (when (and exits-selection-drawing-mode?
		     (eqv? traversal:index (head selection-end)))
	    (exit-selection-drawing-mode!))
	  (when (and focused? (eqv? traversal:index (car (the-cursor))))
	    (mark-cursor! traversal:left traversal:top)))

	(parameterize ((the-traversal traversal))
	  (for c in text
	    (handle-cursor-and-selection!)
            (cond ((eq? c #\newline)
		   (traversal:on-end-line #t)
		   (traversal:new-line!)
		   (set! traversal:max-line-height 1))
		  ((eq? c #\return)
		   ;; this seems to solve a bug on Windows/WSL1
		   (set! traversal:index (- traversal:index 1)))
		  ;; jeszcze chcemy combining-character
		  ;; po prostu dopisac do biezacego znaku
		  (else
		   (put! c traversal:top traversal:left)
		   (traversal:expand-by! 1)))
	    (set! traversal:index (+ traversal:index 1)))
	  (handle-cursor-and-selection!)
	  (traversal:on-end-line #f)))))
#+END_SRC

to chcielibysmy zamiast tego sprawdzac, czy sa jakies highlighty, ktore
stosuja sie do naszego fragmentu.

Poniewaz teraz bedziemy mogli miec kilka kolorow na raz, musimy przemyslec
jakas strategie blenowania ich.

Na razie w kliencie terminalowym mamy obsuge kolorow tak zrobiona

#+BEGIN_SRC scheme
  (define (enter-selection-drawing-mode!)::void
    (invoke-special CharPainter (this)
		    'enter-selection-drawing-mode!)
    (let ((text-color (the-text-color)))
      (set! (the-text-color) (the-background-color))
      (set! (the-background-color) text-color)))

  (define (exit-selection-drawing-mode!)::void
    (let ((text-color (the-text-color)))
      (set! (the-text-color) (the-background-color))
      (set! (the-background-color) text-color))
    (invoke-special CharPainter (this)
		    'exit-selection-drawing-mode!))
#+END_SRC

a w kliencie graficznym tak:

#+BEGIN_SRC scheme
  (define (enter-selection-drawing-mode!)::void
    (set! selection-drawing-mode? #t)
    (set! text-color #xffffffff)
    (set! background-color #xff555555))

  (define (exit-selection-drawing-mode!)::void
    (set! selection-drawing-mode? #f)
    (set! text-color #xff555555)
    (set! background-color transparent))
#+END_SRC


* 25.09.2024

Ogolnie wydaje sie, ze z kwestia obslugi klawiszy
nie ma tragedii - po prostu mielismy buga.

Buga mamy chyba tez w obsludze dotykania, i nim
rowniez byloby dobrze sie zajac

Ale na razie skupiamy sie na wyszukiwaniu.

To co musi sie wydarzyc, zeby ctrl+f powodowalo
wyszukanie kolejnego elementu?

Tzn. ogolnie jak wciskamy ctrl+f, to bysmy chcieli, zeby
podswietlily sie nam wszystkie wystapienia wyszukiwanego
patternu. Czyli musimy jakos zmodyfikowac wyswietlanie,
zeby uwzglednialo liste indeksow.

No i teraz pytanie, jak chcemy to zrobic?

W kliencie androidowym i desktopowym mamy

#+BEGIN_SRC scheme
  (define (draw-text! text::CharSequence
		      font::Font
		      context::Cursor)
    ...)
#+END_SRC

#+BEGIN_SRC scheme
  (define (draw-string! text::CharSequence
			context::Cursor)
    ::void
    ...)
#+END_SRC

Obie te funkcje charakteryzuja sie tym, ze pobieraja
selekcje z funkcji ~(the-selection)~, ktora zwraca
pare kursorow.

Mamy tez funkcje, ktora sobie niedawno napisalismy,
ktora zwraca nam wszystkie indeksy, pod ktorymi elementy
spelniaja okreslony predykat.

I teraz rzeczy do zrobienia mamy zasadniczo dwie:
po pierwsze, w jakis sposob skonstruowac predykat
ze stringa.

Po drugie, chcielibysmy okreslic, w ktorym miejscu
nasz indeks powinien sie konczyc.

Gdybysmy to mieli, mozemy sobie wyobrazic, ze
bysmy mogli miec funkcje (the-findings), zwracajaca
liste par postaci (finding-start . finding-end).

Dodatkowo bysmy chcieli miec w painterze metody
"enter-finding-drawing-mode!" oraz "exit-finding-drawing-mode!".

Czyli na razie najwieksza trudnosc tkwi w tym, jak
okreslic dlugosc naszego matcha - i to na tym powinnismy
sie skupic.

* 24.09.2024

To dzisiaj bysmy zaczeli od okienka z polem tekstowym do
wpisywania tekstu do wyszukiwania

w takim sensie, ze wciskamy ctrl+f, i wtedy pojawia sie
okienko przypisane do aktualnego editora.

Aha no i wlasnie. Warto zastanowic sie od razu nad kwestia
obslugi klawiszy. W takim sensie, ze mamy aktualnie globalna
tablice klawiszy, natomiast docelowo raczej chcielibysmy
miec hierarchiczna obsluge, tzn. wszystkie klawisze, ktorych
nie obsluzylismy, przekazujemy do edytora, i edytor przekazuje
je do widgetu itd.

Byc moze nawet bedzie to trzeba zrobic szybciej niz pozniej,
bo juz teraz widzimy, ze jest problem z kasowaniem zawartosci
pola tekstowego i poruszaniem strzalkami.

No dobra, to jak ten system powinien dzialac?

Chyba najpierw musimy opisac, jak dziala teraz. Na potrzeby
analizy rozwazmybklienta Androidowego.

Mamy takie cos:

#+BEGIN_SRC scheme
  ;; grasp-android.scm
  (define (onKeyDown keyCode::int event::KeyEvent)::boolean
    (safely
     (parameterize ((unicode-input #;< (integer->char
				    (event:getUnicodeChar))))
       (invalidating
	(screen:key-typed!
	 (as long
	     (bitwise-ior
	      (as long keyCode)
	      (if (event:ctrl-pressed?) CTRL_MASK 0)
	      (if (event:alt-pressed?) ALT_MASK 0)
	      (if (event:shift-pressed?) SHIFT_MASK 0)
	      ))
	 '())))))

  ;; screen.scm
  (define (key-typed! key-code::long context::Cursor)::boolean
    (assert (empty? context))
    (if (and (is top Maximizable?)
	     (is (key-code-name key-code) in '(escape back)))
	(screen:unmaximize!)
	(parameterize ((the-pane-width size:width)
		       (the-pane-height size:height))
	  (or (overlay:key-typed! key-code context)
	      (top:key-typed! key-code context)))))

  ;; document-editor
  (define (key-typed! key-code::long context::Cursor)::boolean
    (with-post-transform transform
      (with-view-edges-transformed transform
	(parameterize/update-sources ((the-document document)
				      (the-cursor cursor)
				      (the-editor (this))
				      (the-selection-range
				       selection-range))
	  ((keymap key-code))
	  #t))))

#+END_SRC

* 23.09.2024

Na razie mamy implementacje funkcji wymiarujacych dla klienta
androidowego, i teraz zostal nam klient desktopowy (choc juz teraz
mamy sygnaly, ze cos nie do konca pyka, i trzeba bedzie odczytac stack
trace'a na na komputerze)

Dobra, klient desktopowy juz obsluzony. W kazdym razie tak sie nam
wydaje. Teraz zas bysmy chcieli miec takie zachowanie:

1. jak wciskamy ctrl+f, to nam sie pojawia okenko z polem tekstowym
2. jak cos wpisujemy w to okienko, to sie podswietlaja wszystkie
   znalezione uzycia tego patternu
3. jak naciskamy ctrl+f, to nawiguje nas do kolejnego znalezionego
   uzycia

* 22.09.2024

teraz musimy napisac funkcje wymiarujace pozycje kursora
w obrebie tekstu dla klientow graficznych, zeby znowu
zaczely dzialac.

Jednak zamiast od razu rozwiazywac problem,
lepiej zastanowmy sie, jakie funkcjonalnosci
by sie nam przydaly do rozwiazania go.

Chcielibysmy miec 'widok planistyczny',
w ktorym bysmy sobie pisali z grubsza to,
co piszemy w tym README, ale dodatkowo
bysmy chcieli moc wskazywac na lokalizacje
w poszczegolnych modulach.

I tak bysmy sobie wskazali na:
- koncowke modulu ~(editor interfaces painting)~
- metody w ~(editor text-painter)~

* 21.09.2024

Wydaje sie, ze mamy juz jakos-tam zaimplementowane
measure position dla cons, Space i Atom. Teraz bysmy
sobie sprobowali zaimplementowac to dla quote'ow
oraz dla rzeczy tekstowych, a na koniec dla kombinatorow
i czarodziejstw.

* 20.09.2024

No dobra, to mamy juz jakis zalazek naszej funkcji do pomiaru
pozycji kursora.

Teraz czeka nas nieco wieksze zadanie, bo musimy dodac funkcje
"measure-position" do wszystkich implementacji interfejsu
Element. Zasadniczo wiemy, jak to robic dla spacji. Dla elementow
Beside i Below rowniez mamy pomsl, jak mozna to zrobic.

No dobra, to podciagamy rekawy i dzialamy.

Jezeli idzie o "cons", sprawa jest prosta.
W kwestii Atom, trzeba bedzie chyba dodac
nowe funkcje do paintera.

Natomiast moze zbudujmy sobie - albo poszukajmy - listy
implementacji interfejsu Element.

- Space
- Atom
- cons
- Text
- BlockComment
- LineComment
- ExpressionComment
- HorizontalBar
- VerticalBar
- Beside
- Below
- Bordered
- Over
- Stretched
- Quote
- Magic


* 19.09.2024

Teraz bysmy dodali funkcje "cursor-position", ktora pobiera kursor
i zwraca jego polozenie

#+BEGIN_SRC scheme

  (define/kw (cursor-position cursor ::Cursor := (the-cursor)
			      in: document := (the-document)
			      context: ::Cursor := '()
			      into: target ::Position := (Position))
    ::Position
    (escape-with return
      (let* ((aspiration ::int (length cursor))
	     (level ::int (length context))
	     (suffix ::Cursor (drop (- aspiration level 1) cursor)))

	(define (action item ::Element t::Traversal)
	  (let ((context* (recons t:index context)))
	    (when (equal? context* suffix)
	      (set! target:left (+ target:left t:left))
	      (set! target:top (+ target:top t:top))
	      (return (item:measure-position
		       #;of cursor #;into target
			    #;within context*)))))

	(define (result t ::Traversal)
	  (error "Cursor "cursor"not found in "document))

	(traverse elems doing: action returning: result))))

#+END_SRC


no i teraz jak ona musi dzialac, ta nasza funkcja?

- przemierzamy sobie liste elementow
- jezeli ~(is (recons t:index context) equal? cursor)~,
  to zwracamy polozenie wynikajace z aktualnego traverse'a

- jezeli ~(is (recons t:index context) suffix? cursor)~,
  to rekurencyjnie wywolujemy

No to teraz tak:


* 18.09.2024

no i super: mozemy wyznaczyc zbior indeksow, pod ktorymi
znajduja sie poszukiwane przez nas wyrazenia

teraz trudnosc polega na tym, zeby:
- wycentrowac widok wokol kursora
- podswietlic znalezione wyrazenia

Ale tak ogolnie to bysmy zaczeli od tego, zeby
przemianowac cursor-position na marked-cursor-position

* 16-17.09.2024

No dobra, to wyglada na to, ze funkcja wyszukujaca jako tako dziala

Teraz by sie ja chcialo jakos zintegrowac z interfejsem.
Ale zeby moglo do tego dojsc, musimy miec jakis sposob na to,
zeby wskazac na miejsce w dokumencie, na ktorym znajduje sie
biezacy kursor.

Bo na razie mamy tak, ze jezeli stwierdzamy, ze nasza funkcja rysujaca
nie widzi dalszej czesci dokumentu, to po prostu przerywamy.

Pytanie, czy powinnismy wyznaczac pozycje kursora podczas rysowania,
czy moze raczej powinnismy miec funkcje, ktora dla zadanego kursora
zwraca nam jego pozycje w dokumencie.

A nasza koslawa definicja to tak sobie wyglada:

#+BEGIN_SRC scheme
  (define (find-next satisfying? ::(maps (Element) to: boolean)
		     in: document ::Indexable
		     after: cursor ::Cursor := '()
		     context: context ::Cursor := '())
    ::(maybe Cursor)
    (escape-with return
      (let* ((current-level ::int (length context))
	     (reference-level ::int (length cursor))
	     (pressure (- reference-level current-level 1))
	     (index (if (is pressure #;< >= 0)
			(let ((initial-index (cursor pressure)))
			  (if (= pressure 0)
			      (document:next-index initial-index)
			      initial-index))
			(document:next-index
			 (document:first-index))))
	     (limit (document:last-index)))
	(while (isnt index eqv? limit)
	  (let ((item (document:part-at index)))
	    (when (and (isnt item eq? document)
		       (is item satisfting?))
	      (return (recons index context)))
	    (when (gnu.lists.LList? item)
	      (let ((result (find-next satisfying?
				       in: item
				       context: (recons index
							context))))
		(when result
		  (return result)))))
	  (set! index (document:next-index index)))
	(return #!null))))

  (a ; (1)
   (a ; (1 3)
    (a ; (1 3 3)
     a ; (3 3 3)
     )))
#+END_SRC

no to to musi dzialac mniej wiecej tak, ze:
- jezeli kursor jes

#+BEGIN_SRC scheme

  (e.g.
    (find-next (is _ eq? 'a) in: '(a (a (a a))))
    #;< ===> (1))

  (e.g.
    (find-next (is _ eq? 'a) in: '(a (a (a a))) after: '(1))
    #;< ===> (1 3))

  (e.g.
    (find-next (is _ eq? 'a) in: '(a (a (a a))) after: '(1 3))
    #;< ===> (1 3 3))  

  (e.g.
    (find-next (is _ eq? 'a) in: '(a (a (a a))) after: '(1 3 3))
    #;< ===> (3 3 3))
  
  (e.g.
    (find-next (is _ eq? 'a) in: '(a (a (a a))) after: '(3 3 3))
    #;< ===> #!null)

#+END_SRC


#+BEGIN_SRC

context = '() #0
cursor = '(1) #1
-------------
index = 1 ++ @(1-1)


context = '() #0
cursor = '(1 3 3) #3 
-----------------
index = 3 @(3-1)


context = '(3) #1
cursor = '(1 3 3) #3
-----------------
index = 3 @(3-2)

context = '(3 3) #2
cursor = '(1 3 3) #3
-----------------
index = 1 ++ @(3-3)

#+END_SRC


* 13.09.2024

trzeba pomyslec, co robic, jezeli dokument jest
otwarty w wielu edytorach na raz

na pewno bedzie trzeba dodac "scratch file", na ktorym
nie bedzie sie dalo zrobic "Close", ale na ktorym bedzie
sie dalo zrobic "Clear"

* 12.09.2024

zapisywanie last-save-point wydaje sie, ze juz mamy.
teraz bysmy chcieli zrobic tak, zeby przycisk close
zaczal dzialac

* 11.09.2024

na razie poprawilismy sktypt do budowania, tak zeby pozbyc
sie z niego wyscigu (moze bysmy dzis jeszcze poprawili
te warningi przy kompilacji)

ale po tym bysmy sie zajeli tymi save-pointami

no dobra, to build script poprawiony. czyli teraz tak:

- przegladarka pliku wywoluje przy zapisie procedure =save-document!=
- to wlasnie ta funkcja powinna (o ile pliki sie zgadzaja)
  zaktualizowac wartosc =last-save-point=

  
* 10.09.2024

dzis moze by sie udalo zaimplementowac "new" oraz ewentualnie
"close"?

jezeli idzie o "close", to bysmy dodali do dokumentu
"last-save-point", i przed zamknieciem sprawdzali, czy
sa niezapisane zmiany, a jesli tak, to bysmy pytali
uzytkownika, czy zmiany zapisac.

Aha no i trzeba jeszcze przemianowac 'property' na 'attribute',
aczkolwiek to moze jakos pod koniec tygodnia?

A moze wlasnie teraz?

No dobra, to to mamy. To teraz mozemy sie na spokojnie zajac
koncepcja implementacji close'a (i tworzenia nowych plikow).

No to tak:
- dodajemy atrybut =last-save-point=
  do =(editor document history-tracking)=
- w momencie, kiedy robimy "save", to powinnmy
  (jezeli pliki sie zgadzaja) ustawic jako
  =last-save-point= aktualny front
- przy wywolywaniu "close" powinnismy sprawdzic,
  czy last-save-point jest zgodny z biezacym frontem
  - jezeli nie, to wyswietlamy dialog "czy zapisac zmiany"

* 09.09.2024

sprobujemy dzis popracowac z pustym dokumentem, i wdrozyc
stosowne poprawki

No to tak:
- kursor otwierajacy powinien byc ([ 1), a zamykajacy (] 1)
  ( (  ) )
  
OK. widzimy, ze mamy pewien problem z tym, ze kursor przechowujemy
w edytorze, i ze przy zmianie dokumentu nie zmieniamy tego kursora.

Stad pomysl bylby taki, zeby:
- stworzyc klase DocumentEditingContext
- w dokumencie trzymac mape, ktora pelnilaby role analogiczna
  do document-transform
- mape document-transform usunac

#+BEGIN_SRC scheme
  (define-type (DocumentEditingContext
		cursor: Cursor
		selection-range: int
		transform: Transform))
#+END_SRC


* 08.09.2024

no i po warsztatach.
kilka uwag:
- dobrze by bylo moc tworzyc nowe dokumenty
- i zeby dalo sie edytowac puste dokumenty
- i zeby kursor sie nam nie zawijal
  
No to tak. Udalo sie zaimplementowac podzial
ekranu przy otwieraniu plikow z linii komend.
Jeszcze dobrze by bylo dodac  mozliwosc dzielenia
ekranu skrotami klawiszowymi, np. ctrl+- i ctrl-|.
a takze laczenia za pomoca alt+-, alt+shift+-, alt+|,
alt+shift+|.

Ale na razie moze sie skupmy na tworzeniu nowego
pliku, i powrocmy do tematu persystencji workspace'u.

Ale jest jeszcze taka kwestia, ze klient terminalowy
przyjmuje opcje -p, i w sumie wszystkie klienty
moglyby przyjmowac jakies dodatkowe argumenty, dlatego
moze niech klienty definiuja zmienna "input-files"

no dobra, to to juz mamy. to nad czym chcemy pracowac
jutro?

moze nad bledami, ktore sie nam robia z pustym
dokumentem?

albo tworzeniem nowego dokumentu?

* 06.09.2024

na razie moze zrobmy osobnego brancha, zeby moc synchronizowac
pomiedzy laptopem a telefonem

* 05.09.2024

od komentarzy zaczelismy, i na tym zasadniczo sie
skonczylo. Wydaje sie, ze zeby dobrze obsluzyc
consa, trzeba by bylo sporo przemyslec i dokonac wielu
zmian, tzn. przy

#+BEGIN_SRC scheme
(cons 1 (quote (2)))
#+END_SRC

powinno byc tak, ze:
- zewnetrzne nawiasy znikaja
- cons znika
- lewy nawias wewnatrz quote sie rozszerza
- jedynka przesuwa sie do jego wnetrza

natomiast przy

#+BEGIN_SRC scheme
(cdr (quote (2 3)))
#+END_SRC

powinno byc tak, ze znikaja zewnetrzne nawiasy, cdr oraz
liczba 2 z wnetrza

Czyli co?

Powinnismy wywolac 'dissolve!' na wyrazeniach.

* 04.09.2024

jak na razie wszystko pyka, z tym, ze moze bysmy chcieli,
zeby sie ten cons lepiej zachowywal

i przy okazji zeby poprawic zachowanie komentarzy

ale to od komentarzy zaczniemy


* 03.09.2024

po wczorajszych zmianach ewaluacja wyrazen z consami zaczelea juz
nawet jako tako dzialac, tylko ze sledzenie consowanych, carowanych i
cdrowanych wyrazen jeszcze nie idzie najlepiej - i tym bysmy sie
zajeli dzisiaj, natomiast jutro bysmy moze sprobowali zrobic tak, zeby
quote'y sie zamienialy na rozszerzenia (czy moze szerzej, zeby
wszystkie wyrazenia, ktore moga zostac zamienione na rozszerzenia,
byly na nie zamieniane)

No to jak na razie problem jest taki, ze jak mamy np.

#+BEGIN_SRC scheme
(cdr (quote (2)))
#+END_SRC

to wynik tego - mianowicie () - ma przypisana pozycje 0.

Hipoteza bylaby jednak taka, ze owo wyrazenie nie ma
przypisanej pozycji w ogole, i ze gdybysmy to sprawdzili,
i w tego rodzaju sytuacjach przypisywali obiektom jako
pozycje ich pozycje koncowa, to moze by bylo git?

Ale nie, to sie moze jednak nie udac, poniewaz pozycje
sa mierzone przy tworzeniu obiektu "Morph"

Pytanie zatem pozostaje takie: dlaczego ta pozycja
jest zle wyznaczana, podczas gdy pozycje "normalnych"
wartosci funkcji sa wyznaczane dobrze?

Czy to ma zwiazek z tym, ze ten obiekt jest lista?
Czy moze zgubiona zostaje informacja o proweniencji
tego obiektu?

No, ale skoro dochodzi do zmorphowania, to znaczy,
ze ewaluator wie, ze ma do czynienia z wynikiem
ewaluowanego wyrazenia.

Jak sobie za to robimy rozszerzenia, to cos
temu ewaluatorowi nie pyka

* 02.09.2024

wczorajsza zmiana w ewaluarorze wydaje sie OK
(chociaz consowanie lambdy zdaje sie zdeczka
zepsute bo utozsamiamy (lambda ...) z '(lambda ...))

* 01.09.2024

to bysmy zaczeli od reference steppera, tak zeby aplikacja
funkcji pierwotnej dzialala w taki sposob:

#+BEGIN_SRC scheme
(map (lambda (arg)
       (match arg
         (`(quote ,value) value)
	 (_               arg)))
     args)
#+END_SRC

i zeby wartosc zwracana byla owijana w 'quote', jezeli
jest lista.

* 31.08.2024

teraz to warto sie chyba skupic na rzeczach do warsztatow,
na przyklad na tym, dlaczego listy nie dzialaja w ewaluatorze

* 27.08.2024

no to teraz kilka zagwozdek:
- chcemy wyswietlac kod (Link node: ... weight: ...)
  jako kolko ze strzalka
- ale wartosc tego wyrazenia po ewaluacji chcemy
  wyswietlac jako sciezke na grafie

Ponadto chcemy na grafie wyswietlac odwiedzone wezly.
Co wiecej, przy samym podstawieniu/zmaczowaniu patternu
chcemy miec animacje tranzycji pomiedzy wezlami z patternu
a wezlami z grafu/sciezki



* 26.08.2024

w tym tygodniu skupiamy sie raczej na A*

i mamy tutaj dwa orzechy do zgryzienia:
- po pierwsze, sam zapis algorytmu
- po dugie, animacja z jego wykonania

zapis algorytmu wydaje sie prosty: definiujemy jak
maja wygladac linki i sciezki, zeby moc na ich
podstawie rysowac patterny

tym, co wymaga uwagi, jest przejscie od zapisu algorytmu
do animacji jego wykonania

czyli z jednej strony, od rysowania abstrakcyjnych sciezek
chcemy przejsc do rysowania sciezek na grafie
- czyli nalezaloby zrobic tak, ze jezeli pole "on"
  sciezki jest faktycznie grafem, to rysujemy sciezke
  jako sciezke na grafie?

hmmm

tutaj chodzi o cos takiego, ze mamy jakby dwie supozycje
uzycia sciezki:
- jako pattern
- jako wartosc

no to wyobrazmy sobie, ze mamy juz zakodowany A*

po co sobie wyobrazac? lepiej go narysujmy!

kroki:
- zaczynamy od sciezki z oszacowaniem +oo zawierajacej
  tylko start, oraz liste odwiedzonych wierzcholkow zawierajaca
  tylko start
- w kazdym kroku:
  - bierzemy sciezke, ktora aktualnie uwazamy za optymalna
  - z jej wierzcholka wyliczamy wszystkich sasiadow (ktorych
    jeszcze nie odwiedzilismy), i na ich podstawie
    konstruujemy kolejne sciezki
  - sciezki te 'wmasowujemy' (zgodnie z priorytetem)
    w istniejace sciezki

#+BEGIN_SRC scheme
  (define (merge path paths <) ;>
    (match paths
      (`(,first . ,remaining)
       (if (is path < #;> first)
	   `(,path . ,paths)
	   `(,first . ,(merge path remaining))))
      ('()
       `(,path))))

  (fold-left (lambda (paths new-path)
	       (merge paths new-path
		      (is _:estimated-cost < #;> _:estimated-cost)))
	     remaining-paths
	     ...)
#+END_SRC

#+BEGIN_SRC scheme

  (define (optimial-path on: graph ::Graph
			 from: start ::Node
			 until: success? ::(maps (Node) to: boolean)
			 guided-by: estimate ::(maps (Node) to: real))

    (define (walk paths ::(list-of Path)
		  visited-nodes ::(set-of Node))
      (match paths
	(`(,(Path steps: `(,(Link node: tip
				  weight: w1) . ,remaining-steps)
		  cost-so-far: c) . ,remaining-paths)
	 (if (success? tip)
	     ...
	     (let* ((links (only (isnt _:node in visited-nodes)
				 (graph:neighbours-of tip)))
		    (fronts
		     (map (lambda ((Link node: node weight: w))
			    (Path steps:
				  `(,(Link node: node
					   weight: w)
				    ,(Link node: tip
					   weight: w1)
				    . ,remaining-steps)
				  cost-so-far: (+ c w)
				  estimated-cost:
				  (+ c w (estimate node))))
			  links)))
	       (walk (fold-left (lambda (paths front)
				  (merge
				   paths front
				   (is _:estimated-cost < ;>
				       _:estimated-cost)))
				remaining-paths
				fronts)
		     (union visited-nodes
			    (map (lambda ((Link node: n)) n)
				 links))))))
	('() #!null)))

    (walk `(,(Path steps: `(,(Link node: start))
		   estimated-cost: (estimate start)))
	  `(,start)))

#+END_SRC

no dobra, mamy juz wyobrazenie, ze Link mozna rysowac
jako

(beside (encircled node:label) (below (boxed weight) left-arrow))

a Path jako

(underbrace
  (beside (enclouded finish-flag)
    dotted-left-arrow
    (underbrace
      (apply beside steps)
      cost-so-far))
   estimated-cost)

* 22-23.08.2024

czy teraz sie chcemy zajac juz tym algorytmem A*?
(zostal nam wszakze jeszcze commit jutro, i moze moglibysmy
zrobic do tego czasu cos bardziej przyziemnie pozytecznego?)

#+BEGIN_SRC scheme

  (define-type (Node label: string))

  (define-type (Link weight: real
		     target: Node))

  (define-type (Graph nodes: (set-of Node)
		      neighbours-of: (maps (Node) to:
					   (list-of Link))))

  (define-type (Path steps: (sequence-of Link)
		     cost-so-far: real
		     estimated-total-cost: real))

  (define (probably-shorter? a ::Path b ::Path)::boolean
    (is a:estimated-total-cost < #;> b:estimated-total-cost))

  (define (optimial-path on: graph ::Graph
			 from: initial-state ::Node
			 until: success? ::(maps (Node) to: boolean)
			 guided-by: estimate ::(maps (Node) to: real))
    ::Path

    (define (walk paths ::(list-of Path)
		  visited-nodes ::(set-of Node))
      ::Path
      (and-let* ((`(,(Path steps: `(,(Link node: tip) . ,_)
			   cost-so-far: cost-so-far)
		    . ,remaining-paths) paths)
		 (`(,current-node . ,_) path))
	(define (estimate-total-cost `(,node ,weight))
	  (let* ((total-cost (+ cost-so-far weight))
		 (estimate (+ total-cost
			      (remaining-cost-estimate node))))
	    `(,estimate ,total-cost ,node)))

	(define (update-paths paths `(,estimate
				      ,alternative-cost
				      ,node))
	  (let ((new-path `(,estimate
			    ,alternative-cost
			    (,node . ,path))))

	    (match (find (lambda (`(,_ ,_ (,end . ,_)))
			   (equal? end node))
			 paths)
	      (`(,previous-estimate ,established-cost ,_)
	       (if (is established-cost <= alternative-cost)
		   paths
		   (let ((paths (only (lambda (`(,_ ,_ (,end . ,_)))
					(isnt end equal? node))
				      paths)))
		     (merge `(,new-path) paths probably-shorter?))))
	      (_
	       (merge `(,new-path) paths probably-shorter?)))))

	(if (success? current-node)
	    (values (reverse path) cost-so-far)
	    (let* ((neighbors (weighted-graph current-node))
		   (new-neighbors (only (lambda (`(,node ,weight))
					  (isnt node member visited-nodes))
					neighbors))
		   (judged-neighbors (map estimate-total-cost new-neighbors))
		   (paths (fold-left update-paths paths judged-neighbors)))
	      (walk paths (union `(,current-node)
				 visited-nodes))))))

    (walk `((+inf.0 0 (,initial-state))) '()))

#+END_SRC

* 21.08.2024

sprobowalibysmy moze poprawic obsluge klawiatury w taki sposob,
zeby tapniecie na splita powodowalo poprawna aktualizacje
=the-split-path=

No to aktualnie rzecz wyglada tak, ze the-split-path jest
przekazywane w instrukcjach render i key-typed poszczegolnych
splitow, i to chyba zasadniczo niepotrzebnie.

A moze potrzebnie?

Moze powinnismy przemianowac the-split-path na the-split-context?

No dobra, niewazne juz XD

To bysmy sie z powrotem zajeli nawigacja z klawiatury w menu.
i moze jeszcze tym, zeby sie to menu pokazywalo w odpowiednim
miejscu.

i moze jeszcze tez zeby menu bylo przywiazane do dokumentu
(splita), a nie do ekranu?

Ech. Tyle jeszcze do zrobienia...

No ale na jutro commity juz mamy, i na piatek tez.
Stad propozycja jest taka, zeby:
- na razie sie skupic na algorytmie A*
- w kolejnym tygodniu - niezaleznie od wynikow - robimy tak:
  - nawigacja klawiatura po menu
  - przycisk close
  - zapisywanie i odtwarzanie workspace'ow

* 20.08.2024

no to co chcemy:
1. przy (niemalze?) zamykaniu edytora zapisywac workspace
2. przy otwieraniu edytora (probowac) ladowac workspace
3. otwierac plik scratch.scm (automatycznie zapisywany)
4. na androidzie chcemy moc przelaczac miedzy internal
   i external storage
5. zrobmy chociaz to, zeby pole tekstowe mialo minimalna
   szerokosc

przynajmniej to ostatnie jakos sie udalo.
No ale teraz tak: przede wszystkim nawigacja kursorem
i klawisz backspace w polu tekstowym nie dzialaja na Androidzie.

Czy dzialaja w innych klientach - tego nie wiemy.

Ponadto: chcielibysmy miec jakas nawigacje za pomoca strzalek,
np. tak:

ctrl+spacja otwiera nam menu kontekstowe. Za jego pomoca
poruszamy sie w gore i w dol. Klawisz "back" albo "escape"
powoduje zamkniecie okna. Klawisz enter ma takie samo dzialanie,
jak klikniecie na przycisk.

W menu "save file" mamy klawisz "tab", ktorym mozemy przelaczac
pomiedzy przyciskiem "save", polem tekstowym oraz lista plikow.

No to tak:

#+BEGIN_SRC scheme
  (Below top: (Beside left: text-field
		      right: button)
	 bottom: browser)
#+END_SRC

I teraz to albo elementy Beside i Below musza zarzadzac tym,
w jaki sposob przekazywac input z klawiatury, albo musimy
stworzyc jakiegos managera, ktory bedzie o tym decydowal.

* 19.08.2024

na razie decyzja jest taka, ze nie wydzielamy przegladarek
plikow z =(editor input document-editor)= - choc niewykluczone
ze kiedys w przyszlosci to zrobimy

na razie nasze dwa glowne tematy to:
- aktualizacja artykulu na ICFP
- zapisywanie i przywracanie workspace'u

Co do artykulu, to warto by bylo napisac dwa appendixy:
- wprowadzenie do Kawa Scheme
- wyjasnienie funkcji, ktote nie zostaly zdefiniowane

teraz jednak skupmy sie na workspasie

Zacznijmy od tego, zeby zgromadzic informacje o tym, co i jak
jest reprezentowane.

Ladowanie dokumentu w pliku =init.scm= wyglada tak:

#+BEGIN_SRC scheme
(screen:set-content!
 (DocumentEditor
  document: (Document
	     (car (with-input-from-port
		      (open-asset "intro.scm")
		    parse-document))
	     #!null)))
#+END_SRC

w pliku =(editor document documents)= mamy sobie parametr
=(open-documents)=

* 14.07.2024

wszystko sie tu udalo jak na razie.

jeszcze nastepujace rzeczy nam pozostaja:
- znalezc miejsce dla the-recognizers
- wyodrebnic modul =(editor input file-browsers)=
- a co za tym idzie, stworzyc pod-interfejs dla
  DocumentEditor

to zacznijmy moze od wypisania wsxystkich metod
z klasy Editor uzywanych przez przegladarki plikow

to jest zasadniczo =load-file= oraz pole =document=

* 13.08.2024

wczoraj udalo sie wyodrebnic modul, tyle ze problem z nim jest
taki, ze nie dziala.

wiec dzisiaj trzeba zrobic tak, zeby dzialalo.

no to teraz dziala. Dalsze kroki to:
- przemianowac =(editor input pane)= na =(editor input screen)=
- z powrotem scalic =(editor input overlays)= do moddulu screen
- z modulu =(editor input document-editor)= sprobowac wyodrebnic
  =(editor input pop-ups)=

* 12.08.2024

to co teraz? chyba bedziemy kontynuowac dzielo rozbijania
=(editor input pane)=

to mamy wyestrahowany interfejs Screen. I teraz bysmy sprobowali
zrobic tak, zeby przeniesc zmienna screen do
=(editor interfaces elements)=

no ale to sie niestety nie uda, bo android jest zbyt kaprysny

dlatego na razie sprobujemy wyodrebnic modul =(editor input splits)=.

* 11.08.2024

No dobra, to plan na ten tydzien jest taki, zeby:
- uczynic Screen interfejsem
- przemianowac aktualny Screen na ActualScreen
- rozbic modul =(editor input pane)= na mniejsze

Jak to skonczymy, to bysmy sprobowali uporzadkowac
kwestie otwierania i przelaczania plikow, i kiedy
to bedziemy mieli, to bysmy zrobili to zapisywanie
workspace'u.

A jak to bedzie gotowe, to wtedy tak:
- scroll bar, autoscroll i auto-resize
- poprawki w edycji i pozycjonowaniu kursora
- poprawki w renderowaniu/wymiarowaniu na klientach
  graficznych
- poprawki w ewaluatorze (obsluga list)
- algorytm A* z wizualizacja

A pozniej:
- wydanie wersji 1.0
- wyszukiwanie
- widok projektu (graf zaleznosci)
- przegladanie historii commitow

Ale gdzies w tym wszystkim musi jeszcze byc edycja GRASPa w GRASPie
(i to im szybciej tym lepiej)

* 10.08.2024

Na razie udalo sie sprawic, zeby Screen byl Embeddable

Teraz bysmy sie zajeli tym, zeby Embeddable byl przekazywany
jako argumenr do recognizerow, zeby przeniesc the-recognizers
do gestures

Ale wyglada na to, ze nie mozemy tego zrobic, bo cos w gestures
uzywa =DocumentEditor=.

To kolejne pytanie: czy mamy szanse wyekstrahowac =DocumentEditor=
z =(editor input pane)=?
(a w drugiej kolejnosci splity)


No to ogolnie tak: chcielibysmy uczynic =Screen= interfejsem
w =(editor interfaces elements)=, natomiast =Screen= bysmy
przemianowali na =ActualScreen= - czy to dobry pomysl?

Ogolnie wydaje sie umiarkowany.

* 09.08.2024

trzeba w jakis sposob zaprojektowac zaleznosci.

Przede wszystkim byloby niezle, gdyby screen zostal interfejsem
i byl przeniesiony do innego modulu

podobnie do DocumentEditor raczej powinnismy sie odnosic tylko
za posrednictwem interfejsu Editor z (editor interfaces elements).

A moze nie? Moze przegladarki plikow powinny sie znalezc
razem z DocumentEditor?

Na razie zrobmy tak, zeby
- dodac dodatkowy argument do Recognizerow
- przeniesc definicje the-recognizer do (editor input gestures)

* 08.08.2024

na razie jakos tak doszlo do tego, ze rozbijamy
=(editor input pane)= na mniejsze moduly, i w zwiazku z tym
powinnismy sobie wypisac zaleznosci (i problemy)

no to mamy:
** (editor input pane):
Screen, Overlay, Recognizer, the-recognizers, screen

** (editor input splits)
SplitFocus, the-split-path, Split, ResizeSplitAt, SplitBeside, SplitBelow

** (editor input document-editor)
Selected, DragAround, Translate, Resize, CursorMarker, DocumentEditor

** (editor input scrolling)
Scroll

** (editor input pop-ups)
PopUp

** (editor input file-browsers)
<same funkcje>

** (editor input drawings)
Point, Stroke, Drawing

I teraz tak: te refaktoryzacje z pewnoscia trzrba zrobic, byc moze
nawet w takim ksztalcie, ale pomalu

* 07.08.2024

#+BEGIN_SRC scheme
  (before-possible-exit
   (lambda ()
     ...))

  (screen:set-content!
   (let* ((workspace-file (string-append
			   (application-directory)
			   "/.grasp.workspace"))
	  (scratch-file (string-append
			 (projects-directory)
			 "/.scratch.scm")))
     (otherwise
	 (otwrz albo stwrz scratch-file
		 i sprbuj zaadowa asset "intro.scm")
       (and-let* ((workspace (load-mapping workspace-file))
		  (open-documents (workspace 'open-documents))
		  (main-view (workspace 'main-view)))
	 ...))))

#+END_SRC

Moze dzisiaj skupmy sie na tym fragmencie:

#+BEGIN_SRC scheme
  (otwrz albo stwrz scratch-file
	  i sprbuj zaadowa asset "intro.scm")
#+END_SRC

Musimy miec taka reprezentacje dla dokumentu, ktora by trzymala
informacje o tym, czy dany plik pochodzi z "assets". Moze taki
prefix:

"file://"
"assets://"

Ale na razie moze sprobujmy rozbic =(editor input pane)=
na mniejsze moduly?

Z kolei chcielibysmy tez polaczyc moduly
(language for), (language while), (language match) i (language infix)
w jeden wiekszy modul, nazwijmy go (language extensions)

Ale nie, tego na razie nie robmy. Zrobimy to jak zbudujemy sobie
narzedzie do wizualizacji i scalania modulow,

* 06.08.2024

dzis bysmy zaczeli od tego, zeby przeniesc zawartosc pliku
poczatkowego do =assets/intro.scm= i dodac funkcje =open-asset=.

No dobra, to teraz kiedy juz to mamy, to bysmy popracowali nad tym,
zeby:
- przy uruchamianiu sprawdzac workspace.grasp i jesli istnieje,
  to go ladowac
- przy zamykaniu zapisywac workspace.grasp

No ale na razie chcemy sie upewnic, ze:
- najpierw otwiera sie assets/intro.scm
- oprocz niego otwiera sie (projects-directory)/scratch.scm
- scratch.scm jest zapisywany razem z workspace'em
- scratch.scm jest niezamykalny


* 05.08.2024

chcemy dodac nowa metode, ale jak sie powinnaa nazywac?
- before-termination
- at-exit
- before-possible-termination
- save-state
- on-save-state
- add-save-state-handler!

w koncu zrobilismy before-possible-exit

i teraz trzeba wymyslic jak zapisac i zaladowac stan
przestrzeni roboczej

czyli z jednej strony przy zaladowywaniu chcemy sprawdzic,
czy plik workspace.grasp istnieje - a jesli tak, zaladowac
z niego odpowiednie pola

przy okazji chcemy sprawic, zeby help byl ladowany jako
osobny plik, na ktorego chcemy moc przelaczac.

Chcielibtsmy tez od razu - i to zawsze - otwierac plik
=scratch.grasp=, ktorego nie powinno sie dawac zamknac,
a ktory powinien sie zapisywac zawsze przy zamknieciu

* 04.08.2024

musimy sie zastanowic nad struktura workspace'u.

Chcemy miec takie pola, jak:
- =open-documents=
- =unsaved-document-changes=
- =main-view=
- =editor/document-transform=
- =editor/document-cursor=

Ok. I teraz tak:
- na JVM chcemy wywolac
  (...Runtime:getRuntime:addShutdownHook
   (lambda ()
    ... zapisz plik workspace.grasp ...))
- na Androidzie chcemy zrobic to samo
  tylko w metodzie onStop

* 03.08.2024

mamy funkcje (application-directory), i teraz bysmy chcieli
zzrobic cos takiego, zeby przy uruchomieniu sprawdzac czy
w (application-directory) istnieje plik "workspace.grasp",
a jesli tak, to na jego podstawie odtworzylibysmy zawartosc
widoku.

I to by musialo wygladac tak, ze przechowujemy:
- liste wszystkich otwartych plikow (razem z lista edycji
  od czasu ostatniego zapisania)
- strukture opisujaca podzial ekranu

Natomiast jezeli nie ma tego pliku, to ladujemy plik
z helpem.

No dobra, ale oprocz (application-directory) chcielibysmy
jeszcze miec (projects-directory), w ktorym bysmy trzemali
repozytoria, i ktore w przypadku androida byloby w external
storage, a w przypadku GRASP gdzies w katalogu domowym.

* 02.08.2024

to teraz bysmy sie zajeli modyfikacja pliku init w taki sposob,
zeby ladowal ostatni workspace

a w kazdym razie bysmy chcieli przeniesc zawartosc glownego
pliku do czegos w rodzaju intro.scm

(tylko musimy pamietac, ze klient terminalowy nie posiada
katalogu assets)

No dobra, to musimy ustalic, w jaki sposob rozne srodowiska
widza rozne systemy plikow.

Na desktopie (i w terminalu pewnie tez) mamy sobie funkcje
load-resource

No to tak: na Androidzie mamy getFilesDir, getCacheDir,
getExfernalFilesDir, getExternalCacheDir, natomiast na
PC mamy albo katalog domowy uzytkownika, albo katalog,
w ktorym znajduje sie uruchamiany plik .jar.

Ten ostatni dostajemy za pomoca

(java.lang.System:getProperty "user.dir")

* 01.08.2024

cel nadrzedny na dzisiaj to poprawic generowanie plikow .axml
w taki sposob, zeby nie bylo roznicy pomiedzy nami a aapt
dla io.itch.panicz (a jak to sie powiedzie, to wyprobowac
rowniez inne dlugosci pakietu)

Na poczatek zaczelibysmy od tego, zeby wyrownac dlugosc
bloku z tabela stringow tak, zeby byla podzielna przez 4.

Ale moze tak naprawde nalezaloby zaczac od tego, zeby
przywrocic plik test-axml?

No dobra chyba udalo sie naprawic. To jeszcze tak:
- usunac warningi
- skasowac stare skrypty do budowania
- zaktualizowac README
- dodac ikone dla Litetek

* 31.07.2024

dzis bysmy sprobowali zaimplementowac szybka sciezke przy braku
zmian w plikach scm (podmiane pliku init.scm) i obsluzyc kompilacje
z innym pakietem niz io.github.grasp, np. io.itch.panicz1

No to tak: gdy dlugosc nazwy pakietu sie zgadza, to jest git,
a jak sie nie zgadza, to jest nie-git.

Trzeba rozpoznac gdzie jest problem (w manifescie czy arsc)
i go rozwiazac.

* 30.07.2024

no dobra, skrypt wydaje sie z grubsza przeniesiony - tyle ze
sa nowe warningi, ktore wygladaja ciut niepokojaco (i pewnie maja sens).

wiec trzeba z nimi sie uporac,  i wtedy zastapic skrypt wywolaniem
procedury, i przemapowac argumenty na slowa kluczowe

* 29.07.2024

dobrze by bylo chociaz przeniesc caly proces ze skryptu do
biblioteki, i zbudowac interfejs wywolan ze skryptu powloki

* 28.07.2024

no dobra, to nasz cel na ten tydzien jest taki, zeby skonczyc
system buildow

* 26.07.2024

jak zapewnic, zeby nie przebudowywac plikow .class (i .dex)
jeezeli tylko zmienil sie init?

no to tak: jezeli lista plikow do przebudowania jest pusta,
a ponadto nazwa pakietu i nazwa aplikacji nie ulegly zmianie,
to nie kasujemy plikow classes.dex, grasp-desktop.zip,
grasp-terminal.zip ani katalogu <package>, tylko z istniejacych
plikow budujemy archiwa z nowymi initami.

ale wydaje sie, ze o ile tylko zapiszemy sobie poprzednie
zaleznosci pliku init, i potwierdzimy, ze one nie ulegly
zmianie, to nawet nie powinnismy musiec budowac grafu zaleznosci,
bo wtedy wyatarczy nam, ze:
- grasp-desktop.zip istnieje
- grasp-terminal.zip istnieje
- classes.dex istnieje
- wszystkie te pliki sa nowsze od plikow .scm z katalogu .src
- (previous 'package) jest taki sam, jak package
- zaleznosci init.scm sa podzbiorem (previous 'init-dependencies) 

Natomiast jezeli jedyna roznica to nazwa pakietu, to wtedy musimy
- skasowac folder odpowiadajacy (previous 'package)
- skasowac classes.dex
- ponownie skompilowac dla androida
- przedexowac nowe pliki
- zintegrowac classes.dex

* 25.07.2024

jupi, udalo sie!

no to teraz musimy sie zajac nastepujacymi kwestiami:
- idempotencja build.scm na androidzie (kolejne wywolania
  nie powinny nic psuc)
- zapamietywanie ostatnio uzywanej nazwy pakietu
- sprawienie, zeby zmiana tylko pliku init nie powodowala
  przebudowy plikow .class ani plikow .dex
- interfejs wywolania

#+BEGIN_SRC scheme
  (build targets: '(android desktop terminal)
         name: Literky
	 icon: icons/crossword.png
	 init: init/literki.scm
	 package: systems.grasp
	 keystore: binary/keystore
	 key: ...
	 password: ...)
#+END_SRC

natomiast jak by to musialo wygladac po stronie basha?

#+BEGIN_SRC bash
  ./build.scm --help
  ./build.scm
  ./build.scm --targets=android,desktop
  ./build.scm --name=literki --target=android,desktop \
	      --package=io.itch.panicz --icon=icons/literki.png \
	      --keystore=binary/keystore --key=... \
	      --password=...

#+END_SRC

To plan na teraz jest taki, zeby:
- opisac jak teraz wyglada proces budowania
- zdefiniowac, jak powinien wygladac ten proces
- (a na koniec zrobic adapter, ktory nam dostosowuje
  interfejs basha do kawy, usunac stare skrypty,
  i zaktualizowac README)

No to tak. Aktualny proces budowania:

1. gromadzimy liste wszystkich plikow ".scm"
   z katalogu "src"
2. analizujac ich liste importow, budujemy
   graf zaleznosci
3. sprawdzamy, czy w grafie nie wystepuja
   zaleznosci cykliczne
4. gromadzimy liste wszystkich plikow ".class"
   z katalogu build/cache
5. sprawdzamy, ktore pliki .class pochodza z jakich
   modulow
6. sprawdzamy, ktore pliki .class sa starsze od
   swoich zrodlowych modulow, albo od zaleznosci
   tych modulow, i na tej podstawie tworzymy
   liste plikow do przebudowania i do skasowania
7. wyodrebniamy warstwy grafu zaleznosci,
   i budujemy moduly rownolegle
8. budujemy (rownolegle) klasy dla glownych
   aplikacji (android, terminal i desktop)
   - przy czym klient androidowy buduje sie
     z nazwa pakietu
9. ponownie indeksujemy pliki .class na potrzeby
   dexowania
10. na podstawie zaleznosci (w tym pliku init)
    budujemy liste klas do przedexowania
11. dexujemy pliki .class
12. scalamy pliki .dex z bibliotekami do classes.dex
13. generujemy pliki .apk i .jar

i teraz bysmy chcieli wprowadzic takie zmiany, zeby:
1. jezeli nie budujemy na androida, to omijamy
   dexowanie
2. jezeli jedyne, co sie zmienilo, to plik init,
   i lista jego zaleznosci nie ulegla zmianie,
   to nie chcemy dotykac plikow .class ani .dex
3. jezeli budujemy na androida, to przed zbudowaniem
   plikow .class chcielibysmy skasowac folder
   build/class/<previous-package>, gdzie
   <previous-package> to zawartosc pliku
   build/previous-package (o ile istnieje).

* 24.07.2024

to dzis bysmy sprobowali zbudowac plik apk z build.scm

* 23.07.2024

chyba udalo sie doprowadzic te axmle do ladu. jeszcze przydaloby sie
pozbyc tego pola 'parent' tam, gdzie ono wystepuje, i przekazywac
parent jako argument, a jak to bedziemy mieli, to bysmy sprobowali
wygenerowac binarny axml, ktoremu bysmy mogli nadawac nazwe pakietu
i aplikacji

* 22.07.2024

plan jest teraz taki, zeby zbadac wzajemna odwrotnosc metod parse/serialize
klasy AndroidXML (i prawdopodobnie ja naprawic)

* 12.07.2024\\

#+BEGIN_SRC
000  03 00 08 00 64 0e 00 00  01 00 1c 00 60 07 00 00  |....d.......`...|
010  2f 00 00 00 00 00 00 00  00 00 00 00 d8 00 00 00  |/...............|
020  00 00 00 00 00 00 00 00  1a 00 00 00 34 00 00 00  |............4...|
030  5a 00 00 00 90 00 00 00  ae 00 00 00 d2 00 00 00  |Z...............|
040  de 00 00 00 1a 01 00 00  28 01 00 00 34 01 00 00  |........(...4...|
050  42 01 00 00 50 01 00 00  6e 01 00 00 80 01 00 00  |B...P...n.......|
060  d8 01 00 00 dc 01 00 00  ee 01 00 00 22 02 00 00  |............"...|
070  56 02 00 00 6a 02 00 00  7e 02 00 00 88 02 00 00  |V...j...~.......|
080  90 02 00 00 98 02 00 00  ac 02 00 00 ce 02 00 00  |................|
090  0a 03 00 00 5e 03 00 00  b4 03 00 00 0c 04 00 00  |....^...........|
0a0  4e 04 00 00 88 04 00 00  a2 04 00 00 c6 04 00 00  |N...............|
0b0  e0 04 00 00 f4 04 00 00  04 05 00 00 1c 05 00 00  |................|
0c0  3a 05 00 00 4a 05 00 00  82 05 00 00 96 05 00 00  |:...J...........|
0d0  da 05 00 00 ec 05 00 00  fc 05 00 00 42 06 00 00  |............B...|
0e0  0b 00 76 00 65 00 72 00  73 00 69 00 6f 00 6e 00  |..v.e.r.s.i.o.n.|
0f0  43 00 6f 00 64 00 65 00  00 00 0b 00 76 00 65 00  |C.o.d.e.....v.e.|
100  72 00 73 00 69 00 6f 00  6e 00 4e 00 61 00 6d 00  |r.s.i.o.n.N.a.m.|
110  65 00 00 00 11 00 63 00  6f 00 6d 00 70 00 69 00  |e.....c.o.m.p.i.|
120  6c 00 65 00 53 00 64 00  6b 00 56 00 65 00 72 00  |l.e.S.d.k.V.e.r.|
130  73 00 69 00 6f 00 6e 00  00 00 19 00 63 00 6f 00  |s.i.o.n.....c.o.|
140  6d 00 70 00 69 00 6c 00  65 00 53 00 64 00 6b 00  |m.p.i.l.e.S.d.k.|
150  56 00 65 00 72 00 73 00  69 00 6f 00 6e 00 43 00  |V.e.r.s.i.o.n.C.|
160  6f 00 64 00 65 00 6e 00  61 00 6d 00 65 00 00 00  |o.d.e.n.a.m.e...|
170  0d 00 6d 00 69 00 6e 00  53 00 64 00 6b 00 56 00  |..m.i.n.S.d.k.V.|
180  65 00 72 00 73 00 69 00  6f 00 6e 00 00 00 10 00  |e.r.s.i.o.n.....|
190  74 00 61 00 72 00 67 00  65 00 74 00 53 00 64 00  |t.a.r.g.e.t.S.d.|
1a0  6b 00 56 00 65 00 72 00  73 00 69 00 6f 00 6e 00  |k.V.e.r.s.i.o.n.|
1b0  00 00 04 00 6e 00 61 00  6d 00 65 00 00 00 1c 00  |....n.a.m.e.....|
1c0  72 00 65 00 71 00 75 00  65 00 73 00 74 00 4c 00  |r.e.q.u.e.s.t.L.|
1d0  65 00 67 00 61 00 63 00  79 00 45 00 78 00 74 00  |e.g.a.c.y.E.x.t.|
1e0  65 00 72 00 6e 00 61 00  6c 00 53 00 74 00 6f 00  |e.r.n.a.l.S.t.o.|
1f0  72 00 61 00 67 00 65 00  00 00 05 00 6c 00 61 00  |r.a.g.e.....l.a.|
200  62 00 65 00 6c 00 00 00  04 00 69 00 63 00 6f 00  |b.e.l.....i.c.o.|
210  6e 00 00 00 05 00 73 00  68 00 65 00 6c 00 6c 00  |n.....s.h.e.l.l.|
220  00 00 05 00 74 00 68 00  65 00 6d 00 65 00 00 00  |....t.h.e.m.e...|
230  0d 00 63 00 6f 00 6e 00  66 00 69 00 67 00 43 00  |..c.o.n.f.i.g.C.|
240  68 00 61 00 6e 00 67 00  65 00 73 00 00 00 07 00  |h.a.n.g.e.s.....|
250  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 00 00  |a.n.d.r.o.i.d...|
260  2a 00 68 00 74 00 74 00  70 00 3a 00 2f 00 2f 00  |*.h.t.t.p.:././.|
270  73 00 63 00 68 00 65 00  6d 00 61 00 73 00 2e 00  |s.c.h.e.m.a.s...|
280  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
290  63 00 6f 00 6d 00 2f 00  61 00 70 00 6b 00 2f 00  |c.o.m./.a.p.k./.|
2a0  72 00 65 00 73 00 2f 00  61 00 6e 00 64 00 72 00  |r.e.s./.a.n.d.r.|
2b0  6f 00 69 00 64 00 00 00  00 00 00 00 07 00 70 00  |o.i.d.........p.|
2c0  61 00 63 00 6b 00 61 00  67 00 65 00 00 00 18 00  |a.c.k.a.g.e.....|
2d0  70 00 6c 00 61 00 74 00  66 00 6f 00 72 00 6d 00  |p.l.a.t.f.o.r.m.|
2e0  42 00 75 00 69 00 6c 00  64 00 56 00 65 00 72 00  |B.u.i.l.d.V.e.r.|
2f0  73 00 69 00 6f 00 6e 00  43 00 6f 00 64 00 65 00  |s.i.o.n.C.o.d.e.|
300  00 00 18 00 70 00 6c 00  61 00 74 00 66 00 6f 00  |....p.l.a.t.f.o.|
310  72 00 6d 00 42 00 75 00  69 00 6c 00 64 00 56 00  |r.m.B.u.i.l.d.V.|
320  65 00 72 00 73 00 69 00  6f 00 6e 00 4e 00 61 00  |e.r.s.i.o.n.N.a.|
330  6d 00 65 00 00 00 08 00  6d 00 61 00 6e 00 69 00  |m.e.....m.a.n.i.|
340  66 00 65 00 73 00 74 00  00 00 08 00 61 00 62 00  |f.e.s.t.....a.b.|
350  63 00 64 00 65 00 66 00  67 00 68 00 00 00 03 00  |c.d.e.f.g.h.....|
360  31 00 2e 00 30 00 00 00  02 00 31 00 33 00 00 00  |1...0.....1.3...|
370  02 00 33 00 33 00 00 00  08 00 75 00 73 00 65 00  |..3.3.....u.s.e.|
380  73 00 2d 00 73 00 64 00  6b 00 00 00 0f 00 75 00  |s.-.s.d.k.....u.|
390  73 00 65 00 73 00 2d 00  70 00 65 00 72 00 6d 00  |s.e.s.-.p.e.r.m.|
3a0  69 00 73 00 73 00 69 00  6f 00 6e 00 00 00 1c 00  |i.s.s.i.o.n.....|
3b0  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
3c0  70 00 65 00 72 00 6d 00  69 00 73 00 73 00 69 00  |p.e.r.m.i.s.s.i.|
3d0  6f 00 6e 00 2e 00 57 00  41 00 4b 00 45 00 5f 00  |o.n...W.A.K.E._.|
3e0  4c 00 4f 00 43 00 4b 00  00 00 28 00 61 00 6e 00  |L.O.C.K...(.a.n.|
3f0  64 00 72 00 6f 00 69 00  64 00 2e 00 70 00 65 00  |d.r.o.i.d...p.e.|
400  72 00 6d 00 69 00 73 00  73 00 69 00 6f 00 6e 00  |r.m.i.s.s.i.o.n.|
410  2e 00 52 00 45 00 41 00  44 00 5f 00 45 00 58 00  |..R.E.A.D._.E.X.|
420  54 00 45 00 52 00 4e 00  41 00 4c 00 5f 00 53 00  |T.E.R.N.A.L._.S.|
430  54 00 4f 00 52 00 41 00  47 00 45 00 00 00 29 00  |T.O.R.A.G.E...).|
440  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
450  70 00 65 00 72 00 6d 00  69 00 73 00 73 00 69 00  |p.e.r.m.i.s.s.i.|
460  6f 00 6e 00 2e 00 57 00  52 00 49 00 54 00 45 00  |o.n...W.R.I.T.E.|
470  5f 00 45 00 58 00 54 00  45 00 52 00 4e 00 41 00  |_.E.X.T.E.R.N.A.|
480  4c 00 5f 00 53 00 54 00  4f 00 52 00 41 00 47 00  |L._.S.T.O.R.A.G.|
490  45 00 00 00 2a 00 61 00  6e 00 64 00 72 00 6f 00  |E...*.a.n.d.r.o.|
4a0  69 00 64 00 2e 00 70 00  65 00 72 00 6d 00 69 00  |i.d...p.e.r.m.i.|
4b0  73 00 73 00 69 00 6f 00  6e 00 2e 00 4d 00 41 00  |s.s.i.o.n...M.A.|
4c0  4e 00 41 00 47 00 45 00  5f 00 45 00 58 00 54 00  |N.A.G.E._.E.X.T.|
4d0  45 00 52 00 4e 00 41 00  4c 00 5f 00 53 00 54 00  |E.R.N.A.L._.S.T.|
4e0  4f 00 52 00 41 00 47 00  45 00 00 00 1f 00 61 00  |O.R.A.G.E.....a.|
4f0  6e 00 64 00 72 00 6f 00  69 00 64 00 2e 00 70 00  |n.d.r.o.i.d...p.|
500  65 00 72 00 6d 00 69 00  73 00 73 00 69 00 6f 00  |e.r.m.i.s.s.i.o.|
510  6e 00 2e 00 52 00 45 00  43 00 4f 00 52 00 44 00  |n...R.E.C.O.R.D.|
520  5f 00 41 00 55 00 44 00  49 00 4f 00 00 00 1b 00  |_.A.U.D.I.O.....|
530  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
540  70 00 65 00 72 00 6d 00  69 00 73 00 73 00 69 00  |p.e.r.m.i.s.s.i.|
550  6f 00 6e 00 2e 00 49 00  4e 00 54 00 45 00 52 00  |o.n...I.N.T.E.R.|
560  4e 00 45 00 54 00 00 00  0b 00 61 00 70 00 70 00  |N.E.T.....a.p.p.|
570  6c 00 69 00 63 00 61 00  74 00 69 00 6f 00 6e 00  |l.i.c.a.t.i.o.n.|
580  00 00 10 00 47 00 72 00  61 00 73 00 70 00 41 00  |....G.r.a.s.p.A.|
590  70 00 70 00 6c 00 69 00  63 00 61 00 74 00 69 00  |p.p.l.i.c.a.t.i.|
5a0  6f 00 6e 00 00 00 0b 00  70 00 72 00 6f 00 66 00  |o.n.....p.r.o.f.|
5b0  69 00 6c 00 65 00 61 00  62 00 6c 00 65 00 00 00  |i.l.e.a.b.l.e...|
5c0  08 00 61 00 63 00 74 00  69 00 76 00 69 00 74 00  |..a.c.t.i.v.i.t.|
5d0  79 00 00 00 06 00 2e 00  47 00 52 00 41 00 53 00  |y.......G.R.A.S.|
5e0  50 00 00 00 0a 00 47 00  72 00 61 00 73 00 70 00  |P.....G.r.a.s.p.|
5f0  4c 00 61 00 62 00 65 00  6c 00 00 00 0d 00 69 00  |L.a.b.e.l.....i.|
600  6e 00 74 00 65 00 6e 00  74 00 2d 00 66 00 69 00  |n.t.e.n.t.-.f.i.|
610  6c 00 74 00 65 00 72 00  00 00 06 00 61 00 63 00  |l.t.e.r.....a.c.|
620  74 00 69 00 6f 00 6e 00  00 00 1a 00 61 00 6e 00  |t.i.o.n.....a.n.|
630  64 00 72 00 6f 00 69 00  64 00 2e 00 69 00 6e 00  |d.r.o.i.d...i.n.|
640  74 00 65 00 6e 00 74 00  2e 00 61 00 63 00 74 00  |t.e.n.t...a.c.t.|
650  69 00 6f 00 6e 00 2e 00  4d 00 41 00 49 00 4e 00  |i.o.n...M.A.I.N.|
660  00 00 08 00 63 00 61 00  74 00 65 00 67 00 6f 00  |....c.a.t.e.g.o.|
670  72 00 79 00 00 00 20 00  61 00 6e 00 64 00 72 00  |r.y... .a.n.d.r.|
680  6f 00 69 00 64 00 2e 00  69 00 6e 00 74 00 65 00  |o.i.d...i.n.t.e.|
690  6e 00 74 00 2e 00 63 00  61 00 74 00 65 00 67 00  |n.t...c.a.t.e.g.|
6a0  6f 00 72 00 79 00 2e 00  4c 00 41 00 55 00 4e 00  |o.r.y...L.A.U.N.|
6b0  43 00 48 00 45 00 52 00  00 00 07 00 71 00 75 00  |C.H.E.R.....q.u.|
6c0  65 00 72 00 69 00 65 00  73 00 00 00 06 00 69 00  |e.r.i.e.s.....i.|
6d0  6e 00 74 00 65 00 6e 00  74 00 00 00 21 00 61 00  |n.t.e.n.t...!.a.|
6e0  6e 00 64 00 72 00 6f 00  69 00 64 00 2e 00 69 00  |n.d.r.o.i.d...i.|
6f0  6e 00 74 00 65 00 6e 00  74 00 2e 00 61 00 63 00  |n.t.e.n.t...a.c.|
700  74 00 69 00 6f 00 6e 00  2e 00 54 00 54 00 53 00  |t.i.o.n...T.T.S.|
710  5f 00 53 00 45 00 52 00  56 00 49 00 43 00 45 00  |_.S.E.R.V.I.C.E.|
720  00 00 21 00 61 00 6e 00  64 00 72 00 6f 00 69 00  |..!.a.n.d.r.o.i.|
730  64 00 2e 00 73 00 70 00  65 00 65 00 63 00 68 00  |d...s.p.e.e.c.h.|
740  2e 00 52 00 65 00 63 00  6f 00 67 00 6e 00 69 00  |..R.e.c.o.g.n.i.|
750  74 00 69 00 6f 00 6e 00  53 00 65 00 72 00 76 00  |t.i.o.n.S.e.r.v.|
760  69 00 63 00 65 00 00 00  80 01 08 00 3c 00 00 00  |i.c.e.......<...|
770  1b 02 01 01 1c 02 01 01  72 05 01 01 73 05 01 01  |........r...s...|
780  0c 02 01 01 70 02 01 01  03 00 01 01 03 06 01 01  |....p...........|
790  01 00 01 01 02 00 01 01  94 05 01 01 00 00 01 01  |................|
7a0  1f 00 01 01 00 01 10 00  18 00 00 00 02 00 00 00  |................|
7b0  ff ff ff ff 0d 00 00 00  0e 00 00 00 02 01 10 00  |................|
7c0  b0 00 00 00 02 00 00 00  ff ff ff ff ff ff ff ff  |................|
7d0  13 00 00 00 14 00 14 00  07 00 00 00 00 00 00 00  |................|
7e0  0e 00 00 00 00 00 00 00  ff ff ff ff 08 00 00 10  |................|
7f0  01 00 00 00 0e 00 00 00  01 00 00 00 15 00 00 00  |................|
800  08 00 00 03 15 00 00 00  0e 00 00 00 02 00 00 00  |................|
810  ff ff ff ff 08 00 00 10  21 00 00 00 0e 00 00 00  |........!.......|
820  03 00 00 00 16 00 00 00  08 00 00 03 16 00 00 00  |................|
830  ff ff ff ff 10 00 00 00  14 00 00 00 08 00 00 03  |................|
840  14 00 00 00 ff ff ff ff  11 00 00 00 17 00 00 00  |................|
850  08 00 00 10 21 00 00 00  ff ff ff ff 12 00 00 00  |....!...........|
860  16 00 00 00 08 00 00 10  0d 00 00 00 02 01 10 00  |................|
870  4c 00 00 00 07 00 00 00  ff ff ff ff ff ff ff ff  |L...............|
880  18 00 00 00 14 00 14 00  02 00 00 00 00 00 00 00  |................|
890  0e 00 00 00 04 00 00 00  ff ff ff ff 08 00 00 10  |................|
8a0  17 00 00 00 0e 00 00 00  05 00 00 00 ff ff ff ff  |................|
8b0  08 00 00 10 1d 00 00 00  03 01 10 00 18 00 00 00  |................|
8c0  08 00 00 00 ff ff ff ff  ff ff ff ff 18 00 00 00  |................|
8d0  02 01 10 00 38 00 00 00  0a 00 00 00 ff ff ff ff  |....8...........|
8e0  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
8f0  00 00 00 00 0e 00 00 00  06 00 00 00 1a 00 00 00  |................|
900  08 00 00 03 1a 00 00 00  03 01 10 00 18 00 00 00  |................|
910  0c 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
920  02 01 10 00 38 00 00 00  0d 00 00 00 ff ff ff ff  |....8...........|
930  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
940  00 00 00 00 0e 00 00 00  06 00 00 00 1b 00 00 00  |................|
950  08 00 00 03 1b 00 00 00  03 01 10 00 18 00 00 00  |................|
960  0f 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
970  02 01 10 00 38 00 00 00  10 00 00 00 ff ff ff ff  |....8...........|
980  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
990  00 00 00 00 0e 00 00 00  06 00 00 00 1c 00 00 00  |................|
9a0  08 00 00 03 1c 00 00 00  03 01 10 00 18 00 00 00  |................|
9b0  12 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
9c0  02 01 10 00 38 00 00 00  13 00 00 00 ff ff ff ff  |....8...........|
9d0  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
9e0  00 00 00 00 0e 00 00 00  06 00 00 00 1d 00 00 00  |................|
9f0  08 00 00 03 1d 00 00 00  03 01 10 00 18 00 00 00  |................|
a00  15 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
a10  02 01 10 00 38 00 00 00  16 00 00 00 ff ff ff ff  |....8...........|
a20  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
a30  00 00 00 00 0e 00 00 00  06 00 00 00 1e 00 00 00  |................|
a40  08 00 00 03 1e 00 00 00  03 01 10 00 18 00 00 00  |................|
a50  18 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
a60  02 01 10 00 38 00 00 00  19 00 00 00 ff ff ff ff  |....8...........|
a70  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
a80  00 00 00 00 0e 00 00 00  06 00 00 00 1f 00 00 00  |................|
a90  08 00 00 03 1f 00 00 00  03 01 10 00 18 00 00 00  |................|
aa0  1b 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
ab0  02 01 10 00 60 00 00 00  1d 00 00 00 ff ff ff ff  |....`...........|
ac0  ff ff ff ff 20 00 00 00  14 00 14 00 03 00 00 00  |.... ...........|
ad0  00 00 00 00 0e 00 00 00  08 00 00 00 21 00 00 00  |............!...|
ae0  08 00 00 03 21 00 00 00  0e 00 00 00 09 00 00 00  |....!...........|
af0  ff ff ff ff 08 00 00 01  00 00 02 7f 0e 00 00 00  |................|
b00  07 00 00 00 ff ff ff ff  08 00 00 12 ff ff ff ff  |................|
b10  02 01 10 00 38 00 00 00  21 00 00 00 ff ff ff ff  |....8...!.......|
b20  ff ff ff ff 22 00 00 00  14 00 14 00 01 00 00 00  |...."...........|
b30  00 00 00 00 0e 00 00 00  0a 00 00 00 ff ff ff ff  |................|
b40  08 00 00 12 ff ff ff ff  03 01 10 00 18 00 00 00  |................|
b50  21 00 00 00 ff ff ff ff  ff ff ff ff 22 00 00 00  |!..........."...|
b60  02 01 10 00 74 00 00 00  22 00 00 00 ff ff ff ff  |....t...".......|
b70  ff ff ff ff 23 00 00 00  14 00 14 00 04 00 00 00  |....#...........|
b80  00 00 00 00 0e 00 00 00  0b 00 00 00 ff ff ff ff  |................|
b90  08 00 00 01 06 00 03 01  0e 00 00 00 08 00 00 00  |................|
ba0  25 00 00 00 08 00 00 03  25 00 00 00 0e 00 00 00  |%.......%.......|
bb0  06 00 00 00 24 00 00 00  08 00 00 03 24 00 00 00  |....$.......$...|
bc0  0e 00 00 00 0c 00 00 00  ff ff ff ff 08 00 00 11  |................|
bd0  b0 00 00 00 02 01 10 00  24 00 00 00 27 00 00 00  |........$...'...|
be0  ff ff ff ff ff ff ff ff  26 00 00 00 14 00 14 00  |........&.......|
bf0  00 00 00 00 00 00 00 00  02 01 10 00 38 00 00 00  |............8...|
c00  28 00 00 00 ff ff ff ff  ff ff ff ff 27 00 00 00  |(...........'...|
c10  14 00 14 00 01 00 00 00  00 00 00 00 0e 00 00 00  |................|
c20  06 00 00 00 28 00 00 00  08 00 00 03 28 00 00 00  |....(.......(...|
c30  03 01 10 00 18 00 00 00  29 00 00 00 ff ff ff ff  |........).......|
c40  ff ff ff ff 27 00 00 00  02 01 10 00 38 00 00 00  |....'.......8...|
c50  2a 00 00 00 ff ff ff ff  ff ff ff ff 29 00 00 00  |*...........)...|
c60  14 00 14 00 01 00 00 00  00 00 00 00 0e 00 00 00  |................|
c70  06 00 00 00 2a 00 00 00  08 00 00 03 2a 00 00 00  |....*.......*...|
c80  03 01 10 00 18 00 00 00  2b 00 00 00 ff ff ff ff  |........+.......|
c90  ff ff ff ff 29 00 00 00  03 01 10 00 18 00 00 00  |....)...........|
ca0  2c 00 00 00 ff ff ff ff  ff ff ff ff 26 00 00 00  |,...........&...|
cb0  03 01 10 00 18 00 00 00  2d 00 00 00 ff ff ff ff  |........-.......|
cc0  ff ff ff ff 23 00 00 00  03 01 10 00 18 00 00 00  |....#...........|
cd0  2f 00 00 00 ff ff ff ff  ff ff ff ff 20 00 00 00  |/........... ...|
ce0  02 01 10 00 24 00 00 00  31 00 00 00 ff ff ff ff  |....$...1.......|
cf0  ff ff ff ff 2b 00 00 00  14 00 14 00 00 00 00 00  |....+...........|
d00  00 00 00 00 02 01 10 00  24 00 00 00 32 00 00 00  |........$...2...|
d10  ff ff ff ff ff ff ff ff  2c 00 00 00 14 00 14 00  |........,.......|
d20  00 00 00 00 00 00 00 00  02 01 10 00 38 00 00 00  |............8...|
d30  33 00 00 00 ff ff ff ff  ff ff ff ff 27 00 00 00  |3...........'...|
d40  14 00 14 00 01 00 00 00  00 00 00 00 0e 00 00 00  |................|
d50  06 00 00 00 2d 00 00 00  08 00 00 03 2d 00 00 00  |....-.......-...|
d60  03 01 10 00 18 00 00 00  33 00 00 00 ff ff ff ff  |........3.......|
d70  ff ff ff ff 27 00 00 00  03 01 10 00 18 00 00 00  |....'...........|
d80  34 00 00 00 ff ff ff ff  ff ff ff ff 2c 00 00 00  |4...........,...|
d90  02 01 10 00 24 00 00 00  35 00 00 00 ff ff ff ff  |....$...5.......|
da0  ff ff ff ff 2c 00 00 00  14 00 14 00 00 00 00 00  |....,...........|
db0  00 00 00 00 02 01 10 00  38 00 00 00 36 00 00 00  |........8...6...|
dc0  ff ff ff ff ff ff ff ff  27 00 00 00 14 00 14 00  |........'.......|
dd0  01 00 00 00 00 00 00 00  0e 00 00 00 06 00 00 00  |................|
de0  2e 00 00 00 08 00 00 03  2e 00 00 00 03 01 10 00  |................|
df0  18 00 00 00 36 00 00 00  ff ff ff ff ff ff ff ff  |....6...........|
e00  27 00 00 00 03 01 10 00  18 00 00 00 37 00 00 00  |'...........7...|
e10  ff ff ff ff ff ff ff ff  2c 00 00 00 03 01 10 00  |........,.......|
e20  18 00 00 00 38 00 00 00  ff ff ff ff ff ff ff ff  |....8...........|
e30  2b 00 00 00 03 01 10 00  18 00 00 00 3a 00 00 00  |+...........:...|
e40  ff ff ff ff ff ff ff ff  13 00 00 00 01 01 10 00  |................|
e50  18 00 00 00 3a 00 00 00  ff ff ff ff 0d 00 00 00  |....:...........|
e60  0e 00 00 00                                       |....|
e64
#+END_SRC

#+BEGIN_SRC
000  03 00 08 00 74 0e 00 00  01 00 1c 00 70 07 00 00  |....t.......p...|
010  2f 00 00 00 00 00 00 00  00 00 00 00 d8 00 00 00  |/...............|
020  00 00 00 00 00 00 00 00  1a 00 00 00 34 00 00 00  |............4...|
030  5a 00 00 00 90 00 00 00  ae 00 00 00 d2 00 00 00  |Z...............|
040  de 00 00 00 1a 01 00 00  28 01 00 00 34 01 00 00  |........(...4...|
050  42 01 00 00 50 01 00 00  6e 01 00 00 80 01 00 00  |B...P...n.......|
060  d8 01 00 00 dc 01 00 00  ee 01 00 00 22 02 00 00  |............"...|
070  56 02 00 00 6a 02 00 00  8e 02 00 00 98 02 00 00  |V...j...........|
080  a0 02 00 00 a8 02 00 00  bc 02 00 00 de 02 00 00  |................|
090  1a 03 00 00 6e 03 00 00  c4 03 00 00 1c 04 00 00  |....n...........|
0a0  5e 04 00 00 98 04 00 00  b2 04 00 00 d6 04 00 00  |^...............|
0b0  f0 04 00 00 04 05 00 00  14 05 00 00 2c 05 00 00  |............,...|
0c0  4a 05 00 00 5a 05 00 00  92 05 00 00 a6 05 00 00  |J...Z...........|
0d0  ea 05 00 00 fc 05 00 00  0c 06 00 00 52 06 00 00  |............R...|
0e0  0b 00 76 00 65 00 72 00  73 00 69 00 6f 00 6e 00  |..v.e.r.s.i.o.n.|
0f0  43 00 6f 00 64 00 65 00  00 00 0b 00 76 00 65 00  |C.o.d.e.....v.e.|
100  72 00 73 00 69 00 6f 00  6e 00 4e 00 61 00 6d 00  |r.s.i.o.n.N.a.m.|
110  65 00 00 00 11 00 63 00  6f 00 6d 00 70 00 69 00  |e.....c.o.m.p.i.|
120  6c 00 65 00 53 00 64 00  6b 00 56 00 65 00 72 00  |l.e.S.d.k.V.e.r.|
130  73 00 69 00 6f 00 6e 00  00 00 19 00 63 00 6f 00  |s.i.o.n.....c.o.|
140  6d 00 70 00 69 00 6c 00  65 00 53 00 64 00 6b 00  |m.p.i.l.e.S.d.k.|
150  56 00 65 00 72 00 73 00  69 00 6f 00 6e 00 43 00  |V.e.r.s.i.o.n.C.|
160  6f 00 64 00 65 00 6e 00  61 00 6d 00 65 00 00 00  |o.d.e.n.a.m.e...|
170  0d 00 6d 00 69 00 6e 00  53 00 64 00 6b 00 56 00  |..m.i.n.S.d.k.V.|
180  65 00 72 00 73 00 69 00  6f 00 6e 00 00 00 10 00  |e.r.s.i.o.n.....|
190  74 00 61 00 72 00 67 00  65 00 74 00 53 00 64 00  |t.a.r.g.e.t.S.d.|
1a0  6b 00 56 00 65 00 72 00  73 00 69 00 6f 00 6e 00  |k.V.e.r.s.i.o.n.|
1b0  00 00 04 00 6e 00 61 00  6d 00 65 00 00 00 1c 00  |....n.a.m.e.....|
1c0  72 00 65 00 71 00 75 00  65 00 73 00 74 00 4c 00  |r.e.q.u.e.s.t.L.|
1d0  65 00 67 00 61 00 63 00  79 00 45 00 78 00 74 00  |e.g.a.c.y.E.x.t.|
1e0  65 00 72 00 6e 00 61 00  6c 00 53 00 74 00 6f 00  |e.r.n.a.l.S.t.o.|
1f0  72 00 61 00 67 00 65 00  00 00 05 00 6c 00 61 00  |r.a.g.e.....l.a.|
200  62 00 65 00 6c 00 00 00  04 00 69 00 63 00 6f 00  |b.e.l.....i.c.o.|
210  6e 00 00 00 05 00 73 00  68 00 65 00 6c 00 6c 00  |n.....s.h.e.l.l.|
220  00 00 05 00 74 00 68 00  65 00 6d 00 65 00 00 00  |....t.h.e.m.e...|
230  0d 00 63 00 6f 00 6e 00  66 00 69 00 67 00 43 00  |..c.o.n.f.i.g.C.|
240  68 00 61 00 6e 00 67 00  65 00 73 00 00 00 07 00  |h.a.n.g.e.s.....|
250  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 00 00  |a.n.d.r.o.i.d...|
260  2a 00 68 00 74 00 74 00  70 00 3a 00 2f 00 2f 00  |*.h.t.t.p.:././.|
270  73 00 63 00 68 00 65 00  6d 00 61 00 73 00 2e 00  |s.c.h.e.m.a.s...|
280  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
290  63 00 6f 00 6d 00 2f 00  61 00 70 00 6b 00 2f 00  |c.o.m./.a.p.k./.|
2a0  72 00 65 00 73 00 2f 00  61 00 6e 00 64 00 72 00  |r.e.s./.a.n.d.r.|
2b0  6f 00 69 00 64 00 00 00  00 00 00 00 07 00 70 00  |o.i.d.........p.|
2c0  61 00 63 00 6b 00 61 00  67 00 65 00 00 00 18 00  |a.c.k.a.g.e.....|
2d0  70 00 6c 00 61 00 74 00  66 00 6f 00 72 00 6d 00  |p.l.a.t.f.o.r.m.|
2e0  42 00 75 00 69 00 6c 00  64 00 56 00 65 00 72 00  |B.u.i.l.d.V.e.r.|
2f0  73 00 69 00 6f 00 6e 00  43 00 6f 00 64 00 65 00  |s.i.o.n.C.o.d.e.|
300  00 00 18 00 70 00 6c 00  61 00 74 00 66 00 6f 00  |....p.l.a.t.f.o.|
310  72 00 6d 00 42 00 75 00  69 00 6c 00 64 00 56 00  |r.m.B.u.i.l.d.V.|
320  65 00 72 00 73 00 69 00  6f 00 6e 00 4e 00 61 00  |e.r.s.i.o.n.N.a.|
330  6d 00 65 00 00 00 08 00  6d 00 61 00 6e 00 69 00  |m.e.....m.a.n.i.|
340  66 00 65 00 73 00 74 00  00 00 10 00 61 00 62 00  |f.e.s.t.....a.b.|
350  63 00 64 00 65 00 66 00  67 00 68 00 69 00 6a 00  |c.d.e.f.g.h.i.j.|
360  6b 00 6c 00 6d 00 6e 00  6f 00 70 00 00 00 03 00  |k.l.m.n.o.p.....|
370  31 00 2e 00 30 00 00 00  02 00 31 00 33 00 00 00  |1...0.....1.3...|
380  02 00 33 00 33 00 00 00  08 00 75 00 73 00 65 00  |..3.3.....u.s.e.|
390  73 00 2d 00 73 00 64 00  6b 00 00 00 0f 00 75 00  |s.-.s.d.k.....u.|
3a0  73 00 65 00 73 00 2d 00  70 00 65 00 72 00 6d 00  |s.e.s.-.p.e.r.m.|
3b0  69 00 73 00 73 00 69 00  6f 00 6e 00 00 00 1c 00  |i.s.s.i.o.n.....|
3c0  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
3d0  70 00 65 00 72 00 6d 00  69 00 73 00 73 00 69 00  |p.e.r.m.i.s.s.i.|
3e0  6f 00 6e 00 2e 00 57 00  41 00 4b 00 45 00 5f 00  |o.n...W.A.K.E._.|
3f0  4c 00 4f 00 43 00 4b 00  00 00 28 00 61 00 6e 00  |L.O.C.K...(.a.n.|
400  64 00 72 00 6f 00 69 00  64 00 2e 00 70 00 65 00  |d.r.o.i.d...p.e.|
410  72 00 6d 00 69 00 73 00  73 00 69 00 6f 00 6e 00  |r.m.i.s.s.i.o.n.|
420  2e 00 52 00 45 00 41 00  44 00 5f 00 45 00 58 00  |..R.E.A.D._.E.X.|
430  54 00 45 00 52 00 4e 00  41 00 4c 00 5f 00 53 00  |T.E.R.N.A.L._.S.|
440  54 00 4f 00 52 00 41 00  47 00 45 00 00 00 29 00  |T.O.R.A.G.E...).|
450  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
460  70 00 65 00 72 00 6d 00  69 00 73 00 73 00 69 00  |p.e.r.m.i.s.s.i.|
470  6f 00 6e 00 2e 00 57 00  52 00 49 00 54 00 45 00  |o.n...W.R.I.T.E.|
480  5f 00 45 00 58 00 54 00  45 00 52 00 4e 00 41 00  |_.E.X.T.E.R.N.A.|
490  4c 00 5f 00 53 00 54 00  4f 00 52 00 41 00 47 00  |L._.S.T.O.R.A.G.|
4a0  45 00 00 00 2a 00 61 00  6e 00 64 00 72 00 6f 00  |E...*.a.n.d.r.o.|
4b0  69 00 64 00 2e 00 70 00  65 00 72 00 6d 00 69 00  |i.d...p.e.r.m.i.|
4c0  73 00 73 00 69 00 6f 00  6e 00 2e 00 4d 00 41 00  |s.s.i.o.n...M.A.|
4d0  4e 00 41 00 47 00 45 00  5f 00 45 00 58 00 54 00  |N.A.G.E._.E.X.T.|
4e0  45 00 52 00 4e 00 41 00  4c 00 5f 00 53 00 54 00  |E.R.N.A.L._.S.T.|
4f0  4f 00 52 00 41 00 47 00  45 00 00 00 1f 00 61 00  |O.R.A.G.E.....a.|
500  6e 00 64 00 72 00 6f 00  69 00 64 00 2e 00 70 00  |n.d.r.o.i.d...p.|
510  65 00 72 00 6d 00 69 00  73 00 73 00 69 00 6f 00  |e.r.m.i.s.s.i.o.|
520  6e 00 2e 00 52 00 45 00  43 00 4f 00 52 00 44 00  |n...R.E.C.O.R.D.|
530  5f 00 41 00 55 00 44 00  49 00 4f 00 00 00 1b 00  |_.A.U.D.I.O.....|
540  61 00 6e 00 64 00 72 00  6f 00 69 00 64 00 2e 00  |a.n.d.r.o.i.d...|
550  70 00 65 00 72 00 6d 00  69 00 73 00 73 00 69 00  |p.e.r.m.i.s.s.i.|
560  6f 00 6e 00 2e 00 49 00  4e 00 54 00 45 00 52 00  |o.n...I.N.T.E.R.|
570  4e 00 45 00 54 00 00 00  0b 00 61 00 70 00 70 00  |N.E.T.....a.p.p.|
580  6c 00 69 00 63 00 61 00  74 00 69 00 6f 00 6e 00  |l.i.c.a.t.i.o.n.|
590  00 00 10 00 47 00 72 00  61 00 73 00 70 00 41 00  |....G.r.a.s.p.A.|
5a0  70 00 70 00 6c 00 69 00  63 00 61 00 74 00 69 00  |p.p.l.i.c.a.t.i.|
5b0  6f 00 6e 00 00 00 0b 00  70 00 72 00 6f 00 66 00  |o.n.....p.r.o.f.|
5c0  69 00 6c 00 65 00 61 00  62 00 6c 00 65 00 00 00  |i.l.e.a.b.l.e...|
5d0  08 00 61 00 63 00 74 00  69 00 76 00 69 00 74 00  |..a.c.t.i.v.i.t.|
5e0  79 00 00 00 06 00 2e 00  47 00 52 00 41 00 53 00  |y.......G.R.A.S.|
5f0  50 00 00 00 0a 00 47 00  72 00 61 00 73 00 70 00  |P.....G.r.a.s.p.|
600  4c 00 61 00 62 00 65 00  6c 00 00 00 0d 00 69 00  |L.a.b.e.l.....i.|
610  6e 00 74 00 65 00 6e 00  74 00 2d 00 66 00 69 00  |n.t.e.n.t.-.f.i.|
620  6c 00 74 00 65 00 72 00  00 00 06 00 61 00 63 00  |l.t.e.r.....a.c.|
630  74 00 69 00 6f 00 6e 00  00 00 1a 00 61 00 6e 00  |t.i.o.n.....a.n.|
640  64 00 72 00 6f 00 69 00  64 00 2e 00 69 00 6e 00  |d.r.o.i.d...i.n.|
650  74 00 65 00 6e 00 74 00  2e 00 61 00 63 00 74 00  |t.e.n.t...a.c.t.|
660  69 00 6f 00 6e 00 2e 00  4d 00 41 00 49 00 4e 00  |i.o.n...M.A.I.N.|
670  00 00 08 00 63 00 61 00  74 00 65 00 67 00 6f 00  |....c.a.t.e.g.o.|
680  72 00 79 00 00 00 20 00  61 00 6e 00 64 00 72 00  |r.y... .a.n.d.r.|
690  6f 00 69 00 64 00 2e 00  69 00 6e 00 74 00 65 00  |o.i.d...i.n.t.e.|
6a0  6e 00 74 00 2e 00 63 00  61 00 74 00 65 00 67 00  |n.t...c.a.t.e.g.|
6b0  6f 00 72 00 79 00 2e 00  4c 00 41 00 55 00 4e 00  |o.r.y...L.A.U.N.|
6c0  43 00 48 00 45 00 52 00  00 00 07 00 71 00 75 00  |C.H.E.R.....q.u.|
6d0  65 00 72 00 69 00 65 00  73 00 00 00 06 00 69 00  |e.r.i.e.s.....i.|
6e0  6e 00 74 00 65 00 6e 00  74 00 00 00 21 00 61 00  |n.t.e.n.t...!.a.|
6f0  6e 00 64 00 72 00 6f 00  69 00 64 00 2e 00 69 00  |n.d.r.o.i.d...i.|
700  6e 00 74 00 65 00 6e 00  74 00 2e 00 61 00 63 00  |n.t.e.n.t...a.c.|
710  74 00 69 00 6f 00 6e 00  2e 00 54 00 54 00 53 00  |t.i.o.n...T.T.S.|
720  5f 00 53 00 45 00 52 00  56 00 49 00 43 00 45 00  |_.S.E.R.V.I.C.E.|
730  00 00 21 00 61 00 6e 00  64 00 72 00 6f 00 69 00  |..!.a.n.d.r.o.i.|
740  64 00 2e 00 73 00 70 00  65 00 65 00 63 00 68 00  |d...s.p.e.e.c.h.|
750  2e 00 52 00 65 00 63 00  6f 00 67 00 6e 00 69 00  |..R.e.c.o.g.n.i.|
760  74 00 69 00 6f 00 6e 00  53 00 65 00 72 00 76 00  |t.i.o.n.S.e.r.v.|
770  69 00 63 00 65 00 00 00  80 01 08 00 3c 00 00 00  |i.c.e.......<...|
780  1b 02 01 01 1c 02 01 01  72 05 01 01 73 05 01 01  |........r...s...|
790  0c 02 01 01 70 02 01 01  03 00 01 01 03 06 01 01  |....p...........|
7a0  01 00 01 01 02 00 01 01  94 05 01 01 00 00 01 01  |................|
7b0  1f 00 01 01 00 01 10 00  18 00 00 00 02 00 00 00  |................|
7c0  ff ff ff ff 0d 00 00 00  0e 00 00 00 02 01 10 00  |................|
7d0  b0 00 00 00 02 00 00 00  ff ff ff ff ff ff ff ff  |................|
7e0  13 00 00 00 14 00 14 00  07 00 00 00 00 00 00 00  |................|
7f0  0e 00 00 00 00 00 00 00  ff ff ff ff 08 00 00 10  |................|
800  01 00 00 00 0e 00 00 00  01 00 00 00 15 00 00 00  |................|
810  08 00 00 03 15 00 00 00  0e 00 00 00 02 00 00 00  |................|
820  ff ff ff ff 08 00 00 10  21 00 00 00 0e 00 00 00  |........!.......|
830  03 00 00 00 16 00 00 00  08 00 00 03 16 00 00 00  |................|
840  ff ff ff ff 10 00 00 00  14 00 00 00 08 00 00 03  |................|
850  14 00 00 00 ff ff ff ff  11 00 00 00 17 00 00 00  |................|
860  08 00 00 10 21 00 00 00  ff ff ff ff 12 00 00 00  |....!...........|
870  16 00 00 00 08 00 00 10  0d 00 00 00 02 01 10 00  |................|
880  4c 00 00 00 07 00 00 00  ff ff ff ff ff ff ff ff  |L...............|
890  18 00 00 00 14 00 14 00  02 00 00 00 00 00 00 00  |................|
8a0  0e 00 00 00 04 00 00 00  ff ff ff ff 08 00 00 10  |................|
8b0  17 00 00 00 0e 00 00 00  05 00 00 00 ff ff ff ff  |................|
8c0  08 00 00 10 1d 00 00 00  03 01 10 00 18 00 00 00  |................|
8d0  08 00 00 00 ff ff ff ff  ff ff ff ff 18 00 00 00  |................|
8e0  02 01 10 00 38 00 00 00  0a 00 00 00 ff ff ff ff  |....8...........|
8f0  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
900  00 00 00 00 0e 00 00 00  06 00 00 00 1a 00 00 00  |................|
910  08 00 00 03 1a 00 00 00  03 01 10 00 18 00 00 00  |................|
920  0c 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
930  02 01 10 00 38 00 00 00  0d 00 00 00 ff ff ff ff  |....8...........|
940  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
950  00 00 00 00 0e 00 00 00  06 00 00 00 1b 00 00 00  |................|
960  08 00 00 03 1b 00 00 00  03 01 10 00 18 00 00 00  |................|
970  0f 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
980  02 01 10 00 38 00 00 00  10 00 00 00 ff ff ff ff  |....8...........|
990  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
9a0  00 00 00 00 0e 00 00 00  06 00 00 00 1c 00 00 00  |................|
9b0  08 00 00 03 1c 00 00 00  03 01 10 00 18 00 00 00  |................|
9c0  12 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
9d0  02 01 10 00 38 00 00 00  13 00 00 00 ff ff ff ff  |....8...........|
9e0  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
9f0  00 00 00 00 0e 00 00 00  06 00 00 00 1d 00 00 00  |................|
a00  08 00 00 03 1d 00 00 00  03 01 10 00 18 00 00 00  |................|
a10  15 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
a20  02 01 10 00 38 00 00 00  16 00 00 00 ff ff ff ff  |....8...........|
a30  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
a40  00 00 00 00 0e 00 00 00  06 00 00 00 1e 00 00 00  |................|
a50  08 00 00 03 1e 00 00 00  03 01 10 00 18 00 00 00  |................|
a60  18 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
a70  02 01 10 00 38 00 00 00  19 00 00 00 ff ff ff ff  |....8...........|
a80  ff ff ff ff 19 00 00 00  14 00 14 00 01 00 00 00  |................|
a90  00 00 00 00 0e 00 00 00  06 00 00 00 1f 00 00 00  |................|
aa0  08 00 00 03 1f 00 00 00  03 01 10 00 18 00 00 00  |................|
ab0  1b 00 00 00 ff ff ff ff  ff ff ff ff 19 00 00 00  |................|
ac0  02 01 10 00 60 00 00 00  1d 00 00 00 ff ff ff ff  |....`...........|
ad0  ff ff ff ff 20 00 00 00  14 00 14 00 03 00 00 00  |.... ...........|
ae0  00 00 00 00 0e 00 00 00  08 00 00 00 21 00 00 00  |............!...|
af0  08 00 00 03 21 00 00 00  0e 00 00 00 09 00 00 00  |....!...........|
b00  ff ff ff ff 08 00 00 01  00 00 02 7f 0e 00 00 00  |................|
b10  07 00 00 00 ff ff ff ff  08 00 00 12 ff ff ff ff  |................|
b20  02 01 10 00 38 00 00 00  21 00 00 00 ff ff ff ff  |....8...!.......|
b30  ff ff ff ff 22 00 00 00  14 00 14 00 01 00 00 00  |...."...........|
b40  00 00 00 00 0e 00 00 00  0a 00 00 00 ff ff ff ff  |................|
b50  08 00 00 12 ff ff ff ff  03 01 10 00 18 00 00 00  |................|
b60  21 00 00 00 ff ff ff ff  ff ff ff ff 22 00 00 00  |!..........."...|
b70  02 01 10 00 74 00 00 00  22 00 00 00 ff ff ff ff  |....t...".......|
b80  ff ff ff ff 23 00 00 00  14 00 14 00 04 00 00 00  |....#...........|
b90  00 00 00 00 0e 00 00 00  0b 00 00 00 ff ff ff ff  |................|
ba0  08 00 00 01 06 00 03 01  0e 00 00 00 08 00 00 00  |................|
bb0  25 00 00 00 08 00 00 03  25 00 00 00 0e 00 00 00  |%.......%.......|
bc0  06 00 00 00 24 00 00 00  08 00 00 03 24 00 00 00  |....$.......$...|
bd0  0e 00 00 00 0c 00 00 00  ff ff ff ff 08 00 00 11  |................|
be0  b0 00 00 00 02 01 10 00  24 00 00 00 27 00 00 00  |........$...'...|
bf0  ff ff ff ff ff ff ff ff  26 00 00 00 14 00 14 00  |........&.......|
c00  00 00 00 00 00 00 00 00  02 01 10 00 38 00 00 00  |............8...|
c10  28 00 00 00 ff ff ff ff  ff ff ff ff 27 00 00 00  |(...........'...|
c20  14 00 14 00 01 00 00 00  00 00 00 00 0e 00 00 00  |................|
c30  06 00 00 00 28 00 00 00  08 00 00 03 28 00 00 00  |....(.......(...|
c40  03 01 10 00 18 00 00 00  29 00 00 00 ff ff ff ff  |........).......|
c50  ff ff ff ff 27 00 00 00  02 01 10 00 38 00 00 00  |....'.......8...|
c60  2a 00 00 00 ff ff ff ff  ff ff ff ff 29 00 00 00  |*...........)...|
c70  14 00 14 00 01 00 00 00  00 00 00 00 0e 00 00 00  |................|
c80  06 00 00 00 2a 00 00 00  08 00 00 03 2a 00 00 00  |....*.......*...|
c90  03 01 10 00 18 00 00 00  2b 00 00 00 ff ff ff ff  |........+.......|
ca0  ff ff ff ff 29 00 00 00  03 01 10 00 18 00 00 00  |....)...........|
cb0  2c 00 00 00 ff ff ff ff  ff ff ff ff 26 00 00 00  |,...........&...|
cc0  03 01 10 00 18 00 00 00  2d 00 00 00 ff ff ff ff  |........-.......|
cd0  ff ff ff ff 23 00 00 00  03 01 10 00 18 00 00 00  |....#...........|
ce0  2f 00 00 00 ff ff ff ff  ff ff ff ff 20 00 00 00  |/........... ...|
cf0  02 01 10 00 24 00 00 00  31 00 00 00 ff ff ff ff  |....$...1.......|
d00  ff ff ff ff 2b 00 00 00  14 00 14 00 00 00 00 00  |....+...........|
d10  00 00 00 00 02 01 10 00  24 00 00 00 32 00 00 00  |........$...2...|
d20  ff ff ff ff ff ff ff ff  2c 00 00 00 14 00 14 00  |........,.......|
d30  00 00 00 00 00 00 00 00  02 01 10 00 38 00 00 00  |............8...|
d40  33 00 00 00 ff ff ff ff  ff ff ff ff 27 00 00 00  |3...........'...|
d50  14 00 14 00 01 00 00 00  00 00 00 00 0e 00 00 00  |................|
d60  06 00 00 00 2d 00 00 00  08 00 00 03 2d 00 00 00  |....-.......-...|
d70  03 01 10 00 18 00 00 00  33 00 00 00 ff ff ff ff  |........3.......|
d80  ff ff ff ff 27 00 00 00  03 01 10 00 18 00 00 00  |....'...........|
d90  34 00 00 00 ff ff ff ff  ff ff ff ff 2c 00 00 00  |4...........,...|
da0  02 01 10 00 24 00 00 00  35 00 00 00 ff ff ff ff  |....$...5.......|
db0  ff ff ff ff 2c 00 00 00  14 00 14 00 00 00 00 00  |....,...........|
dc0  00 00 00 00 02 01 10 00  38 00 00 00 36 00 00 00  |........8...6...|
dd0  ff ff ff ff ff ff ff ff  27 00 00 00 14 00 14 00  |........'.......|
de0  01 00 00 00 00 00 00 00  0e 00 00 00 06 00 00 00  |................|
df0  2e 00 00 00 08 00 00 03  2e 00 00 00 03 01 10 00  |................|
e00  18 00 00 00 36 00 00 00  ff ff ff ff ff ff ff ff  |....6...........|
e10  27 00 00 00 03 01 10 00  18 00 00 00 37 00 00 00  |'...........7...|
e20  ff ff ff ff ff ff ff ff  2c 00 00 00 03 01 10 00  |........,.......|
e30  18 00 00 00 38 00 00 00  ff ff ff ff ff ff ff ff  |....8...........|
e40  2b 00 00 00 03 01 10 00  18 00 00 00 3a 00 00 00  |+...........:...|
e50  ff ff ff ff ff ff ff ff  13 00 00 00 01 01 10 00  |................|
e60  18 00 00 00 3a 00 00 00  ff ff ff ff 0d 00 00 00  |....:...........|
e70  0e 00 00 00                                       |....|
e74
#+END_SRC

* 11.07.2024

dzisiaj bysmy chcieli:
- zakodowac wygenerowany pkik AndroidManifest.xml do postaci binarnej
- dodac go do pliku apk

* 10.07.2024

#+BEGIN_SRC
public abstract void setInput (InputStream inputStream, 
                String inputEncoding="UTF8")
#+END_SRC

No dobra, to teraz plan jest mniej wiecej taki, ze bysmy chcieli:
- wygenerowac zawartosc pliku AndroidManifest.xml (jako string)
- przekazac go jako strumien do XmlPullParsera
- zakodowac go do postaci binarnej za pomoca xml2axml


* 09.07.2024

No to tak. Stary plik arsc:

#+BEGIN_SRC
0000  02 00 0c 00 54 02 00 00  01 00 00 00 01 00 1c 00  |....T...........| #x254 = 596
0010  3c 00 00 00 01 00 00 00  00 00 00 00 00 01 00 00  |<...............| #x3c = 60
0020  20 00 00 00 00 00 00 00  00 00 00 00 16 16 72 65  | .............re| #x16 = 22
0030  73 2f 64 72 61 77 61 62  6c 65 2f 67 72 61 73 70  |s/drawable/grasp|
0040  2e 70 6e 67 00 00 00 00  00 02 20 01 0c 02 00 00  |.png...... .....| 5 zer, 02 20 01 0c 02 00 00 7f 00 00 00
0050  7f 00 00 00 69 00 6f 00  2e 00 67 00 69 00 74 00  |....i.o...g.i.t.| io.github.grasp (2x15), po nich same zera
0060  68 00 75 00 62 00 2e 00  67 00 72 00 61 00 73 00  |h.u.b...g.r.a.s.|
0070  70 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |p...............|
0080  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
0150  00 00 00 00 20 01 00 00  02 00 00 00 58 01 00 00  |.... .......X...|
0160  01 00 00 00 00 00 00 00  01 00 1c 00 38 00 00 00  |............8...|
0170  02 00 00 00 00 00 00 00  00 01 00 00 24 00 00 00  |............$...|
0180  00 00 00 00 00 00 00 00  07 00 00 00 04 04 61 74  |..............at|
0190  74 72 00 08 08 64 72 61  77 61 62 6c 65 00 00 00  |tr...drawable...|
01a0  01 00 1c 00 28 00 00 00  01 00 00 00 00 00 00 00  |....(...........|
01b0  00 01 00 00 20 00 00 00  00 00 00 00 00 00 00 00  |.... ...........|
01c0  05 05 67 72 61 73 70 00  02 02 10 00 10 00 00 00  |..grasp.........|
01d0  01 00 00 00 00 00 00 00  02 02 10 00 14 00 00 00  |................|
01e0  02 00 00 00 01 00 00 00  00 00 00 00 01 02 54 00  |..............T.|
01f0  68 00 00 00 02 00 00 00  01 00 00 00 58 00 00 00  |h...........X...|
0200  40 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |@...............|
0210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
0240  00 00 00 00 08 00 00 00  00 00 00 00 08 00 00 03  |................|
0250  00 00 00 00                                       |....|
0254
#+END_SRC

nowy plik arsc:

#+BEGIN_SRC
0000  02 00 0c 00 50 02 00 00  01 00 00 00 01 00 1c 00  |....P...........| #x250 = 592
0010  38 00 00 00 01 00 00 00  00 00 00 00 00 01 00 00  |8...............| #x38 = 56
0020  20 00 00 00 00 00 00 00  00 00 00 00 15 15 72 65  | .............re| #x15 = 21
0030  73 2f 64 72 61 77 61 62  6c 65 2f 69 63 6f 6e 2e  |s/drawable/icon.|
0040  70 6e 67 00 00 02 20 01  0c 02 00 00 7f 00 00 00  |png... .........| 2 zera, 02 20 01 0c 02 00 00 7f 00 00 00
0050  73 00 79 00 73 00 74 00  65 00 6d 00 73 00 2e 00  |s.y.s.t.e.m.s...| systems.grasp (2x13), po nich same zera
0060  67 00 72 00 61 00 73 00  70 00 00 00 00 00 00 00  |g.r.a.s.p.......|
0070  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
0150  20 01 00 00 02 00 00 00  58 01 00 00 01 00 00 00  | .......X.......|
0160  00 00 00 00 01 00 1c 00  38 00 00 00 02 00 00 00  |........8.......|
0170  00 00 00 00 00 01 00 00  24 00 00 00 00 00 00 00  |........$.......|
0180  00 00 00 00 07 00 00 00  04 04 61 74 74 72 00 08  |..........attr..|
0190  08 64 72 61 77 61 62 6c  65 00 00 00 01 00 1c 00  |.drawable.......|
01a0  28 00 00 00 01 00 00 00  00 00 00 00 00 01 00 00  |(...............|
01b0  20 00 00 00 00 00 00 00  00 00 00 00 04 04 69 63  | .............ic|
01c0  6f 6e 00 00 02 02 10 00  10 00 00 00 01 00 00 00  |on..............|
01d0  00 00 00 00 02 02 10 00  14 00 00 00 02 00 00 00  |................|
01e0  01 00 00 00 00 00 00 00  01 02 54 00 68 00 00 00  |..........T.h...|
01f0  02 00 00 00 01 00 00 00  58 00 00 00 40 00 00 00  |........X...@...|
0200  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
0240  08 00 00 00 00 00 00 00  08 00 00 03 00 00 00 00  |................|
0250
#+END_SRC

i teraz tak:
grasp - 5 znakow
icon - 4 znaki

io.github.grasp - 15 znakow
systems.grasp - 12 znakow

No dobra,  to teraz plan jest taki - poniewaz najwidoczniej
w plikach arsc bedzie sie nam zmieniala tylko nazwa pakietu
- zebysmy sprobowali kilka roznych nazw, zaczynajac od a,
  ab, abc, abcd, abcde, abcdef, abcdefg, abcdefgh, abcdefghi
  i tak dalej, i nastepnie wysnujmy hipoteze o strukturze,
  i zwalidujmy ja dla dluzszych przykladow.

Przy okazji zapamietajmy sobie pliki .xml, i dla nich
rowniez podobna analize.

No dobra, pliki xml sprobujemy wygenerowac narzedziem xml2axml
(bo jest javowe)

Natomiast jezeli idzie o resources.arsc, to najpierw mamy

#+BEGIN_SRC
000  02 00 0c 00 50 02 00 00  01 00 00 00 01 00 1c 00  |....P...........|
010  38 00 00 00 01 00 00 00  00 00 00 00 00 01 00 00  |8...............|
020  20 00 00 00 00 00 00 00  00 00 00 00 15 15 72 65  | .............re|
030  73 2f 64 72 61 77 61 62  6c 65 2f 69 63 6f 6e 2e  |s/drawable/icon.|
040  70 6e 67 00 00 02 20 01  0c 02 00 00 7f 00 00 00  |png... .........|
#+END_SRC

pozniej 256-bajtowy blok rozpoczynajacy sie od nazwy pakietu
w utf-16 (czyli starsze bajty to zera) a potem

#+BEGIN_SRC
150  20 01 00 00 02 00 00 00  58 01 00 00 01 00 00 00  | .......X.......|
160  00 00 00 00 01 00 1c 00  38 00 00 00 02 00 00 00  |........8.......|
170  00 00 00 00 00 01 00 00  24 00 00 00 00 00 00 00  |........$.......|
180  00 00 00 00 07 00 00 00  04 04 61 74 74 72 00 08  |..........attr..|
190  08 64 72 61 77 61 62 6c  65 00 00 00 01 00 1c 00  |.drawable.......|
1a0  28 00 00 00 01 00 00 00  00 00 00 00 00 01 00 00  |(...............|
1b0  20 00 00 00 00 00 00 00  00 00 00 00 04 04 69 63  | .............ic|
1c0  6f 6e 00 00 02 02 10 00  10 00 00 00 01 00 00 00  |on..............|
1d0  00 00 00 00 02 02 10 00  14 00 00 00 02 00 00 00  |................|
1e0  01 00 00 00 00 00 00 00  01 02 54 00 68 00 00 00  |..........T.h...|
1f0  02 00 00 00 01 00 00 00  58 00 00 00 40 00 00 00  |........X...@...|
200  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
220  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
230  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
240  08 00 00 00 00 00 00 00  08 00 00 03 00 00 00 00  |................|
250
#+END_SRC


* 08.07.2024

zanotujmy sobie info o strukturze AndroidManifest.xml:
- package - dowolny ale musi byc zgodny z tym co podajemy
  przy kompilacji
- application android:label - dowolny, wyswietla sie przy informacjach
  o aplikacji
- activity android.name - musi byc .GRASP
- activity android:label - dowolny, wyswietla sie
  przy ikonce launchera, najlepiej zeby byl taki sam jak
  application android:label

dalsza kwestia - podczas budowy powinnismy sobie zapamietywac
w pliku build/cache/android-package-name nazwe pakietu,
ktorej ostatnio uzylismy przy budowie. na tej podstawie
moglibysmy kasowac cache przy budowaniu kolejnej wersji.

no to wyglada na to, ze:
- android.arsc zalezy tylko od nazwy pakietu i nazwy ikony
  (do zweryfikowania czy tez od zawartosci ikony)
- musimy rozkminic binarny format manifestu

* 07.07.2024

zacznijmy od nazwy aplikacji i pakietu.

plan bylby taki, zeby:
- zrobic AndroidManifest.xml z inna nazwa pakietu i aplikacji
- wygenerowac .apk dla takiego czegos
- wyodrebnic z nich pkiki AndroidManifest.xml oraz
  resources.arsc
- na podstawie analizy napisac wlasny generator
  plikow AndroidManifest.xml i resources.arsc
- uzyc tego generatora do wygenerowania plikow zgodnych z nazwa
  pakietu i aplikacji


* 06.07.2024

no dobra, czyli tak: pliki dex bedzie mozna cache'owac

to teraz bysmy chcieli, zeby skrypt do budowania:
- jezeli zmienil sie tylko plik init.scm, to zeby tylko
  podmienial ten skrypt
- zeby mozna sobie bylo wybrac targety (desktop, android, terminal)
- zeby mozna bylo podac nazwe aplikacji i pakietu
- zeby mozna bylo podac ikone

* 05.07.2024

byc moze bedziemy musieli pozegnac nasze marzenia
z cache'owaniem plikow 'dex'?

na razie sprobujmy zbudowac classes.dex bez kroku posredniego

* 04.07.2024

zaleznosci ogarniete wraz z mala refaktoryzacja, ale
klawiayura nadal nie dziala

to by trzeba zdiagnozowac

* 03.07.2024
no to co dzis robimy?
- zaleznosci w buildzie androidowym
- idempotencja procesu budowania
- a w kolejnym kroku bysmy zrobili moze podmianki
  ikonek, zmiane nazwy pakietu i wybor uprawnien
  (co bedzie wymagalo generowania plikow resources.arsc
  oraz binarnego AndroidManifest.xml)

No, to teraz co do tego pierwszego podpuntku, wydaje sie
ze bedzie potrzebna refaktoryzacja: chodzi o to, ze
folder z nazwa pakietu oraz glownej klasy budujemy
przed dexowaniem, i zasadniczo powinnismy budowac
do osobnego folderu (np. =android-cache=).

Hmm, a moze potrzebujemy /refleksji/ nad tym, jak ten system
dziala w tej chwili? (Bo ostatecznie trzeba bedzie wymyslic
cos z tym androidem?)

Moze jednak na razie zacznijmy lepiej od tych zaleznosci


* 02.07.2024

rzeczy najpilniejsze:
- dlaczego w nowym buildzie nie dziala keymap?
- chcemy naprawde generowac apk
- i raczej uzywac plikow posrednich

to sa te pierwsze rzeczy. kolejna rzecz to parametryzacja
builda androidowego:
- plikiem init
- ikona
- nazwa pakietu

chcemy tez, zeby skrypt byl idempotentny ze wzgledu na classes.dex
i zeby - jezeli classes.dex, grasp-desktop.jar i grasp-terminal.jar
sa nowsze od pkikow zrodlowych - nie dokonywac rekompikacji,
tylko budowac zipy od nowa

no, na razie hipoteza jest taka, ze problem bierze sie stad,
ze mamy wiecej niz jedna instancje initialize-keymap, i powinnismy
wylaczyc z dexowania terminal-keymap i desktop-keymap, albo
mowiac konktetniej - dexowac pliki zgodnie z zaleznosciami

ale najpierw: zrobmy tak, zeby alignment odbywal sie
na plikach posrednich.

ok, to juz mamy. co dalej?


* 01.07.2024

to bysmy zrobili mniej wiecej takie rzeczy:
1. podmienili AndroidManifest na binarny i sprobowali zainstalowac
2. ewentualnie podejrzeli jak aapt generuje binarne xmle
3. zmienili nazwe grasp.png na icon.png (ewentualnie cos pokombinowali
   i poczytali o formatach ikon)
4. jezeli to zadziaka, to bysmy sparametryzowali build androidowy
   nazwa pakietu i plikiem z ikona
   (bysmy sprobowali wygenerowac kilka roznych nazw pakietow
   i podejrzeli roznice binarne)

no dobra, to ten plik chyba nie dziala

ok, teraz juz dziala!

no to bysmy zrobili takie testy:
- zmienili 'grasp.png' na 'icon.png'

Trzeba jeszcze cos wymyslic z tym keytoolem  


* 28.06.2024

jakue sa nasze oczekiwania?
1. nadawanie dowolnej nazwy plikowi apk
2. wybor pliku init
3. generowanie tlustej apk (umiejacej generowac apk)
4. generowanie uber apk (generujacej tluste apk)
5. generowanie plikow apk/jar na podstawie widgetu
- tlusty .apk powinien zawierac zrodla GRASPa

No ale problemy mamy zasadniczo takie:
- resources.arsc
- key store
- i to ze nam nie dziala to co teraz mamy
   
* 25.06.2024

co bysmy zrobili:
- mamy juz kompilowanie plikow .dex
- teraz chcemy wziac te wszystkie pliki i zbudowac z nich plik
  classes.dex
- a jak to bedziemy mieli, to mozemy NA RAZIE wywolac shell,
  zeby stworzyc plik apk i dodac do niego classes.dex



* 24.06.2024

No dobra, to teraz w zasadxie mamy kilka drog do sprawdzenia.

po pierwsze, mozemy sprobowac wybudowac androidowego klienta
tym co juz mamy

po drugie mozemy sprobowac zrobic tak, zeby te pliki .dex
sie regenerowaly zgodnie z zaleznosciami

i moze od tego bysmy zaczeli?

tylko tak: zaleznosci musimy przebudowywac albo wtedy,
gdy plik .dex jedt starszy od odpowiadajecego mu pliku .class,
albo gdy nie istnieje

tylko pytanie, co z tymi plikami androidowymi


* 21.06.2024

co sie dzieje, gdy wywolujemy d8?

oto fragmenty r8/src/main/java/com/android/tools/r8/D8.java

#+begin_src java
    D8Command command = D8Command.parse(args, CommandLineOrigin.INSTANCE).build();
    if (command.isPrintHelp()) {
	//...
    }
    InternalOptions options = command.getInternalOptions();
    AndroidApp app = command.getInputApp();
    ExecutorService executor = ThreadUtils.getExecutorService(options);
    run(app, options, executor);

  
  com.android.tools.r8.D8:run(D8Command.builder()
	  .addProgramFiles(inputPathA, inputPathB)
	  .setOutput(outputPath, OutputMode.DexIndexed)
	  .build());


#+end_src

com.android.tools.r8.D8:run

#+begin_src scheme

  (define (dex input::java.io.File output::java.io.File)::void
    (let* ((command ::com.android.tools.r8.D8Command.Builder
		    (com.android.tools.r8.D8Command:builder))
	   (command (command:addProgramFiles (input:toPath)))
	   (command (command:setOutput (output:toPath))))
      (com.android.tools.r8.D8:run
       (command:build)
       (com.android.tools.r8.OutputMode:DexFilePerClass))))

#+end_src


Cos tam pomalu zaczyna nam dzialac. Problem jest jednak taki, ze
inkrementalne dexowannie nie dziala. Byc moze daloby aie tak
zorkiestrowac caly proces, zeby zadzialalo, gdyby budowac moduly
zgodnie z ich kolejnoscia w grafie zaleznosci?



* 20.06.2024

czyli takie cos:

#+begin_src scheme
  (define (build-file source ::string target-directory ::string)
    (let* ((messages ::gnu.text.SourceMessages
		     (gnu.text.SourceMessages))
	   (parse-options ::int (+ gnu.expr.Language:PARSE_PROLOG
				   gnu.expr.Language:PARSE_EXPLICIT))
	   (language ::gnu.expr.Language
		     (gnu.expr.Language:getDefaultLanguage))
	   (module-manager ::gnu.expr.ModuleManager
			   (gnu.expr.ModuleManager:getInstance))
	   (module-info ::gnu.expr.ModuleInfo
			(module-manager:findWithSourcePath source))
	   (input ::gnu.kawa.io.InPort
		  (open-input-file source)))
      (module-manager:setCompilationDirectory target-directory)
      (let ((compilation ::gnu.expr.Compilation
			 (language:parse input messages
					 parse-options
					 module-info)))
	(if (messages:seenErrors)
	    (primitive-throw (gnu.text.SyntaxException messages)))
	(module-info:loadByStages gnu.expr.Compilation:CLASS_WRITTEN)
	(if (messages:seenErrors)
	    (primitive-throw (gnu.text.SyntaxException messages))))))
#+end_src

no i to sie wydaje z grubsza dzialac.

i teraz plan jest taki, zeby dodac opcjonalne parametry
package oraz top-class

nastepnie zeby generowac pliki .dex z plikow .class
(bazujac na zrodlach d8)

nastepnie zeby generowac AndroidManifest.xml i dodawac go
do pliku .apk

na razie nie wiemy, co z tym resources.arsc

ale jeszcze bysmy chcieli alignowac i podpisywac ten plik apkignerem
i zipalignem, rowniez ze zrodel.

Chcielibysmy moc generowac dwa warianty aplikacji:
pierwszy jak do tej pory, a drugi zawierajacy apksigner,
zipalign i d8


* 19.06.2024

jak na razie rzecz wyglada nastepujaco, ze;
- javowy zipalign wydaje sie dzialac
- apksigner tez jest javowy

Musimy tylko rozkminic co wyczynia ten aapt.

Ale na razie mozemy sprobowac takie cos, zeby:
1. zbudowac grasp-android tak-jakby byly ustawione
   opcje -P <nazwa-pakietu> -T <nazwa-pakietu>.GRASP
2. wygenerowac odpowiedni AndroidManifest.xml
3. zregenerowac odpowiednie pliki .dex
4. zbudowac plik classes.dex
5. wygenerowac plik .apk i dodac do niego manifest,
   classes.dex, res
6. wyalignowac plik .apk
7. podpisac plik .apk

Domyslna nazwa pakietu do tej pory to io.github.graap.

To zobaczmy najpierw w kodach Kawy co robia argumenty
-P i -T

jezeli idzie o -T, to ustawia wartosc zmiennej compilationTopname,
ktora nastepnie jest w taki sposob uzyta:

#+begin_src java
  ModuleInfo minfo = manager.findWithSourcePath(arg);

  if (compilationTopname != null) {
      String cname
	  = Mangling.mangleNameIfNeeded(compilationTopname);
      if (Compilation.classPrefixDefault != null)
	  cname = Compilation.classPrefixDefault + cname;
      minfo.setClassName(cname);
  }

  comp = language.parse(fstream, messages,
			defaultParseOptions, minfo);
#+end_src

Jezeli zas idzie o flage -P, to ona z kolei ustawia wartosc
Compilation.classPrefixDefault.

No to plan na razie bylby z grubsza taki, zeby stworzyc
swoja wlasna implementacje com[ile-file, baxujaca na oryginalnej
wersji.

Mozemy tez sprobowac stworzyc implementacje bazujaca na
wywolaniach w Kawie:

#+begin_src java
  minfo.loadByStages(Compilation.CLASS_WRITTEN);
#+end_src

bo w schemie to tak wyglada

#+begin_src scheme
  (define (build-file source ::string output ::String)
    ::void
    (let* ((messages ::gnu.text.SourceMessages
		     (gnu.text.SourceMessages))
	   (comp ::gnu.expr.Compilation
		 (kawa.lang.CompileFile:read (source:toString)
					     messages)))
      (set! comp:explicit #t)
      (if (messages:seenErrors)
	  (primitive-throw (gnu.text.SyntaxException messages)))
      (comp:compileToArchive (comp:getModule) output)
      (if (messages:seenErrors)
	  (primitive-throw (gnu.text.SyntaxException messages)))))
#+end_src

* 17.06.2024

No to czas na pare eksperymentow z buildami:
- zamiana kolejnosci podpisywania z zipalignem
- wywalenie z apk katalogu resources.arsc

* 16.06.2024

na razie rownolegle sobie zaczniemy pisac pejper na
ICFP, ale tak poza tym to:
- musimy rozkminic dzialanie skryptu budujacego apk
- zaimplementowac to samo po stronie naszego skryptu

#+begin_src sh

  java -cp tools/d8.jar com.android.tools.r8.D8 \
       --min-api 23 --lib libs/android.jar \
       `find build/android/obj -name '*.class'` libs/kawa.dex \
       libs/androidsvg-1.4.dex

  aapt package -I tools/android.jar -f \
       -M AndroidManifest.xml \
       -S res \
       -A assets \
       -F build/android/bin/"$PKGNAME.apk"

  aapt add -f "$PKGNAME.apk" classes.dex

  zipalign -p 4 "$PKGNAME.apk" "aligned-$PKGNAME.apk"

  if [ ! -s ~/pland.keystore ]; then
      keytool -genkey -v -keystore ~/pland.keystore \
	      -alias pland -keyalg RSA -keysize 2048 -validity 10000
  fi

java -jar ../../../tools/apksigner.jar sign --ks ~/pland.keystore \
	  --ks-key-alias pland --ks-pass pass:quack01 \
     "aligned-$PKGNAME.apk"

#+end_src


No to po kolei:
- musimy znalezc sposob, zeby z plikow .class budowac
  pliki .dex
- musimy tez sie dowiedziec, co robi aapt

* 15.06.2024

sledzenie zaleznosci z pliku include juz dziala. co nam teraz
pozostaje:
- budowanie grasp-terminal.jar
- parametryzacja skryptu
  - plik init
  - nazwa pliku wyjsciowego
  - pomijanie niektorych targetow
  - budowanie wersji androidowej
    (w tym generowanie manifestu)

to tak: terminal juz sie buduje (choc na razie
bardziej szeregowo, niz rownolegle), natomiast
chcialoby sie tez budowac klienta androidowego

* 14.06.2024

jeszcze mamy taki problem,ze przy pierwszym wybudowaniu
pliki .class nie sa wrzucane do archiwum.

ok, to juz sie chyba udalo rozwiazac.

I CO TERAZ?

Teraz mamy kilka opcji:
- zajac sie budowaniem grasp-terminal.jar
- dodac zaleznosci pliku init do pozostalych zaleznosci
- dokonac paralelizacji buildow (co nie powinno byc
  trudne, zwazywszy na to, ze mamy warstwy, ktore teraz
  splaszczamy)

W dalszej kolejnosci bedziemy musieli sie zajac klientem
androidowym, co wydaje sie o tyle klopotliwe, ze bedzie
trzeba zintegrowac interfejsy narzedzi takich, jak aapt
czy r8/d8 oraz zipalign i apksigner.

Ale damy rade!

No ale zajmijmy sie jeszcze tym wspolbieznym przetwarzaniem.
To by moglo jakos tak wygladac:

#+begin_src scheme

  (define (par-for-each function collection)
    (let* ((items ::int (length collection))
	   (runtime (java.lang.Runtime:getRuntime))
	   (processors ::int (max 1 (runtime:availableProcessors)))
	   (2*processors ::int (* 2 processors)))
      (if (is items <= 2*processors) ;>
	  (let ((workers ::java.utils.List
			 (java.utils.ArrayList items)))
	    (for-each (lambda (x)
			(workers:add (future (function x))))
		      collection)
	    (for-each (lambda (f)
			(force f))
		      workers)
	    (workers:clear))
	  (let* ((workers ::java.utils.List
			  (java.utils.ArrayList 2*processors))
		 (queue ...))
	    (for-each (lambda (x)
			(if (is i 


	    (for i from 0 below 2*processors
		 (set! (workers i)
		       (future
			(begin
			  (function (collection 
#+end_src

no dobra, przetwarzanie zrownoleglone juz jako tako dziala.

w przyszlosci dobrze by bylo zrobic jakis madrzejszy
algorytm, uwzgledniajacy liczbe dostepnych rdzeni, w taki
sposob, ze alokujemy tablice watkow, i watek glowny
- gdy te pozostale skoncza prace - dorzucalby kolejne.

  zeby to jednak mialo szanse dzialac, potrzebna bylaby kolejka
  z indeksami: po zakonczeniu pracy kazdy watek dorzucalby
  swoj indeks do kolejki, i watek glowny moglby tworzyc
  kolejne watki

do tego chcielibysmy tak sobie zorganizowac zakeznosci miedzy
modulami, zeby zmaksymalizowac paralelizacje

no ale na razie zostawmy to gdzies na boku - temat ciekawy,
ale na razie niezbyt pilny

to co teraz? najwazniejsze to chyba zaleznosci z pliku init.scm.

* 13.06.2024

generowanie grasp-desktop.jar juz dziala. Teraz:
- to samo dla terminala
- analogicznie dla Androida
- parametryzacja skryptu (wybor pliku init i nazwy aplikacji,
  pomijanie ktoregos z targetow)

* 12.06.2024

Zacznijmy moze od tego, zeby wypisac sobie wszystkie
zaleznosci modulu grasp-desktop.scm na konsole.

#+begin_src java

import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.util.Enumeration;
import java.util.zip.ZipEntry;
import java.util.zip.ZipFile;
import java.util.zip.ZipOutputStream;

public class Main {

    // 4MB buffer
    private static final byte[] BUFFER = new byte[4096 * 1024];

    /**
     * copy input to output stream - available in several StreamUtils or Streams classes 
     */    
    public static void copy(InputStream input, OutputStream output) throws IOException {
        int bytesRead;
        while ((bytesRead = input.read(BUFFER))!= -1) {
            output.write(BUFFER, 0, bytesRead);
        }
    }

    public static void main(String[] args) throws Exception {
        // read war.zip and write to append.zip
        ZipFile war = new ZipFile("war.zip");
        ZipOutputStream append = new ZipOutputStream(new FileOutputStream("append.zip"));

        // first, copy contents from existing war
        Enumeration<? extends ZipEntry> entries = war.entries();
        while (entries.hasMoreElements()) {
            ZipEntry e = entries.nextElement();
            System.out.println("copy: " + e.getName());
            append.putNextEntry(e);
            if (!e.isDirectory()) {
                copy(war.getInputStream(e), append);
            }
            append.closeEntry();
        }

        // now append some extra content
        ZipEntry e = new ZipEntry("answer.txt");
        System.out.println("append: " + e.getName());
        append.putNextEntry(e);
        append.write("42\n".getBytes());
        append.closeEntry();

        // close
        war.close();
        append.close();
    }
}

#+end_src

* 11.06.2024

no to tak:
- po zbudowaniu wszystkich modulow powinnismy
  stworzyc nowe archiwum - grasp-desktop.jar
  - i dodac do niego najpierw wsxystkie pliki
    z grasp-desktop.zip, nastepnie wszystkie
    zaleznosci modulu "grasp-desktop.scm"
    z katalogu "build/cache", a wreszcie
    wsztstkie (rozpakowane wczesniej?) zaleznosci.

  - stworzyc plik manifestu, i jego takze dodac
    
* 10.06.2024

dzis moze by sie udalo zbudowac grasp-desktop.jar

zaleta jest taka, ze moze uda sie to w taki sposob
zrobic, ze nie bedzie trzeba nadmiernie kopiowac
plikow

#+begin_src java
public class ZipMultipleFiles {

    public static void main(String[] args) throws IOException {
        String file1 = "src/main/resources/zipTest/test1.txt";
        String file2 = "src/main/resources/zipTest/test2.txt";
        final List<String> srcFiles = Arrays.asList(file1, file2);

        final FileOutputStream fos = new FileOutputStream(Paths.get(file1).getParent().toAbsolutePath() + "/compressed.zip");
        ZipOutputStream zipOut = new ZipOutputStream(fos);

        for (String srcFile : srcFiles) {
            File fileToZip = new File(srcFile);
            FileInputStream fis = new FileInputStream(fileToZip);
            ZipEntry zipEntry = new ZipEntry(fileToZip.getName());
            zipOut.putNextEntry(zipEntry);

            byte[] bytes = new byte[1024];
            int length;//<
            while((length = fis.read(bytes)) >= 0) {
                zipOut.write(bytes, 0, length);
            }
            fis.close();
        }

        zipOut.close();
        fos.close();
    }
}
#+end_src

* 09.06.2024

warto mniej wiecej pomyslec nad mozliwymi opcjami naszego skryptu:
--android=no[/yes], --terminal=no[/yes], --desktop=no[/yes]
(w szczegolnosci ta pierwsza powodowalaby pominiecie budowania
plikow .dex), --init=..., --app-name=..., --icon=...

Chcielibysmy tez popakowac rozne funkcje uzywane przez skrypt
budujacy w module - (utils graph), (utils files) i ewentualnie
(utils build) - zeby kiedys w przyszlosci moc wykonywac buildy
z wnetrza aplikacji (w szczegolnosci tej androidowej)


No dobra, to wydaje sie, ze jeszcze trzeba zrobic cos takiego, zeby
po zbudowaniu listy plikow .class do skasowania uzupelnic je o
ich zaleznosci

* 08.06.2024

Dzis bysmy sprobowali wydobyc atrybut SourceFile z plikow .class.

#+begin_src

000  ca fe ba be 00 00 00 31  00 0c 01 00 13 65 64 69  |.......1.....edi|
010  74 6f 72 2f 4f 77 6e 43  6c 69 70 62 6f 61 72 64  |tor/OwnClipboard|
020  07 00 01 01 00 10 6a 61  76 61 2f 6c 61 6e 67 2f  |......java/lang/|
030  4f 62 6a 65 63 74 07 00  03 01 00 19 65 64 69 74  |Object......edit|
040  6f 72 2f 64 6f 63 75 6d  65 6e 74 2f 43 6c 69 70  |or/document/Clip|
050  62 6f 61 72 64 07 00 05  01 00 24 6a 61 76 61 2f  |board.....$java/|
060  61 77 74 2f 64 61 74 61  74 72 61 6e 73 66 65 72  |awt/datatransfer|
070  2f 43 6c 69 70 62 6f 61  72 64 4f 77 6e 65 72 07  |/ClipboardOwner.|
080  00 07 01 00 0a 53 6f 75  72 63 65 46 69 6c 65 01  |.....SourceFile.|
090  00 11 61 77 74 2d 63 6c  69 70 62 6f 61 72 64 2e  |..awt-clipboard.|
0a0  73 63 6d 01 00 14 53 6f  75 72 63 65 44 65 62 75  |scm...SourceDebu|
0b0  67 45 78 74 65 6e 73 69  6f 6e 06 01 00 02 00 04  |gExtension......|
0c0  00 02 00 06 00 08 00 00  00 00 00 02 00 09 00 00  |................|
0d0  00 02 00 0a 00 0b 00 00  00 61 53 4d 41 50 0a 61  |.........aSMAP.a|
0e0  77 74 2d 63 6c 69 70 62  6f 61 72 64 2e 73 63 6d  |wt-clipboard.scm|
0f0  0a 53 63 68 65 6d 65 0a  2a 53 20 53 63 68 65 6d  |.Scheme.*S Schem|
100  65 0a 2a 46 0a 2b 20 31  20 61 77 74 2d 63 6c 69  |e.*F.+ 1 awt-cli|
110  70 62 6f 61 72 64 2e 73  63 6d 0a 73 72 63 2f 65  |pboard.scm.src/e|
120  64 69 74 6f 72 2f 61 77  74 2d 63 6c 69 70 62 6f  |ditor/awt-clipbo|
130  61 72 64 2e 73 63 6d 0a  2a 45 0a                 |ard.scm.*E.|

#+end_src

#+begin_src scheme
"\xca\xfe\xba\xbe\x00\x00\x00\x31\x00\x0c\x01\x00\x13\x65\x64\x69\
\x74\x6f\x72\x2f\x4f\x77\x6e\x43\x6c\x69\x70\x62\x6f\x61\x72\x64\
\x07\x00\x01\x01\x00\x10\x6a\x61\x76\x61\x2f\x6c\x61\x6e\x67\x2f\
\x4f\x62\x6a\x65\x63\x74\x07\x00\x03\x01\x00\x19\x65\x64\x69\x74\
\x6f\x72\x2f\x64\x6f\x63\x75\x6d\x65\x6e\x74\x2f\x43\x6c\x69\x70\
\x62\x6f\x61\x72\x64\x07\x00\x05\x01\x00\x24\x6a\x61\x76\x61\x2f\
\x61\x77\x74\x2f\x64\x61\x74\x61\x74\x72\x61\x6e\x73\x66\x65\x72\
\x2f\x43\x6c\x69\x70\x62\x6f\x61\x72\x64\x4f\x77\x6e\x65\x72\x07\
\x00\x07\x01\x00\x0a\x53\x6f\x75\x72\x63\x65\x46\x69\x6c\x65\x01\
\x00\x11\x61\x77\x74\x2d\x63\x6c\x69\x70\x62\x6f\x61\x72\x64\x2e\
\x73\x63\x6d\x01\x00\x14\x53\x6f\x75\x72\x63\x65\x44\x65\x62\x75\
\x67\x45\x78\x74\x65\x6e\x73\x69\x6f\x6e\x06\x01\x00\x02\x00\x04\
\x00\x02\x00\x06\x00\x08\x00\x00\x00\x00\x00\x02\x00\x09\x00\x00\
\x00\x02\x00\x0a\x00\x0b\x00\x00\x00\x61\x53\x4d\x41\x50\x0a\x61\
\x77\x74\x2d\x63\x6c\x69\x70\x62\x6f\x61\x72\x64\x2e\x73\x63\x6d\
\x0a\x53\x63\x68\x65\x6d\x65\x0a\x2a\x53\x20\x53\x63\x68\x65\x6d\
\x65\x0a\x2a\x46\x0a\x2b\x20\x31\x20\x61\x77\x74\x2d\x63\x6c\x69\
\x70\x62\x6f\x61\x72\x64\x2e\x73\x63\x6d\x0a\x73\x72\x63\x2f\x65\
\x64\x69\x74\x6f\x72\x2f\x61\x77\x74\x2d\x63\x6c\x69\x70\x62\x6f\
\x61\x72\x64\x2e\x73\x63\x6d\x0a\x2a\x45\x0a"
#+end_src

No dobra, sie udalo wydobyc te nazwe pliku. Wydaje sie, ze
w jakiejs mierze to pomoglo, ale jeszcze nie calkiem.

Tym niemniej, nie oczekuje, ze uda mi sie ten problem rozwiazac
samodzielnie.

Dlatego co chcielibysmy zrobic dalej?
- wybudowac klienta terminalowego
- wybudowac klienta desktopowego
- zaimplementowac zaleznosci do zbudowania plikow .dex na podstawie
  plikow .class
- wybudowac klienta androidowego (z generowaniem android manifest)


* 07.06.2024

Tematy na radarze:
- odczytywanie pliku zrodlowego z modulow .class,
  ktorych nie rozpoznajemy po nazwie
- dexowanie plikow .class (za pomoca funkcji z d8.jar,
  ktorego to tez bysmy chcieli przedexowac)

dexowanie d8 byloby jednak potrzebne tylko do
wersji pro aplikacji. Z drugiej strony skrypt do budowania
powinien sam generowac AndroidManifest oraz wybrana
nazwe dla projektu.

#+begin_src scheme
  (define-alias ClassFile com.sun.tools.classfile.ClassFile)
  (define-alias ClassAttribute com.sun.tools.classfile.Attribute)
  (define-alias SourceFileAttribute
    com.sun.tools.classfile.SourceFile_attribute)
  ;;(define-alias ClassConstants com.sun.tools.classfile.ConstantPool)


  (and-let* ((classfile ::ClassFile (ClassFile:read file))
	     (attribute ::SourceFileAttribute (classfile:getAttribute
					       ClassAttribute:SourceFile)))
    (attribute:getSourceFile classfile:constant_pool))

#+end_src

to nie dziala, bo jakichs klas tam nie ma. Ale w plikach .class
mozemy znalezc takie cos:


#+begin_src
0700  00 76 01 00 0a 53 6f 75  72 63 65 46 69 6c 65 01  |.v...SourceFile.|
0710  00 0d 66 75 6e 63 74 69  6f 6e 73 2e 73 63 6d 01  |..functions.scm.|
0720  00 14 53 6f 75 72 63 65  44 65 62 75 67 45 78 74  |..SourceDebugExt|
#+end_src

i teraz mozemy w nich poszukac takiego czegos:

"\x01\x00SourceFile\x01\x00\([^\x01]+)\x01"

tyle ze wyrazenia regularne nie obaluguja danych binarnych

#+begin_src scheme

  (define (skip-characters #!key
			   (from::gnu.kawa.io.InPort
			    (current-input-port))
			   (until-having-read:string ""))
    ::(either gnu.kawa.io.InPort #f)
    (let* ((pattern ::string until-having-read)
	   (n ::int (string-length pattern))
	   (candidate ::gnu.lists.FString (gnu.lists.FString n)))
      (let loop ()
	(if (= n (string-length candidate))
	    input
	    (and-let* ((c ::gnu.text.Char (read-char from))
		       ((isnt c eof-object?)))
	      (candidate:append c)
	      (while (isnt candidate string-prefix? pattern)
		(candidate:delete 0 1))
	      (loop))))))

  (e.g.
   (call-with-input-string "kokokokosowycb"
     (lambda (port)
       (and-let* ((,port (skip-characters from: port
					  until-having-read: "kokos")))
	 (read-string 5 port)))) #;< ===> "owych")

#+end_src


* 06.06.2024

to teraz plan jest taki, zeby:
- skrypt listowal krok po kroku, co ma sie wydarzyv
- jakos ogarnac entry-pointsy, tj. pliki
  "grasp-desktop.scm", "grasp-android.scm" oraz
  "grasp-terminal.scm"
- i dla tych entry-pointsow budowac pliki .jar

I teraz rzecz tak sie ma, ze grasp-terminal
oraz grasp-desktop maja (module-compile-options main: #t)

No dobra, to na razie bysmy zrobili tak, ze nie
kompilujemy plikow bezposrednio z katalogu src

Ogolnie wyglada na to, ze po dzisiejszych zmaganiach
analiza zaleznosci z grubsza dziala, pomijajac to, ze
czasem wybucha.

Pomysl jest zatem taki, zebysmy sprobowali zbudowac
najpierw klienta desktopowego i terminalowego,
a potem tez androudowego.

* 05.06.2024

poniewaz wiadomosci slane na grupe mailingowa kawy pozostaja
bez odpowiedzi, plan jest taki, zeby wywolac te funkcje,
ktore wola sam kompilator, kiedy sie go wywoluje z opcjami
-C i -d

Opcja -d:

#+begin_src java
  ModuleManager manager = ModuleManager.getInstance();
  manager.setCompilationDirectory(args[iArg++]);
#+end_src

opcja -C

#+begin_src java
  compileFiles(args, iArg, maxArg);
  return -1;
#+end_src

gdzie compileFiles jest public static w kawa.repl.


*** no dobra


okazalo sie, ze problem byl zwiazany z nazwaniem funkcji
"module-name".

* 03.06.2024

dzis bysmy napisali sobie funkcje do przrnoszenia plikow
z jedbego katalogu do innego


#+begin_src scheme
  (define (as-file path::(either string java.io.File))::java.io.File
    (if (java.io.File? path)
	path
	(java.io.File (as String path))))

  (define (move-files #!key from to)
    ::void
    (let ((source-directory ::java.io.File (as-file from))
	  (target-directory ::java.io.File (as-file to)))
      (for file::java.io.File in (source-directory:listFiles)
	(if (file:isDirectory)
	    (move-files from: file to: (java.io.File target-directory
						     (file:getName)))
	    (file:renameTo (java.io.File target-directory
					 (file:getName)))))))
#+end_src


* 01.06.2024

bysmy moze sprobowali tej sciezki z odzipowywaniem
(a jak to sie nie uda, napisalibysmy do Bothnera)

oto fragment kodu znaleziony w internecie

#+begin_src java

  public class UnzipFile {

      public static File newFile(File destinationDir, ZipEntry zipEntry) throws IOException {
	  File destFile = new File(destinationDir, zipEntry.getName());

	  String destDirPath = destinationDir.getCanonicalPath();
	  String destFilePath = destFile.getCanonicalPath();

	  if (!destFilePath.startsWith(destDirPath + File.separator)) {
	      throw new IOException("Entry is outside of the target dir: " + zipEntry.getName());
	  }

	  return destFile;
      }
      
      public static void main(String[] args) throws IOException {
	  String fileZip = "src/main/resources/unzipTest/compressed.zip";
	  File destDir = new File("src/main/resources/unzipTest");

	  byte[] buffer = new byte[1024];
	  ZipInputStream zis = new ZipInputStream(new FileInputStream(fileZip));
	  ZipEntry zipEntry = zis.getNextEntry();
	  while (zipEntry != null) {
	      File newFile = newFile(destDir, zipEntry);
	      if (zipEntry.isDirectory()) {
		  if (!newFile.isDirectory() && !newFile.mkdirs()) {
		      throw new IOException("Failed to create directory " + newFile);
		  }
	      } else {
		  // fix for Windows-created archives
		  File parent = newFile.getParentFile();
		  if (!parent.isDirectory() && !parent.mkdirs()) {
		      throw new IOException("Failed to create directory " + parent);
		  }

		  // write file content
		  FileOutputStream fos = new FileOutputStream(newFile);
		  int len; //<
		  while ((len = zis.read(buffer)) > 0) {
		      fos.write(buffer, 0, len);
		  }
		  fos.close();
	      }
	      zipEntry = zis.getNextEntry();
	  }

	  zis.closeEntry();
	  zis.close();
      }
  }

#+end_src

to bysmy to sobie tak przetlumaczyli:

#+begin_src scheme

  (define (unzip archive ::string #!key (into ::string "."))::void
    (let* ((dir ::java.io.File (java.io.File (as String into)))
	   (buffer ::(array-of byte) ((array-of byte) length: 1024))
	   (data ::java.io.FileInputStream
		 (java.io.FileInputStream (java.io.File archive)))
	   (source ::java.util.zip.ZipInputStream
		   (java.util.zip.ZipInputStream archive)))
      (let next-entry ()
	(let ((entry ::java.util.zip.ZipEntry (source:getNextEntry)))
	  (when entry
	    (let ((file ::java.io.File (java.io.File dir (entry:getName))))
	      (if (entry:isDirectory)
		  (file:mkdirs)
		  (let ((parent ::java.io.File (file:getParentFile)))
		    (parent:mkdirs)
		    (let ((output ::java.io.FileOutputStream
				  (java.io.FileOutputStream file)))
		      (let rewrite-next ()
			(let ((n ::int (source:read buffer))) ;<
			  (when (is n > 0)
			    (output:write buffer 0 n)
			    (rewrite-next))))
		      (output:close)))))
	    (next-entry))))
      (source:closeEntry)
      (source:close)))

#+end_src


* 31.05.2024

wydaje sie, ze sledzenie zaleznosci mamy juz zrobione,
i na razie chcemy zbudowac pliki .class.

W jakiejs mierze to juz dziala, tyle ze pliki trafiaja
do archiwow .zip. Pytanie czy jest jakis sposob, zeby
to obejsc (mozna je rozzipowac, ale moze uda sie
przetrzepac zrodla Kawy, zeby tego uniknac)

* 30.05.2024

no to dzis bysmy zrobili tak, zeby uzyskac w skrypcie
budujacym:
- liste modulow do skompilowania (poprzez usuniecie
  z listy wszystkich modulow tych, dla ktorych
  mamy nowsze pliki .class)
- liste plikow .class do skasowania (w sklad ktorych
  beda wchodzic te pliki .class, ktorych odpowiedniki
  .scm sa nowsze, albo ktorych odpowiedniki .scm
  maja wsrod swoich zaleznosci pliki .scm, ktorych
  pliki .class powinny zostac skasowane)

* 29.05.2024

byc moze dobrym pomyslem byloby uczynienie "analdep"
modulem ladowanym przez build.scm - albo wyodrebnienie
wspolnej funkcjonalnosci?

na razie wylane: chcemy po prostu miec dzialajacy build system.
docelowo analdep.scm po prostu wywalimy, a funkcjonalnosc
sprawdzania zaleznosci wyodrebmimy do skryptu budujacego.

* 28.05.2024

ok, to mamy juz sobie te warstwy zaleznosci - choc na razie
tylko w narzedziu do analizy. troche nam to porzadkuje w glowie,
aczkolwiek duzo lepiej byloby moc je sobie jakos zwizualizowac
na widgecie.

tym niemniej, naszym celem jest usprawnienie procesu buildow,
przy czym on powinien wygladac tak, ze:
- po pierwszym buildzie mamy sobie katalog build/cache,
  zawierajacy pliki .class i ewentualnie pliki .dex
- po zmianie w jakims module wszystkie moduly, ktore
  od niego zaleza, kasujemy, i budujemy od nowa
  
(jako zmiane rozumiemy to, ze timestamp pliku .scm jest
pozniejszy od timestampu pliku .class)

No dobrze, to teraz rzecz tak wyglada, ze skrypt budujacy
powinien:
1. przeanalizowac zaleznosci glownych modulow
   (grasp-android, grasp-desktop, grasp-terminal)
2. sprawdzic, ktore moduly sa nowsze od odpowiadajacych
   im plikow .class
3. znalezc wszystkie moduly zalezace od zmodyfikowanych
   modulow
4. skasowac nieaktualne pliki .class (co dotyczy
   rowniez plikow xxx$frame[0-9]* oraz xxx$[0-9]*)
5. w srodowisku build/cache - tak zeby Kawa miala do tego
   dostep - nakazac zbudowanie rzeczonych modulow

Byc moze proces bedzie jeszcze musial uwzglednic kopiowanie
plikow .scm - na potrzeby kompilacji, ale rowniez na potrzeby
dystrybucji.

Jednak na razie zostawmy ten temat na boku, i raczej skupmy sie
na samym procesie budowania.

Moze bysmy to zrobili w taki sposob, ze skrypt build.sh
tworzy katalog "build/cache" i kopiuje do niego plik
"src/build.scm" (wraz z innymi plikami), i stamtad go
wykonuje?

Hmm, no trudno powiedziec.


* 27.05.2024

no dobra, to teraz musimy troche pokombinowac.
do tej pory uzylismy takiej strategii, ze
po prostu sprawdzalismy nowsze pliki, i tylko
te dodawalismy do nowej kompilacji.
Ale to najwidoczniej nie dziala.

Zatem pozadane rozwiazanie byloby takie, ze
najpierw budujemy sobie graf zaleznosci,
i nastepnie przebudowujemy wszystkie moduly,
ktore zaleza od zmienionego modulu.

To mogloby dzialac w taki sposob, ze w katalogu build/cache
trzymamy wszystkie pliki .class, ale jezeli jakas zaleznosc
sie zaktualizuje, to kasujemy te pliki, przy czym przez
'te pliki' rozumiemy rowniez klasy pochodne, tzn. jezeli
$m jest nazwa modulu Kawy, a $jm jej javowym odpowiednikiem,
to wszystkie pliki o nazwach $jm\$[0-9]*.class oraz
$jm\$frame[0-9]*.class stanowia pliki pochodne

W takiej sytuacji trzeba by bylo zaczac od budowania
grafu zaleznosci. Byc moze tez przy tej okazji mozna by sie
zastanowic nad budowa rozszerzenia do wizualizacji grafu,
przy czym dobrze by bylo sobie ten graf posortowac w warstwy,
takie ze:

- na samej gorze sa moduly, ktore nie maja zadnych
  zaleznosci
- na samym dole sa moduly

i dalej: "przedostatnie pietra" to moduly, ktore
odnosza sie tylko do modulow na samej gorze;
"przed-przedostatnie pietra" to moduly, ktore
moga sie dodatkowo odnosic do modulow z przedostatniego
pietra
itd.

moglibysmy zaczac od tego, ze - skoro i tak budujemy graf w narzedziu
do analizy - sprobowalibysmy sobie dodac opcje "--layers" do tego narzedzia?



* 26.05.2024

uff, mamy za soba lispowy game jam - i wydaje sie, ze w miare sie
udalo.

najwazniejszy wniosek na razie jest taki, ze musimy cos zrobic, zeby
przyspieszyc czas kompilacji, a takze zwiekszyc elastycznosc systemu
budowania - przynajmniej o tyle, zeby mozna bylo w rozny sposob
nazywac pliki wynikowe (najlepiej zeby AndroidManifest.xml byl
generowany).

Moglibysmy tez uwspolnic skrypt budujacy wszystkie 3 wersje,
poniewaz pliki .class raczej beda we wszystkich przypadkach
takie same.

Poza przyspieszeniem kompilacji chcielibysmy tez poprawic
'developer experience' tak zeby w przyszlosci tego rodzaju
gre dalo sie stworzyc bez wychodzenia z edytora.

Warto jednak zaczac przynajmniej od tego, zeby te gre dalo sie
odpalac bezposrednio z edytora.

* 17-25.05.2024

logi w pliku 'SPRING-LISP-GAME-JAM-2024.org' na branchu
spring-lisp-game-jam-2024.

* 13-16.05.2024

(chyba zgubilismy jakies dane)

* 12.05.2024

No dobra, zalozmy ze mamy takie cos:

(parameterize ((p v))
  (future (f ... (p) ...)))

to problem tutaj jest taki, ze watek wolajacy wyjdzie z zasiegu
szybciej, niz watek potomny.


Zastanowmy sie, dlaczego to, co jest w Kawie, w ogole dziala.

(parameterize ((p v))
  (future (set! (p) v2))
  )


1. watek glowny przypisuje wartos v parametrowi p
2. tworzymy nowy watek
3. przywracamy stara wartosc parametru

I teraz: jak to dziala z ThreadLocation?

A konkretnie - dlaczego w tym przypadku mamy dostep do starej
wartosci?


No bo ogolnie chcielibysmy to miec mniej wiecej tak jak jest teraz,
tylko ze ta wartosc to powinna byc lokacja.


* 11.05.2024 (komputer)

moze bysmy zmodyfikowali "parameterize" w Kawie
w taki sposob, zeby zamiast ThreadLocation uzywac
SharedLocation, i zobaczyli, jak sie zachowa taki
oto snipet kodu:

#+BEGIN_SRC scheme
(define x (make-parameter 0))

(parameterize ((x 1))
  (force (future (set! (x) 2)))
  (display (x)))

#+END_SRC

* 11.05.2024

no to teraz przed game-jamem przydaloby sie skupic na nastepujacych
funkcjonalnosciach:
- maksymalizacja widgetu
- ewaluacja rozszerzen podczas parsowania

pomijajac wszystko inne, wydaje sie, ze warto by bylo w koncu
doprowadzic do sytuacji, w ktorej mozemy uzywac GRASPa do edytowania
i budowania jego samego.

Przed game jamem wydaje malo prawdopodobne, zeby dalo sie to
calkowicie zrobic, bo raczej nie zrobimy wyszukiwania.

Ale chodziloby o to, zeby miec narzedzie, ktore buduje calego
GRASPa + plik inicjalizujacy.

Wszelako trzeba bedzie pomyslec, jakie moduly maja byc
kompilowane (dokompilowywane), zeby wszystko mialo szanse
dzialac.

Do samej gry bedziemy musieli zrobic takie oto funkcjonalnosci:
- klocki z literkami
- pola na klocki z literkami
- maksymalizowalna plansze

a, co do samych gier:
- ukladanie wyrazow ze slownika
- rysowanie liter
- ukladanie wyrazow z wypowiedzi
- czytanie wyrazow
  
* 10.05.2024

dzisiaj bysmy zrobili tak:
- zeby say bylo blokujace
- zeby ten wczorajszy kod dzialal

* 09.05.2024

dzisiaj:
- dodac typ powodujacy 'zachowanie tozsamosci' obiektu
  podczas graspowania
- wymuszac przerysowanie ekranu

to sie udalo dosc gladko. ale jest wiekszy problem,
mianowicie:
- ewaluacja "say" nie czeka do zakonczenia wypowiedzi
- ewaluacja "listen" zwraca wynik przed otrzymaniem go

i z tego powodu np. program

#+begin_src scheme
  (begin
    (say "Jak masz na imi?")
    (let ((name (listen)))
      (say "witaj")
      (say name)))
#+end_src

nie zadziala.

ponadto mamy taka hipoteze, ze zarowno kod startActivityForResult
jak i kod on onActivityResult sa wolane z glownego watku, przez
co oczekiwanie na odpowiedz po wywolaniu startActivityForResult
za posrednictwem kolejki powoduje, ze interfejs sie zawiesza.

Rozwiazanie byloby takie, zeby ewaluacji zawsze dokonywac w osobnym
watku, zas startActivityForResult wywolywac z watku UI?
(Activity:runOnUiThread)

No dobra. Ewaluacje w osobnym watku juz mamy - teraz jedyny problem
jest taki, ze parametry zachowuja unikatowosc w obrebie watku, a nie
w obrebie zasiegu, i przez to kursor sie nie aktualizuje odpowiednio.

Ponadto, dobrze by bylo dorobic inwalidacje ekranu po stronie
paintera, zeby moc to wywolywac z poziomu ewaluacji.

Jednak zamiast skupiac sie na tych problemach, zajmijmy sie raczej
synchronizacja czasu ewaluacji wyrazenia z czasem wypowiedzi,
czyli tym UtteranceProgressListener'em.


* 08.05.2024

speech to text nadal nie dziala, wiec bysmy jakos sprobowali
z tym startActivityForResult

No dobra, to moze sobie przekopiujmy tutaj ten artykul
z internetow, zeby go lepiej przeanalizowac.

#+BEGIN_SRC java
public class StartVoiceRecognition extends Activity {
   private final int REQUEST_SPEECH_RECOGNIZER = 3000;
   private TextView mTextView;
   private final String mQuestion = "Which company is the largest
      online retailer on the planet?";
   private String mAnswer = "";

   @Override
   protected void onCreate(Bundle savedInstanceState) {
      super.onCreate(savedInstanceState);
      setContentView(R.layout.voicerecog);
      mTextView = (TextView)findViewById(R.id.tvstt);
      startSpeechRecognizer();
   }

   private void startSpeechRecognizer() {
      Intent intent = new Intent
         (RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
      intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL,
         RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
      intent.putExtra(RecognizerIntent.EXTRA_PROMPT, mQuestion);
      startActivityForResult(intent, REQUEST_SPEECH_RECOGNIZER);
   }

   @Override
   protected void onActivityResult(int requestCode, int resultCode,
         Intent data) {
      super.onActivityResult(requestCode, resultCode, data);

      if (requestCode == REQUEST_SPEECH_RECOGNIZER) {
         if (resultCode == RESULT_OK) {
            List<string> results = data.getStringArrayListExtra
               (RecognizerIntent.EXTRA_RESULTS);
            mAnswer = results.get(0);

            if (mAnswer.toUpperCase().indexOf("AMAZON") > -1)
               mTextView.setText("nnQuestion: " + mQuestion +
                  "nnYour answer is '" + mAnswer +
                  "' and it is correct!");
            else
               mTextView.setText("nnQuestion: " + mQuestion +
                  "nnYour answer is '" + mAnswer +
                  "' and it is incorrect!");
         }
      }
   }
}
#+END_SRC

Po kolei co tutaj sie dzieje:
1. w onCreate jest wywolywany "startSpeechRecognizer",
   ktory wywoluje setActivityForResult z pewnym arbitralnym
   kodem
2. w metodzie onActivityResult jest wywolywana kontynuacja,
   ktora na obiekcie "data" wywoluje getStringArrayListExtra.

I teraz na pewno jest tak, ze mamy juz w tym kliencie
Androidowym jakies mechanizmy, ktore robia takie rzeczy
za nas, tylko musimy je zmapowac w to rozwiazanie.

* 06.05.2024

dzis bysmy sprobowali ma Androidzie zintefrowac speech to text

* 05.05.2024 (telefon)

moze jeszcze bysmy zrobili zmiany pod katem 'usability'
- zeby moc wreszcie edytowac pliki z poziomu GRASPa

ale zacznijmy od tego, zeby miec w kliencie androidowym
funkcje (say "message"), uzywajaca androidowego text to speech

* 05.05.2024

trzeba wymyslic jakis plan na ten tydzien.

z rzeczy calkiem podstawowych, to bysmy sie mogli zajac
operacjami na komentarzach (kopiowanie, przenoszenie)

natomiast byc moze widget Teletype mialby dla nas wieksza wartosc,
podobnie jak refleksja w klientach pecetowych, oraz podswietlanie
wcisnietych guzikow

natomiast na androidzie mozemy sprobowac poeksplorowac
text to speech oraz speech to text. warto tez pomyslec
nad trybem przechwytywania inputu przez jakies konkretne
rozszerzenie - bo chyba docelowo wlasnie czegos takiego
bysmy chcieli w naszym zgloszeniu na lisp game jam.

I tutaj pomysl jest z grubsza taki:
- jezeli widget jest "przechwytujacy", to double-tap
na nim powoduje jego maksymalizacje
- jezeli jestesmy w trybie przechwytywania, to wcisniecje
przycisku "escape" (albo "back" na androidizie) spowoduje
wyjscie z niego

Inny pomysl (taki troche na odleglejsza przyszlosc - moze
na te przerwe, ktora ma miec miejsce miedzy czerwcem
a lipcem?) to stworzyc czysto tekstowa implementacje
edytora, posiadajaca calkowicie nowa reprezentacje dokumentu
(troche na modle tej wczesnej wersji multics emacsa)

Kolejna istotna rzecz to zrobic w koncu ta implementacje
algorytmu A*,  moze tez jakis translator Scheme'u do JavaScriptu.

Aaa no i te podswietlania guzikow.

Ogolem wizja jest taka, ze mamy sobie pole tekstowe
(z mozliwoscia wprowadzania tekstu) oraz pole z tekstem,
ktory jest wypluwany przez terminal (i w ktorym mozemy
zaznaczac tekst oraz kopiowac, ale nie mozemy tam nic
pisac)

* 02.05.2024

sprobujmy poprawic wyswietlanie stringow na desktopie,
no i zajmijmy sie implementacja rozszetzenia Teletype.

* 25.04.2024

czyli co dzis?
- kopiowanie na drugie wcisniecie
- i moze jeszcze zmiana rozmiaru pustego pudelka
  (ktora daje nam okazje do tego, zeby sie skupic
  na zachowaniu resize'a w kontekscie komentarzy)

jezeli idzie o ten pierwszy punkt, to najlepiej go zrealizowac
w analogii do tego, co juz mamy, czyli

#+begin_src scheme
  ((or (is target Atom?)
       (and (or (is target cons?)
		(is target EmptyListProxy?))
	    (eqv? tip (target:first-index))))
   ;; powinnismy powiekszyc spacje poprzedzajaca
   ;; wydobywany element o szerokosc tego elementu
   ;; podzielona przez (painter:space-width)
   (set! (the-cursor) (cursor-climb-back
		       (cursor-retreat (tail path))))
   (let* ((removed ::Remove (remove-element!
			     at: subpath))
	  (selection (Selected
		      removed:element
		      (copy
		       (last-known-pointer-position
			finger)))))
     (screen:drag! finger (DragAround selection))))
#+end_src

i w nowym przypadku to powinno wygladac podobnie, tyle ze
zamoast usuwac, chcemy kopiowac.

i jest tutaj jeszcze taki szkopul, ze bysmy chcieli zrozumiec,
co sie tutaj dzieje.

to tak: remove-element! jest zdefiniowane nastepujaco:

#+begin_src scheme
(define/kw (remove-element! at: cursor::Cursor := (the-cursor)
			    from: document := (the-document))
  ::Remove
  (let* ((shift (last-index (space-preceding cursor in: document)))
	 (element (extract! at: cursor from: document))
	 (history ::History (history document))
	 (action ::Remove (Remove element: element
				  at: cursor
				  with-shift: shift)))
    (history:record! action)
    action))
#+end_src

natomiast Selected jest zdefiniowane w taki oto sposob:

#+begin_src scheme
(define-object (Selected items::cons position::Position)::Layer

  (define (draw!)::void
    (parameterize ((the-document items))
      (with-translation (position:left position:top)
	(draw-sequence! items))))

  (IgnoreInput))
#+end_src

a DragAround - o tak:

#+begin_src scheme
(define-object (DragAround selected::Selected)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    (let ((position ::Position selected:position))
      (set! position:left (+ position:left dx))
      (set! position:top (+ position:top dy))))

  (define (drop! x::real y::real vx::real vy::real)::void
    ;; musimy sobie przetransformowac wspolrzedne
    ;; do wspolrzednych edytora oraz wybrac dokument
    (screen:overlay:remove! selected)
    (screen:top:drop-at! x y selected:items)
    )

  (screen:overlay:add! selected))
#+end_src

I tutaj rzecz ma sie w taki sposob, ze to metoda drop-at!
w DocumentEditor zajmuje sie zarejestrowaniem akcji Insert:

#+begin_src scheme
  ((is parent Space?)
   (let* ((action ::Insert (Insert element: items
				   at: cursor))
	  (history ::History (history document)))
     (history:record! action)
     (set! (the-cursor) (action:apply! document))))
#+end_src

przy czym History:record! zajmuje sie tym, zeby sprawdzic, czy
ostatnia akcja to nie bylo Remove na tym elemencie.

Hipoteza jest zatem taka, ze kopiowanie powinno wygladac
nastepujaco:

#+begin_src scheme
  ((or (is target Atom?)
       (and (or (is target cons?)
		(is target EmptyListProxy?))
	    (eqv? tip (target:first-index))))
   (let* ((selection (Selected
		      (cons (copy target) (empty))
		      (copy
		       (last-known-pointer-position
			finger)))))
     (screen:drag! finger (DragAround selection))))
#+end_src

W porzadku, to wydaje sie dzialac.

Czyli co nam teraz pozostaje?

Teraz bysmy sie zajeli zmiana rozmiaru pustych list?
(i innymi zmianami behawioralnymi w module (editor input pane))

A moze na razie bysmy sie zajeli odpoczywaniem?

* 24.04.2024

dzis od rana jakies absolutne pierdoly: zamiana $bracket-apply$
na array-of i parameter-of.

natomiast dobrze by bylo sie zajac tym podwojnym
kliknieciem, i przy okazji moze zrobic zmiany behawioralne,
a konkretnie:
- 'drugie-wcisniecie' atomu albo lewego nawiasu
  tworzy kopie tego obiektu
- przytrzymanie na atomie daje nam liste dostepnych metod
- dwukrotne klikniecie atomu zabiera nas do definicji,
  a w przypadku definicji - pokazuje wszystkie uzycia
  (markujac to ostatnie)
- dwukrotne klikniecie na nawiasie zamyka albo
  otwiera wyrazenie
- jezeli przeciagamy wyrazenie i dotkniemy je drugim palcem,
  to mozemy je powiekszac albo zmniejszac. podobnie powinno dzialac
  ctrl+shift+mouse wheel

poza tym chcemy miec scroll-bary (polprzezroczyste),
chcemy moc scrollowac tylko w granicach dokumentu,
i tylko zoomowac bez obracania, i to tylko w pewnych
granicach.

jezeli odzoomujemy dalej, to powinien sie nam renderowac
widok prototypow klas, funkcji i zmiennych w kontekscie
modulow, oraz zaleznosci pomiedzy modulami

i to jest jedna rzecz. Natomiast w gre wchodzi tutaj
jeszcze druga, mianowicie widok historii w gicie, czyli
takie cos, ze sobie rysujemy migawki modulow w poszczegolnych
commitach (w takim widoku jakby-3D) oraz sciezki historii
projektu - z akcentem na topologie, ale w taki sposob, zeby
przy odpowiednim zoomie moc rowniez zobaczyc poszczegolne
commity

No, ale ta integracja z gitem, przechodzenie do definicji
itd. to na razie piesn przyszlosci. Natomiast tym, co bysmy
robili w pierwszej kolejnosci, to:
- kopiowanie wyrazen
- scroll bary
- ograniczenie zoomowania i rotacji
- rysowaine chmurek <3 (pliz pliz pliz)
no dobra, rysowanie chmurek

- przegladarka plikow na androidzie
- wyszukiwanie
  (i do tego celu bysmy chcieli przeniesc popup
  z przegladarka pliku z ekranu do poszczeoglnego splita)
  
* 23.04.2024

no dobra, to parser udalo sie poprawic.
mozemy poprawic ten unquote-splicing
w kliencie tekstowym, natomiast warto sie zastanowic
nad lista rzeczy do zrobienia na po-majowce.

unquote-splicing poprawiony!

to teraz przypomnijmy sobie wczorajsza sesje nagraniowa
i rzeczy, ktore wydawaly sie nam potrzebne.

Na pierwszy strzal to by byly:
- kopiowanie przez podwojne klikniecie
- podswietlanie wcisniec przyciskow
- cytowanie wyrazen
- przenoszenie przyciskow
- pulling-the-rug
- i jego przeciwienstwo, czyli zamykanie
  selekcji w nawias
- wynik ewaluacji (na czerwono albo zielono)
- przenoszenie tekstu
- minimalizacja wyrazen
- skalowanie wyrazen
- rysowanie chmurek
- rysowanie guzikow
- wyszukiwanie
- (no i moze jeszcze takie cos, ze jak sie przytrzyma
  palec na atomie, to sie wokol niego pojawiaja wszystkie
  metody tego obiektu, i jak je wcisniemy, to sie nam
  zrobi szablon wywolania metody, no i jezeli mamy
  przeciazona metode - na co Java pozwala, to mozemy
  sobie cyrkulowac pomiedzy szablonami. Ale cos takiego
  samego mogloby byc rowniez wtedy, kiedy wpiszemy
  dwukropek na koncu symbolu)

Ha! To wszystko brzmi niezle! Jednak co musielibysmy zrobic,
gdybysmy chcieli, zeby dalo sie uzywac GRASPa do edytowania
jego samego?

I tutaj pomyslow jest kilka. Pierwsza rzecz - plan minimum
- to dzialajaca wybieraczka plikow dla Androida.

Przy okazji warto by bylo rowniez rozwazyc kwestie przyspieszenia
budowania projektu Androidowego, poniewaz aktualnie trwa
masakrycznie dlugo.

Jednak wlasnie z tego powodu warto by bylo zaczac od systemu
buildow dla desktopa i dla terminala. A tak naprawde to chcielibysmy
uwspolnic system buildow dla tych wszystkich modulow.

I z tego powodu zacznijmy od czegos jeszcze zupelnie innego,
mianowicie maila do Bothnera, w ktorym:
- zaanonsujemy wczorajsze demo
- zapytamy o roznice pomiedzy ewaluacja na androidzie i na JVMie


* 22.04.2024

dzis moze bysmy sie sprobowali zajac tym drugim
problemem, ktory mamy z initem, czyli tym, co sie dzieje
na koncu

wyglada na to, ze mamy do czynienia z dwoma problemami:
- po pierwsze unquote-splicing sie
  nie najlepiej wyswietla
- po drugie, komentarze blokowe i liniowe
  jak sie je przeplata, to cos sie zle parsuja

i teraz plan bylby z grubsza taki:
- dodac odpowiednie testy do parsera
- dodac odpowiednie testy do paintera


* 19.04.2024

no i co teraz, e?

mozemy sprobowac rozwiazac te problemy, na ktore
sie natknelismy przy budowaniu inita.

po nich zas bysmy dopracowali drag&drop, w tym:
- podwojne klikniecia (kopiowanie)
- pulling-the-rug
- wyrzucanie
- przywracanie nieumieszczonych i niewyrzuconych elementow
- drag&drop na komentarzach

* 18.04.2024

#+begin_src

                                                
 define  ! n                                    
                                              
  1                                          
  2                                        
  3                                          
  4                                          
                                              
  if  <= n 0                                 
                                              
                                                
    1                                           
                                                
                                          
    * n  !  - n 1                         
                                          

#+end_src

no to widac ze problem jest wtedy, gdy probujemy przeciagnac
pierwsza spacje - i w takiej sytuacji powinnismy raczej wziac
sobie "reach" ostatniej spacji

No dobra, to wyglada na to, ze te jedna rzecz udalo sie
zrobic i jako tako dziala.

Zatem musimy albo ustalic dalsze prace w sensie obslugi
bledow i brakujacych funkcjonalnosci, albo jakos sie zastanowic
nad Lisp Game Jam.

OK, to niech bedzie ten Lisp Game Jam ;D

No to plan jest z grubsza taki: kiedy otwieramy gre, jestesmy
pytani o nasze imie (glosem "jak masz na imie?").

W odpowiedzi podajemy swoje imie. Wowczas jestesmy przenoszeni
na plansze, na ktorej musimy ulozyc nasze imie z klockow
na odpowiednim polu.

Kiedy skonczymy, zaladowane zostaja nasze ustawienia.

Sama rozgrywka polega na tym, ze losujemy sobie zdania
o roznym poziomie trudnosci. Kiedy wylosujemy zdanie,
wybieramy sobie slowo z tego zdania.

Zeby ulozyc slowo, musimy miec odpowiednio duzo liter.
Litery odblokowujemy w taki sposob, ze najpierw je rysujemy,
a pozniej (opcjonalnie) wymawiamy.

Dla niektorych slow rysowane sa obrazki.

Mozna jeszcze zrobic tak, zeby trzeba bylo wypowiedziec
dane slowo, zeby zdobyc punkty

* 17.04.2024

to dzis bysmy sie zajeli tym resizem.

* 16.04.2024

no to teraz mamy wreszcie troche oddechu.

oczywiscie warto by bylo rozwiazac problem
tego resize'a, natomiast wydaje sie, ze w kolejce
jest jeszcze kilka palacych spraw, w tym:

- drag&dropowanie wyrazen
- drag&dropowanie komentarzy
- bledy renderowania komentarzy
- poprawa uzywalnosci:
  - automatyczne podazanie za kursorem
  - zapis i odczyt plikow
  - praca jak z normalnym edytorem tekstu
- bledy poruszania kursorem
- poprawne pozycjonowanie kursora
    
i jeszcze rzeczy nieco ciekawsze, takie jak:
- minimalizacja i maksymalizacja wyrazen
- zmniejszanie i obracanie wyrazen
- algorytm A*
  
* 15.04.2024

dzisiaj raczej nie zdolamy zrobic nic innego, niz
uporzadkowac testy

* 12.04.2024

dzis bysmy sie skupili na tym, zeby dobrze narysowac
te czerwona kropke przy resize (i ewentualnie dorysowali
kolejne kropki)

dobra, chyba problem udalo sie naprawic (i nie bylo trudne)

teraz jednak warto by bylo jeszcze popracowac nad tym,
zeby chwytanie ponad polowa atomu w pierwszym nawiasie
powodowalo przesuwanie wzgledem pierwszej spacji.


* 11.04.2024

dzis bysmy sie sprobowali skoncentrowac na naprawie
przynajmniej jednego z testow, ktore wczoraj napisalismy
(i to raczej tego z drag&dropem, bo juz many rozgrzebane)

to plan dzialania jest z grubsza taki:
- niech DocumentEditor z (editor input pane) uzywa
  document:cursor-under* zamiast cursor-under
- Document:cursor-under* powinno dzialac w taki sposob,
  ze jezeli nie znajdzie pasujacego indeksu, to zwraca
  indeks pierwszej albo ostatniej spacji

na razie mamy to jakos szczatkowo zaimplementowane.

to teraz bysmy sprobowali dodac owe utensylia debugowe
do resize'a (te same, ktore mielismy juz wczesniej,
czyli zeby sie nam gdzies tam wyswietlala czerwona
kropka)

* 10.04.2024

No dobra, to test nam dziala. I co robimy dalej?

Jedna mysl jest taka, zeby zrobic rozszerzenie, ktore by nam
pozwalalo na trzaskanie takich testow na potege.

Druga mysl, to zeby po prostu natrzaskac troche takich testow,
i ewentualnie potem zrefaktoryzowac.

Z rozszerzeniem bylby taki problem, ze rozne klienty
maja rozne skale, wiec te same wspolrzedne dotkniec
nie beda wspolmierne dla roznych klientow
- chyba ze wszystkie rozszerzenia by operowaly
  na wspolrzednych tekstowych

no dobra, na razie olewamy rozszerzenie, bo wydaje sie,
ze zwykla copy-pasta jest wystarczajaca do pisania
interesujacych nas testow - a juz teraz widzimy, ze
sa bledy w resize - wiec na razie uzyjmy tego testu
do naprawy bledu - i ewentualnie pobadajmy jeszcze
przenoszenie wyrazen. 

* 09.04.2024

Testa juz mamy, tyle ze nie do konca dziala tak, jak to
sobie wymarzylismy. Wiec dzis trzeba bedzie pobadac
nieco; poinwestygowac.

* 08.04.2024

Usunelismy sobie na razie draw-document!, i teraz
co dalej?
No, chyba wypadaloby napisac jakiegos takiego
testa dla resize'a.

* 07.04.2024

byc moze bedzie trzeba zamienic screen na parametr
(the-screen)?

Chyba nie trzeeeba.

Ale mozemy sprobowac dopicowac ten wczorajszy
kod.

#+BEGIN_SRC scheme
  (let* ((document (with-input-from-string "\
  (define (! n)
    (if (<= n 0)
	1
	(* n (! (- n 1)))))
  " parse-document))
	 (press (Position left: 36 top: 11))
	 (release (Position left: 41 top: 14))
	 (finger 0)
	 (trajectory (list press release))
	 )
    (e.g.
     (snapshot
      (Over back: (Dummy document)
	    front: (Movement from: press
			     to: release
			     via: trajectory)))
     #;< ===> "
    ...
    ")
    (screen:press! finger press:left press:top)
    (let ((last-position press))
      (for position in trajectory
	(screen:move! finger
		      position:left position:top
		      (- position:left last-position:left)
		      (- position:top last-position:top))
	(set! last-position position)))
    (screen:release! finger release:left release:top 0 0)
    (e.g.
     (snapshot document) #;< ===> "
    ...
    "))
#+END_SRC




* 06.04.2024

no i co dalej?
czy nie wypadaloby zaczac pisac jakichs testow
wykorzystujacych Movement?

Jak bumerang powraca rowniez pytanie dotyczace
zmiany reprezentacji dokumentu.

No ale dobra, powiedzmy ze to na razie olewamy
(bo to jest cos co bysmy chcieli zrobic w zasadzie
od podstaw).

Natomiast tak to bysmy zrobili

#+BEGIN_SRC scheme
(Over top: (Movement ...) bottom: document)
#+END_SRC

Tylko ze wtedy bysmy caly ten "border" wywalili.

No dobra, ale jak by wowczas wywolywali nasz test?

Zacznijmy moze od nieformalnego opisu. To musi byc
cos takiego, ze "majac dany taki a taki dokument,
i wykonujc na nim tak a tak akcj, otrzymujemy
nowy stan dokumentu".

#+BEGIN_SRC scheme
  (let* ((document ...)
	 (press ...)
	 (release ...))
    (e.g.
     (rendered
      (overlay (View document) with: (Movement ...)))
     #;< ===> "
  ...
  ")
    (pane:press! ...)
    ...

    (e.g.
     (rendered (View document)) #;< ===> "
  ...
  "))
#+END_SRC

* 05.04.2024

no to jak teraz bedzie?

chcielibysmy zrobic tak, zeby odczarowywanie
rozszerzenia dopisywalo na poczatku atom "list"

* 04.04.2024

dzisiaj byla tylko zmiana inita - z bezsensownego
na pomocny. Ale jutro warto by bylo wrocic
do developerki, a przynajmniej zmienic strzalki
w ikonkach :D

* 03.04.2024

no to dzis bysmy sprobowali zintegrowac ten wczorajszy kod
z baza GRASP, tylko jakas lepsza nazwe bysmy wymyslili.
Moze simplified-transform?

* 02.04.2024

plan na dzis jest z grubsza taki, zeby ten nasz Movement
uwzglednial press/release-extent, i bysmy sobie tez
dopracowali jego dzialanie w obliczu transformacji
edytora

a jak to nam sie uda, to bysmy:
- dodali nowy kombinator Shift
- wykombinowali sobie jak rysowac testy
- zrobili test dla operacji Resize

No dobra, to przynajmniej press/release-extent
mamy uwzgledniony (i wydaje sie to calkiem fajnie
zachowywac). To teraz bysmy sie skupili na tych
transformacjach, bo ewidentnie widac, ze
one nie sa aplikowane:
- do przemieszczen
- do polozenia poczatkowego

Wydaje sie, ze to sa dwie nieco rozne kwestie,
poniewaz punkt poczatkowy powinien zawsze byc
dobrze mapowany, natomiast mapowaniem przesuniec
powinien sie juz martwic sam widget.

No dobra, to sie wydaje, ze ten pierwszy problem
mamy rozwiazany. Jezeli idzie o ten drugi problem,
czyli skalowanie przesuniec, to musielibysmy
zrobic to mniej wiecej tak, ze:
- w momencie tworzenia elementu Drag przechwytujemy
  sobie biezaca transformacje
- kazdorazowo aplikujemy te transformacje w
  metodzie "move!"

Widac, ze uzywamy dwoch makr:
- with-post-transform
- with-view-edges-transformed

No dobra, to wiemy, ze mamy

#+BEGIN_SRC scheme

  (define the-transform-stack ::TransformStack (TransformStack))

  (define-syntax-rule (with-post-transform t . actions)
    (the-transform-stack:addLast t)
    (try-finally
     (begin . actions)
     (the-transform-stack:removeLast)))
  
#+END_SRC

gdzie "the-transform-stack" to singletonowany obiekt typu TransformStack:

#+BEGIN_SRC scheme

  (define-object (TransformStack)::BiMap2D
    (define transforms ::($bracket-apply$ java.util.ArrayList BiMap2D) ...)

    (define (outside-in x::real y::real)::(Values real real) ...)
    (define (inside-out x::real y::real)::(Values real real) ...)

    (define (addLast transform::BiMap2D)::void ...)

    (define (addFirst transform::BiMap2D)::void ...)

    (define (removeLast)::BiMap2D ...)

    (define (removeFirst)::BiMap2D ...)
    )

#+END_SRC

chcielibysmy miec sposob, zeby "splaszczac" stos transformacji

#+BEGIN_SRC scheme
  (define (transform2D transform ::Map2D)::Transform
    (let*-values (((x0 y0) (transform:outside-in 0 0))
		  ((x10 y10) (transform:outside-in 1 0))
		  ((kC kS) (values (- x10 x0) (- y10 y0)))
		  ((angle scale) (values (atan2 kS kC)
					 (sqrt (+ (* kS kS)
						  (* kC kC)))))
		  ((C/k S/k) (values (/ (cos angle) scale)
				     (/ (sin angle) scale)))
		  ((left top) (values (+ (* C/k x0) (* S/k y0))
				      (- (* C/k y0) (* S/k x0)))))
      (if (and (= angle 0) (= scale 1))
	  (Translation left: left
		       top: top)
	  (Isogonal left: left
		    top: top
		    scale: scale
		    angle/rad: angle))))
#+END_SRC


* 01.04.2024

oprocz dodania press/release-mark-extent bysmy jeszcze
cos pokombinowali z mapowaniem wspolrzednych, "tak zeby
bylo dobrze"



* 31.03.2024

no to wyglada na to, ze musimy wprowadzic do paintera
press/release-mark-extent, i jakos zrefaktoryzowac
obsluge wcisniecia, zeby dobrze dzialala dla Enchanted.
a jak to bedziemy mieli, to mozemy kontynuowac nasza
liste bledow

przy czym w gre nam tutaj jeszcze wchodzi co nieco
rozkminy, jak to zrobic, zeby moc na telefonie
edytowac GRASP w GRASP i ewentualnie zrobic takie
rzeczy, jak cache'owanie plikow '.class'.


* 27.03.2024

nie chcemy jednak tego "extension-margin".  Zamiast niego bysmy
chcieli miec wartosc height/width-ratio, ktora by nam mowila,
w jaki sposob powinnismy przeskalowac szerokosc, zeby otrzymac
wizualnie podobny efekt dla wysokosci (i dla klientow tekstowych
bysmy przyjeli wartosc 1/2, a dla graficznych - 1)

i co dalej?

Najmniejsza szerokosc widgetu powinna wynosic

#+begin_src
(+ (* 2 (painter:border-size))
   (* (painter:space-width)
       (+ 2 (length (typename)))))
#+end_src

a najmniejsza wysokosc powinna byc wynikiem 
wymnozenia tej wartosci przez height/width-ratio.

OK, ale pozostaje nam jeszcze draw-press-mark!
i draw-release-mark!

i przypadku klienta tekstowego to latwe, ale
dla graficznych jest dosc klopotliwe

* 26.03.2024

No dobra, to co teraz chcemy zrobic?

Mozemy sprobowac zaimplementowac tego movementa w pelni.

To rzecz wyglada tak, ze musimy teraz dodac do
Paintera:

#+begin_src
extension-margin-horizontal
extension-margin-vertical
draw-press!
draw-release!

 Movement 
             
          
          
          
             


 Movement 
             
            
          
            
             



 Stepper 
                             
+  * 2 3   - 4 5             
                             

              



#+end_src

a do tego bysmy przemianowali draw-line! na
draw-thick-line! i dodali draw-thin-line!

* 25.03.2024

no dobra, to teraz jak bysmy chcieli, zeby wygladaly
testy zwiazane z drag&dropem?

no oczywiscie tak, ze mamy jakas "sytuacje przed",
klikniecie, przeciagniecie i upuszczenie, a po nich
nowa sytuacje

i teraz tak: od strony czysto technicznej bysmy sobie
stworzyli specjalny widget, ktory nam rejestruje
zdarzenia wcisniecia, puszczenia i poruszenia

#+begin_src scheme
  (define-type (Movement from: Point
			 via: (list-of Point)
			 to: Point)
    extending Magic
    with
    (define (draw! context::Cursor)
      (let ((last-point ::Point from))
	(for p in via
	  (painter:draw-line! last-point p)
	  (set! last-point p))
	(when to
	  (painter:draw-release! to)
	  (painter:draw-line! last-point to))
	(painter:draw-press! from)
	))
#+end_src

  i teraz rozmiar tego cacuszka powiniem wynosic
  rozmiar sciezki + marginesy


* 24.03.2024

wczoraj sie udalo wyeliminowac mala upierdliwosc z komunikatami
diagnostycznymi podczas ewaluacji

natomiast teraz mysl jest taka: skoro mamy przerwe w edycji,
to moze zamiast latania drobnych bugow, skupilibysmy sie
na doprowadzeniu uzywalnosci do jako takiego ladu?

co konkretnie przez to rozumiem:

- poprawki w scrollowaniu edytora, tak zeby nie dalo sie
  wychodzic poza prostokat dokumentu (i zeby nie dalo sie
  obracac) i zeby sie wyswietlaly scroll bary

- zeby edytor zapamietywal swoj stan (zawartosc ostatnio
  edytowanego dokumentu, a w przypadku desktopa
  rozmiar okna)

- zeby na androidzie dalo sie edytowac (i ew. budowac)
  kod GRASPa

- i w sumue to zeby na desktopie i w terminalu tez sie dalo

a no i fajnie by tez bylo pisac testy dla tego drag&dropa
 

#+begin_src

          
          
          

#+end_src


* 23.03.2024

Wielu rzeczy wczoraj planowanych jeszcze sie nie udalo.
Ale to nic, bo za tydzien bedziemy mieli kolejny sprint.

Teraz pytanie, czy lepiej sie skupic na 'grzebieniowej'
reprezentacji, czy na poprawie bugow?

Bugi w edycji mamy teraz takie, ze:
- pole tekstowe przy zapisie plikow jest jakies ble

no i te wczesniejsze bugi:

+ czasem nadal dostajemy komunikat, ze znak rozni sie od
  oczekiwanego
+ po przelaczeniu dokumentu na desktopie nie dziala zoomowanie
+ zdarzenia z klawiatury nie sa prawidlowo propagowane
+ nie dziala przegladarka plikow na androidzie
  (nie widzi plikow)
+ czasem po zaladowaniu innego dokumentu nie dziala menu
  na kliencie desktopowym
+ klient terminalowy wiesza sie w tajemniczy sposob
+ brak oznaczenia komentarzy liniowych
+ nie dziala drag&drop na komentarzach
+ drag&drop na nie-komentarzach tez ma swoje problemy
+ dziwne rzeczy sie dzieja z selekcja na granicy atomow
  (na pewno na Androidzie)

* 22.03.2024

dzisiaj/jutro bysmy:
- dokonczyli testy kasowania i dodawania elementow do quote'ow
- sprobowali zaimplementowac taka funkcjonalnosc, ze:
  - jak jestesmy na nawiasie albo atomie i nacisniemy `, to owijamy
    wyrazenie w quasiquote
  - podobnie z , oraz '
  - jak wcisniemy te przyciski bedac na spacji, to po prostu
    dodajemy nowego quote'a/quasiquote'a/unquote/a z pusta lista
  - jezeli jestesmy na liscie majacej dokladnie jeden element,
    to powinnismy sie moc przelaczac poimedzy 'x a '(x)
  - wcisniecie tych przyciskow po raz drugi powinno nam zmieniac
    tryb


No dobra, to jakis tam projekt mamy, i moze sie nam go uda lepiej
lub gorzej zrealizowac.

Tymczasem warto by bylo sie zastanowic nad szerzymi kwestiami
rozwojowymi.

Pierwsza rzecz, to w kolejnym tygodniu bede prowadzil prezentacje
i metaprogramowaniu, i to na niej chcialbym sie skupic.

Druga sprawa, to zmiana reprezentacji. I tutaj rzecz wyglada tak,
ze zmiany musiayby dotknac nastepujacych modulow:
- oczywiscie samego (editor types primitive)
- parsera (no bo jakze by inaczej)
- ale rowniez (editor document history-tracking)

Strategia natomiast musialaby byc taka, ze bysmy musieli robic tak,
zeby dotychczasowe testy nam przechodzily.

Zaleta jest taka, ze mamy juz gotowe paintery, wiec kod powinien
wzglednie od razu dzialac.

No dobra, to teraz myk jest taki:
- rozwijac grzebien to bysmy woleli raczej w tle
- byc moze fajnie by bylo przejsc na nowa reprezentacje
  jeszcze przed naprawa bugow z edycja komentarzy
- a moze lepiej wydac wersje 1.0 jeszcze na starej
  reprezentacji


OK, to sie sprobujmy teraz zajac tym bledem, ze jak mamy
dokument wczytany z pliku i skasujemy pierwsze wyrazenie,
to pozostaje nam wszystko oprocz pierwszego wyrazenia.

Ogolnie wydaje sie, ze blad moze byc zwiazany z tym, ze
cos mylnie jest brane za dokument, a co innego - za wyodrebniona
rzecz.


* 21.03.2024

dzisiaj sie zajmiemy kasowaniem wyrazen wewnatrz quote'ow

* 20.03.2024

dzis bysmy zrobili tak, zeby operacja wklejania pudelka
nie powodowala cofania kursora, zas operacja wstawiania
pudelka to powodowala

no dobra, to juz mamy.

to teraz moze sprobujmy wrocic do naszych Quotationow
(a jutro bysmy sie zajeli owijaniem ich w ramach
operacji edycji)

* 19.03.2024

walczymy sobie z tymi kursorami, i zastanawiajace jest,
czy nie powinnismy wprowadzic nowej reprezentacji dla
dokumentu:


#+begin_src scheme
  (define-object (Comb)::Tile
    ;; the name is Comb, because its stands for
    ;; a combination, but also because items and
    ;; spaces are meant to be interleaved in the same
    ;; way the teeth in a comb are interleaved with
    ;; spaces/hair
    (define items ::(instance java.util.List Tile)
      (java.util.ArrayList))

    ;; we assume here that 
    (define spaces ::(instance java.util.List Space)
      (java.util.ArrayList))

    ;; the number of elements in spaces should always
    ;; be one greater than 

    (define (draw! context::Cursor)::void
      (for i::int from 0 below (items:size)
	   ...))

    (define (extent)::Extent
      ...)

    (define (remove-at! index::int)::Tile
      ...)

    (define (insert-at! index::int item::Tile)::void
      ...)

    (spaces:add (Space)))
#+end_src

no dobra, to wyglada na to, ze teraz nas czeka sporo roboty.

musimy bowiem:
- zaimplementowac Comb
- wymienic parser
- obsluzyc wszystkie operacje (dodawanie, usuwanie, zamiana)
- naprawic ewaluator

Do tego dochodza jeszcze takie kwestie, ze operacje Insert etc.
uzywaja list linkowanych
  
I moze dlatego warto by jeszcze bylo sprawdzic, czy jestesmy
w stanie naprawic tego quote'a i poruszanie kursorem.

No i dobra, to co teraz mamy wydaje sie w jakims sensie
ok, aczkolwiek byloby dobrze rozprzegnac poruszanie kursorem
od wstawiania wyrazenia.

* 18.03.2024

no to teraz plan jest taki, zeby override'owac
set-car! oraz set-cdr! w quote'ach

jak na razie samo w sobie to nic nie dalo.

chyba trzeba to troche lepiej przemyslec, tak zeby
dzialalo 'bezszwowo' z dotychczasowym systemem edycji

#+begin_src scheme
  (quote ())
  ;      ^ ---  ([ 3)
  []
#+end_src

no i dobra, i teraz jaki jest problem?

albo: jakie sa pomysly na rozwiazanie go?

Jeden pomysl to potraktowac Quotation jako "cons".
No ale zasadniczo widzimy, ze to nie dziala.

Stad inny pomysl jest taki, zeby dla interfejsu
"Enchanted" stworzyc jakas specjalna sciezke
w "insert-character!".  


* 15.03.2024

no dobra, to moze sprobujmy zrobic tak:
- dodawanie elementow do quote'ow
- quote'owanie wyrazen

* 14.03.2024

no dobra, cos tam naprawilismy z tym enterem.

to teraz moze sie tymi quote'ami zajmijmy

pierwszy pomysl jest taki, zeby potraktowac
quote'y jako consy, ale w gruncie rzeczy wydaje
sie to nieco problematyczne.

zatem mozliwe, ze trzeba by bylo stworzyc
interfejs, ktory bylby implementowany zarowno
przez cons, jak i przez Quote

No ale teraz tak:

Jest kilka spraw. Zasadniczo chodzi o to, ze teraz robimy tak,
ze wydobywamy sobie rodzica elementu, na ktorym chcemy operowac,
no bo chodzi o to, ze na przyklad taki backspace moze nam
usunac element.

* 13.03.2024

wracamy do naszej listy:
- czasem nadal dostajemy komunikat, ze znak rozni sie od
  oczekiwanego
- po przelaczeniu dokumentu na desktopie nie dziala zoomowanie
- nie dziala dodawanie i usuwanie elementow do Quotationow
- zdarzenia z klawiatury nie sa prawidlowo propagowane
- nie dziala przegladarka plikow na androidzie
  (nie widzi plikow)
- czasem po zaladowaniu innego dokumentu nie dziala menu
  na kliencie desktopowym
- klient terminalowy wiesza sie w tajemniczy sposob
- brak oznaczenia komentarzy liniowych
- nie dziala drag&drop na komentarzach
- dziwne rzeczy sie dzieja z selekcja na granicy atomow
  (na pewno na Androidzie)
- jak mamy "[]| " i wcisniemy enter, to sie dzieje dosc
  dziwacznie

* 12.03.2024

to dzis bysmy sprobowali zrobic odczarowywanie steppera

no dobra, to chyba co nieco sie tutaj udalo, ale jeszcze
nie wszystko, bo sie nam Stepper zmienia na PlayerWithControls.

Dlatego dobrze by bylo sprobowac zrobic tak, zeby ta operacja
zrobila sie idempotentna.

To moze sprobujmy sobie chociaz opisac, na czym w tej chwili
polega problem. Otoz aktualnie mamy takie cos:

#+BEGIN_SRC scheme
  (define-simple-extension (PlayerWithControls player::Player) ;::Enchanted
    (bordered
     (below
      player
      (beside
	(Button label: "" action: (lambda () (player:rewind!)))
	(Button label: " " action: (lambda () (player:back!)))
	(Button label: "  " action: (lambda () (player:play!)))
	(Button label: " " action: (lambda () (player:next!)))
	(Button label: "" action: (lambda () (player:fast-forward!))))
      )))

  (set! (extension 'Stepper)
      (object (Extension)
	((enchant source::cons)::Enchanted
	 (otherwise (begin
		      (WARN "Unable to create Stepper from "source)
		      #!null)
	   (parameterize ((cell-access-mode CellAccessMode:Editing))
	     (and-let* ((`(Stepper ,expression) source))
	       (PlayerWithControls (Stepper expression))))))))

#+END_SRC

Czyli od strony mechanizmu wszystko wydaje sie OK, tylko problemem
jest wprowadzona przez nas wieloznacznosc terminu Stepper.

Plan jest zatem taki, zeby:
- przemianowac Stepper na StepperContent
- z PlayerWithControls uczynic z powrotem zwykla funkcje
- odpowiednio zdefinowac rozszerzenie Stepper

Przy okazji powinnismy zadbac o to, zeby:
- ewaluacja wyrazenia Stepper dawala nam odpowiedni przedmiot
- define-simple-extension samo dodawalo rozszerzenie do haszmapy

No dobra, to na razie mamy tyle ile mamy.


* 11.03.2024

Z testu wynika nam, ze problemem jest to, ze kursor ma taka postac:
(0 right right right bottom element 1 1)
w czym zasadniczo nie ma nic zlego, tyle ze probujemy podzielic
symbol "right" przez 2

Czyli bysmy chcieli miec funkcje "skip-all" taka, ze

#+BEGIN_SRC scheme
    (e.g.
      (skip-prefix-containing-any (isnt _ integer?)
				  '(0 right right right bottom element 1 1))
      #;< ===> (1 1))

  (define (skip-prefix-containing-any satisfying?::predicate elements::list)::list
    (let ((candidate elements))
      (let loop ((elements elements))
	(match elements
	  (`(,first . ,rest)
	   (when (satisfying? first)
	     (set! candidate rest))
	   (loop rest))
	  ('()
	   candidate)))))
#+END_SRC

No dobra, to wyglada na to, ze kasowanie zaczarowanego wyrazenia mamy juz jako tako
ogarniete. Teraz pozostaje nam jeszcze odczarowywanie go (i wydaje sie, ze bedziemy
chcieli to robic na podobna modle, tzn. ucinac kawalek kursora, ktory nie jest
"liczbowy").

Natomiast przy okazji mysli sie taki oto pomysl, zeby od razu zrobic nawigacje po
guzikach.
Co wiecej, byc moze ta nawigacja juz jest w jakiejs mierze zrobiona, i moglibysmy
to sprobbowac przetestowac.

No dobra, to wyglada na to, ze nawigowanie po przyciskach za pomoca klawiatury
ogolnie dziala, tylko musielibysmy zrobic dwie rzeczy:
- zeby pogrubiac albo rozjasniac przycisk, na ktorym znajduje sie kursor
- zeby animowac wcisniecie przycisku

* 10.03.2024

Jak na razie wyglada na to, ze bedziemy potrzebowac nieco grubszych
zmian w projekcie systemu rozszerzen.

Rzecz konkretnie ma sie w taki sposob, ze teraz jak probujemy
odczarowywac zaklete pudelka (takie, ktore wewnetrznie rowniez maja
jakas swoja strukture), to wychodzi to roznie - bo przykladowo
ostatnio zamiast oryginalnego wyrazenia dostalismy guzik.

Zatem musimy zmienic funkcje odczarowujaca w taki sposob, zeby
odczarowywala najmniej zagniezdzone rozszerzenie.

Drugi problem, jaki chcielibysmy zdiagnozowac (i oczywiscie naprawic)
dotyczy kasowania rozserzenia. Z jakiegos powoduje wydaje sie dzialac
w przypadku guzika, ale w przypadku steppera juz nie dziala.

Poza tym rzeczy wygladaja tak, ze w kolejnym tygodniu bedziemy mieli
chyba 6 dni commitowych z rzedu, i wowczas bedziemy sie zajmowac
diagnozowaniem i naprawianiem drobniejszych bugow.

Po tym ma nastapic tydzien przerwy, a po nim kolejne 2 tygodnie
orki. W tym wolnym tygodniu dobrze by bylo sie zajac przygotowaniem
prezentacji o meta-programowaniu do pracy.

No dobra, to moze zacznijmy od tego kasowania steppera, bo na to
mamy juz w zasadzie napisany test


* 08.03.2024

#+BEGIN_SRC scheme
   (define-syntax dropping-type-signatures
     (syntax-rules (::)
       ((_ all one () (processed ...))
	(all processed ...))

       ((_ all one (arg :: type args ...) (processed ...))
	(_ all one (args ...) (processed ... (one arg))))

       ((_ all one (arg args ...) (processed ...))
	(_ all one (args ...) (processed ... (one arg))))
       ))


   (define-syntax-rule (define-simple-extension (name args ...) . body)
     (define-object (name . args)::Enchanted ;<
       (define (typename)::String (symbol->string 'name))

       (define (value)::cons
	 (cons (Atom #;< (symbol->string 'name))
	       (dropping-type-signatures cons*
					 identity-syntax
					 (args ...) ())))
       (SimpleExtension (begin . body))))
#+END_SRC

No dobra, to teraz majac takie cudo, chcielibysmy sobie
zdefiniowac stepper, ktory daloby sie odczarowac

#+BEGIN_SRC scheme
  (define-simple-extension (PlayerWithControls player::Player)
    (bordered
     (below
      player
      (beside
       (Button label: "" action: (lambda () (player:rewind!)))
       (Button label: " " action: (lambda () (player:back!)))
       (Button label: "  " action: (lambda () (player:play!)))
       (Button label: " " action: (lambda () (player:next!)))
       (Button label: "" action: (lambda () (player:fast-forward!))))
      )))
#+END_SRC

czy to ma szanse zadzialac?

* 07.03.2024

#+BEGIN_SRC scheme
  (define-object (SimpleExtension content::Enchanted)::Enchanted
    (define (tap! finger::byte  x::real y::real)::boolean
      (content:tap! finger x y))

    (define (press! finger::byte x::real y::real)::boolean
      (content:press! finger x y))

    (define (second-press! finger::byte #;at x::real y::real)::boolean
      (content:second-press! finger #;at x y))

    (define (double-tap! finger::byte x::real y::real)::boolean
      (content:double-tap! finger x y))

    (define (long-press! finger::byte x::real y::real)::boolean
      (content:long-press! finger x y))

    (define (key-typed! key-code::long context::Cursor)::boolean
      (content:key-typed! key-code context))

    (define (scroll-up! left::real top::real)::boolean
      (content:scroll-up! left top))

    (define (scroll-down! left::real top::real)::boolean
      (content:scroll-down! left top))

    (define (scroll-left! left::real top::real)::boolean
      (content:scroll-left! left top))

    (define (scroll-right! left::real top::real)::boolean
      (content:scroll-right! left top))

    (define (zoom-in! left::real top::real)::boolean
      (content:zoom-in! left top))

    (define (zoom-out! left::real top::real)::boolean
      (content:zoom-out! left top))

    (define (rotate-left! left::real top::real)::boolean
      (content:rotate-left! left top))

    (define (rotate-right! left::real top::real)::boolean
      (content:rotate-right! left top))

    (define (draw! context::Cursor)::void
      (content:draw! context))

    (define (cursor-under* x::real y::real path::Cursor)::Cursor*
      (content:cursor-under* x y path))

    (define (extent)::Extent
      (content:extent))

    (define (typename)::String #!abstract)

    (define (part-at index::Index)::Indexable*
      (let ((target (content:part-at index)))
	(if (eq? target content)
	    (this)
	    target)))

    (define (first-index)::Index
      (content:first-index))

    (define (last-index)::Index
      (content:last-index))

    (define (next-index index::Index)::Index
      (content:next-index index))

    (define (previous-index index::Index)::Index
      (content:previous-index index))

    (define (index< a::Index b::Index)::boolean
      (content:index< a b)) ;>

    (define (value)::Object
      #!abstract)

    (Magic))

  (define-syntax-rule (define-simple-extension (name args ...) . body)
    (define-object (name . args)::Enchanted
      (define (value)::cons
	(cons (Atom #;< (symbol->string 'name))
	      (without-type-signatures args ...)))
      (SimpleExtension (begin . body))))
#+END_SRC

dalsze plany: stworzyc ObjectProxy i ProcedureProxy. Ten pierwszy
bedzie wyswietlal wszystkie wlasciwosci i metody, a ten drugi
- typy argumentow.

* 06.03.2024

dzis probujemy zrefaktoryzowac Stepper tak, zeby byl wyrazeniem
(a nie "extension"em), tak zeby finalnie skasowac cala tablice
oraz klase Extension

#+BEGIN_SRC scheme
  (define-extension (VisualStepper expression: Expression
				   step: int := 0)
    (PlayerWithControls (Stepper expression step)))
#+END_SRC

czy definicja moglaby tak wygladac?

Jaki jest problem?

Rzecz w tym, ze mamy juz obiekt Stepper, ktory powinien sie
serializowac do (Stepper expression).

Czyli raczej powinnismy sie skupic na PlayerWithControls.

I tutaj plan jest taki, zeby zmienic Player na
EnchantedPlayableAnimation, zas PlayerWithControls
na Player.

I wowczas bysmy mieli taki dwupoziomowy schemat: zamiast
(Stepper expression) bysmy mieli (Player (Stepper 'expression 0)).

Czyli moze zamiast

#+BEGIN_SRC scheme
  (define (PlayerWithControls player::Player)::Enchanted
    (bordered
     (below
      player
      (beside
       (Button label: "" action: (lambda () (player:rewind!)))
       (Button label: " " action: (lambda () (player:back!)))
       (Button label: "  " action: (lambda () (player:play!)))
       (Button label: " " action: (lambda () (player:next!)))
       (Button label: "" action: (lambda () (player:fast-forward!))))
      )))
#+END_SRC

bysmy mieli

#+BEGIN_SRC scheme
  (define-simple-extension (PlayerWithControls player::Player)
    (bordered
     (below
      player
      (beside
       (Button label: "" action: (lambda () (player:rewind!)))
       (Button label: " " action: (lambda () (player:back!)))
       (Button label: "  " action: (lambda () (player:play!)))
       (Button label: " " action: (lambda () (player:next!)))
       (Button label: "" action: (lambda () (player:fast-forward!))))
      )))
#+END_SRC

I co by to nam dawalo?


* 05.03.2024

pozostale bledy
- czasem nadal dostajemy komunikat, ze znak rozni sie od
  oczekiwanego
- po przelaczeniu dokumentu na desktopie nie dziala zoomowanie
- nie dziala dodawanie i usuwanie elementow do Quotationow
- zdarzenia z klawiatury nie sa prawidlowo propagowane
- nie dziala przegladarka plikow na androidzie
  (nie widzi plikow)
- czasem po zaladowaniu innego dokumentu nie dziala menu
  na kliencie desktopowym
- klient terminalowy wiesza sie w tajemniczy sposob
- brak oznaczenia komentarzy liniowych
- nie dziala drag&drop na komentarzach
- dziwne rzeczy sie dzieja z selekcja na granicy atomow
  (na pewno na Androidzie)

duzy temat na dzis i na jutro to uporzadkowanie steppera

no bo ogolne to bysmy chcieli, zeby;
- zapamietywac, na ktorym kroku ewaluacji wyrazenia
  jestesmy
- Stepper byl wyrazeniem (w takim samym sensie, jak Button)
i pewnie tez zeby izomorfizm miedzy wyrazeniem a stepperem
utrzymywal sie automatycznie

no ale dobra, na razie mamy cos co jakby dziala, wiec wyjdzmy od tego.

w tej chwili rozszerzenie jest tak napisane:

#+BEGIN_SRC scheme

  (define-interface Playable ()
    (rewind!)::void
    ...
    (fast-forward!)::void)

  (define-interface Player (Enchanted Playable Animation))

  (define-object (Stepper initial-expression::Tile)::Player
    ...
    (define (draw! context::Cursor)::void
      (current-morph:draw! context))
    ...
    (Magic))

  (define (PlayerWithControls player::Player)::Enchanted
    (bordered
     (below
      player
      (beside
       (Button label: "" action: (lambda () (player:rewind!)))
       (Button label: " " action: (lambda () (player:back!)))
       (Button label: "  " action: (lambda () (player:play!)))
       (Button label: " " action: (lambda () (player:next!)))
       (Button label: "" action: (lambda () (player:fast-forward!))))
      )))

  (set! (extension 'Stepper)
	(object (Extension)
	  ((enchant source::cons)::Enchanted
	   (otherwise (begin
			(WARN "Unable to create Stepper from "source)
			#!null)
	     (parameterize ((cell-access-mode CellAccessMode:Editing))
	       (and-let* ((`(Stepper ,expression) source))
		 (PlayerWithControls (Stepper expression))))))))

#+END_SRC

a dla odmiany np. Button jest zdefiniowany tak:

#+BEGIN_SRC scheme

  (define-type (Button action: (maps () to: void)
		       label: string)
    extending Magic
    with
    ((draw! context::Cursor)::void
     ...)
    ...)

  (set! (extension 'Button)
      (object (Extension)
	((enchant source::cons)::Enchanted
	 (try-catch
	  (or (as Button (eval source)) #!null)
	  (ex java.lang.Throwable
	      (WARN "Unable to create Button from "source": "
		    (java.lang.String:valueOf ex))
	      #!null)))))

#+END_SRC

Natomiast ogolnie chcielibysmy w ogole zrezygnowac z czegos takiego,
jak extension, natomiast zamiadt zaczarowywania i odczarowywania
bysmy mieli ciag operacji:
- ewaluacja wyrazenia
- skasowanie wyewaluowanego wyrazenia

czyli docelowo powinny nam wyleciec:
- disenchant-expression!
- enchant-expression!
- odpowiednie operacje edycji
- tablica extension

#+BEGIN_SRC scheme

;; document-operations
(define/kw (enchant-expression! at: cursor::Cursor := (the-cursor)
				in: document := (the-document))
  (parameterize ((cell-access-mode CellAccessMode:Evaluating))
    (and-let* ((expression ::cons (the-expression at: cursor
						  in: document))
	       (`(,keyword::symbol . ,data) expression)
	       (magic ::Extension (extension keyword))
	       (enchanted ::Enchanted (magic:enchant expression)))
      (set! (origin enchanted) expression)
      (replace-expression! at: cursor with: enchanted
			   in: document)
      enchanted)))

(define/kw (disenchant-expression! at: cursor::Cursor := (the-cursor)
				   in: document := (the-document))
  (and-let* ((enchanted ::Enchanted (the-expression at: cursor
						    in: document))
	     (expression (enchanted:value)))
    (replace-expression! at: cursor with: expression
			 in: document)
    expression))

;; history-tracking

(define-type (EnchantExpression at: Cursor := (the-cursor))
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (otherwise #!null
     (and-let* ((enchanted ::Element
			  (enchant-expression! at: at
					       in: document)))
       (recons (enchanted:first-index)
	       (cursor-core at document)))))

  ((inverse)::Edit
   (DisenchantExpression at: at)))

(define-type (DisenchantExpression at: Cursor := (the-cursor))
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (otherwise #!null
     (and-let* ((expression ::Element
			    (disenchant-expression! at: at
						    in: document)))
       (recons (expression:first-index)
	       (cursor-core at document)))))

  ((inverse)::Edit
   (EnchantExpression at: at)))

;; editor types extensions extensions

(define-simple-class Extension ()
  ((enchant source::cons)::Enchanted
   #!abstract)
  )

(define-constant extension
  (mapping (keyword)
	   (begin
	     (WARN "no extension for "keyword)
	     #f)))

(define-property (origin enchanted) enchanted)
   
#+END_SRC

jednakowoz zanim to bedzie moglo nastapic, Stepper musi sie
ewaluowac do steppera - a zanim do tego dojdzie, musimy
wykombinowac, jak sie za to zabrac


* 04.03.2024

mamy problem z deserializacja Steppera - bo to nie jest
"osobny obiekt", tylko kompozycja kilku obiektow

ale ogolnie to z tym stepperem jest nieco wiecej problemow.
Konkretnie, on jest zdefiniowany jako zwykla funkcja, ktora
zwraca obiekt Bordered. i to samo w sobie jest fajne.

tyle ze po odczarowaniu nie chcemy dostac Bordered, a Stepper.

No to zacznijmy od tego, ze bysmy chcieli, zeby Stepper byl
zwyklym wyrazeniem, ktore ewaluuje sie do steppera. W tym celu
zamiast [Stepper [! 5]] bysmy musieli pisac [Stepper '[! 5]].

Ok, moze tym tematem sie zajmiemy pozniej, a na razie skupmy
sie na kasowaniu wyrazen.


* 03.03.2024

to teraz bysmy sie moze zajeli usuwanuem zaczarowanych pudelek
oraz odczarowywaniem pudelek

* 01.03.2024

to moze dzis sie zajmijmy "[1 "

to plan jest taki, zeby stworxtc modul "test-regressions.scm"

ale moze najpierw zajmiemy sie warningami?

* 29.02.2024

dzisiaj matomiast mozemy:
- na szybko zajac sie kopiowaniem selekcji
- ale tez zrobic cos, zeby nievwklejac cudzyslowow
- jest tez taki pomysl, zeby przy wklejaniu selekcji
  w spacje zachowac typ oryginalu

  no dobra. a tu po drodze sie jeszcze objawia zupelnie
  nowy pomysl, mianowicie zeby miec nowa-stara reprezentacje
  dla dokumentu

  tzn ze mamy cos takiego jak Box, ktory ma wskaznik na
  Spacje

  na razie chyba nie idzmy ta droga :/

wiec na razie plan jest taki, ze bedziemy sobie opisywac i
lowic bledy, i w miare mozliwosci pisac testy

no to taka lista bledow:
- czasem dostajemy komunikat, ze znak rozni sie od
  oczekiwanego
- po przelaczeniu dokumentu na desktopie nie dziala zoomowanie
- jak napiszemy np. "[1 ", to potem backspace nie chce usunac
  tej spacji
- nie dziala dodawanie i usuwanie elementow do Quotationow
- nie dziala odczarowywanie pudelek
- nie da sie usuwac zaczarowanych pudelek
- zdarzenia z klawiatury nie sa prawidlowo propagowane
- nie dziala przegladarka plikow na androidzie
  (nie widzi plikow)
- czasem po zaladowaniu innego dokumentu nie dziala menu
  na kliencie desktopowym
- klient terminalowy wiesza sie w tajemniczy sposob
- brak oznaczenia komentarzy liniowych
- nie dziala drag&drop na komentarzach
- dziwne rzeczy sie dzieja z selekcja na granicy atomow
  (na pewno na Androidzie)

* 28.02.2024

dzis moze sprobujemy zrobic wycinanie selekcji

* 27.02.2024

mamy zrobione nadpisywanie selekcji.
Wydaje sie, ze w analogiczny sposob moglibysmy zrobic
- kasowanie selekcji (po wcisnieciu "backspace")
- wycinanie selekcji
- wklejanie selekcji

i co dalej?

dalej bysmy:
- zajeli sie lowieniem, katalogowaniem i naprawianiem bugow
  (i przy okazji pisaniem testow)
- popracowali nad tym, zeby GRASP zachowywal sie bardziej
  jak zwyczajny edytor tekstu, a mniej jak plotno
  

* 26.02.2024

to co? teraz selekcje?

to moze bysmy zrobili tak, ze bysmy zaczeli od kasowania
i nadpisywania selekcji

* 25.02.2024

plan teraz jest taki, zeby:
- uwspolnic obsluge schowka
- obsluzyc selekcje wewnatrz jednego obiektu, i to tak:
  - kopiowanie
  - wycinanie
  - wklejanie
  - kasowanie
  - nadpisywanie

* 23.02.2024

#+BEGIN_SRC scheme

  (define-alias Transferable java.awt.datatransfer.Transferable)
  (define-alias DataFlavor java.awt.datatransfer.DataFlavor)

  (define-alias StringSelection java.awt.datatransfer.StringSelection)
  (define-alias AWTClipboard java.awt.datatransfer.Clipboard)
  (define-alias ClipboardOwner java.awt.datatransfer.ClipboardOwner)

  (define-interface OwnClipboard (Clipboard ClipboardOwner))

  (define-object (AWTSystemClipboard clipboard::AWTClipboard)
    ::OwnClipboard

    (define own-content ::list '())
    (define own-clip-data ::Transferable #!null)

    (define (try-parse item ::Transferable)::pair
      (let* ((reader ::java.io.Reader
		     (DataFlavor:stringFlavor:getReaderForText item))
	     (input ::gnu.kawa.io.InPort (gnu.kawa.io.InPort reader)))
	(with-input-from-port input
	  (lambda ()
	    (let*-values (((expression preceding-space) (read-list 1))
			  ((following-space) (read-spaces))
			  ((next) (peek-char)))
	      (if (eof-object? next)
		  expression
		  (cons (text input) '())))))))

    (define (upload! new-content ::pair)::void
      (and-let* ((`(,head . ,tail) new-content) ;<
		 (text (show->string head))
		 (clip ::Transferable (StringSelection text)))
	(clipboard:setContents clip (this))
	(set! own-clip-data clip)
	(set! own-content new-content)))

    (define (content)::list
      (let ((clip ::Transferable (clipboard:getContents)))
	(if (eq? clip own-clip-data)
	    (copy own-content)
	    (try-parse clip))))
    )

#+END_SRC

* 22.02.2024

jako tako dzialajacy schowek udalo sie wymodzic
(choc jeszcze nie dziala doskonale)

to teraz kolejnym krokiem powinna byc implementacja
schowka w kliencie desktopowym

a pozniej chyba obsluga selekcji

no to przywolajmy sobie:

#+BEGIN_SRC scheme
  (define-alias Transferable java.awt.datatransfer.Transferable)
  (define-alias StringSelection java.awt.datatransfer.StringSelection)
  (define-alias AWTClipboard java.awt.datatransfer.Clipboard)

  (let ((clipboard ::AWTClipboard (java.awt.Toolkit:getSystemClipboard)))
    (clipboard:setContents (as Transferable something)
			   (as ClipboardOwner (this)))
    (let ((content ::Transferable
		   (clipboard:getContents (this) #;unused)))
      ...))

#+END_SRC

java.awt.datatransfer.Transferable to interfejs implementowany
m.in. przez java.awt.datatransfer.StringSelection
z metoda java.lang.Object getTransferData(DataFlavor flavor)
gdzie argument flavor powinien przyjmowac wartosc
java.awt.datatransfer.DataFlavor:stringFlavor

czyli bedzie StringSelection(data)

no dobra, wezmy sobie impkementacje androidowa:

#+BEGIN_SRC scheme

(define-object (AndroidSystemClipboard clipboard::AndroidClipboard)
  ::Clipboard

  (define own-content ::list '())
  (define own-clip-data ::AndroidClipData #!null)
  
  (define (try-parse item ::AndroidClipData:Item)::Element
    (let ((input (item:getText)))
      (with-input-from-string input
	(lambda ()
	  (let*-values (((expression preceding-space) (read-list 1))
			((following-space) (read-spaces))
			((next) (peek-char)))
	    (if (eof-object? next)
		(or (and-let* ((`(,inside) expression))
		      inside)
		    expression)
		(text input)))))))
  
  (define (upload! new-content ::pair)::void
    (and-let* ((`(,head . ,tail) new-content)
	       (text (show->string head))
	       (clip ::AndroidClipData (AndroidClipData:newPlainText
				   "label" text)))
      (let rewrite ((input tail))
	(and-let* ((`(,head . ,tail) input))
	  (clip:addItem (AndroidClipData:Item
			 (show->string head)))
	  (rewrite tail)))
      (clipboard:setPrimaryClip clip)
      (set! own-clip-data clip)
      (set! own-content new-content)))
  
  (define (content)::list
    (let ((clip ::AndroidClipData (clipboard:getPrimaryClip)))
      (if (eq? clip own-clip-data)
	  (copy own-content)
	  (let ((n ::int (clip:getItemCount)))
	    (if (is n <= 0)
		'()
		(let* ((items ::list (cons (try-parse (clip:getItemAt 0))
					   '()))
		       (end ::list items))
		  (for i from 1 below n
		       (let ((item (try-parse (clip:getItemAt i))))
			 (set! (cdr end) (cons item '()))
			 (set! end (cdr end))))
		  items))))))
  )

#+END_SRC



* 21.02.2024

dzis kontynuujemy prace nad schowkiem systemowym na Androidzie

* 20.02.2024

- dzis bysmy zrobili to kopiowanie i sprobowali poczynic
  jakies kroki w kierunku integracji ze schowkiem systemowym
  - najpierw na Androidzie, a potem w AWT

aaa kopiowanie juz dziala!

no to od razu robimy costam ze schowkiem systemowym

* 19.02.2024

- obsluga schowka w pozostalych klientach
- refaktoryzacja spacji zeby poprawic klonowanie
- kopiowanie
- obsluga selekcji w obrebie jednego elementu
- wyjatki dla atomu
- integracja ze schowkami systemowymi

* 17.02.2024

dzisiaj nic nie robimy, ale mozna pozwolic umyslowi troche sobie
powedrowac

kilka rzeczy natomiast mamy:
- przywrocic 'propertisy' dla rzadkich cech komorek
  (pre-head-space, pre-tail-space, post-tail-space, dotted?)
- wycinanie komentarzy
- drag&drop stringow i komentarzy

tymczasem chcielibysmy zaimplementowac jeszcze zamykanie i otwieranie
pudelek (tzn. list i stringow)

* 16.02.2024

no to tak:
- wycinanie wyrazen dziala
- wklejanie wyrazen dziala
- wklejanie w tekst dziala
  - przy wklejaniu do atomu powinnismy uwazac na spacje i nawiasy

natomiast do zrobienia mamy:
- kopiowanie wyrazen
- wycinanie selekcji z tekstow
- wklejanie selekcji w tekst (zastepowanie)
- integracje ze schowkiem na androidzie
- na desktopie
- w terminalu?

i jeszcze w dalszej kolejnosci:
- selekcje przekraczajace granice wyrazen?

* 13.02.2024

mamy fragment wycinania, i teraz bysmy zrobili analogiczny
fragment wklejania i kopjowania.

a jak to bedziem to przynajmniej na desktopie i androidzie
bysmy zintegrowali ze schowkiem systemowym

* 11.02.2024

na razie mamy sobie kilka tajemniczych funkcjonalnosci,
czyli funkcje cursor-core oraz cursor-terminal+stem.

ten pierwszy to jest po prostu cdr kursora w sytuacji, gdy
part-at zwraca sam awoj obiekt

ten drugi przecina lancuch na dowolnej spacji, tak zeby
nie ewaluowac komenrarzy

teraz jeszcze zmienilismy (the-expression) zeby nie zwracal
spacyj

* 9.02.2024

plan jest taki, zeby na razie kompletnie olac heterogeniczne
selekcje, i jak najszybciej dojsc do tego, zebysmy mogli
wycinac, kopiowac i wklejac cale wyraxenia i selekcje
tekstowe

* 8.02.2024

no dobra, to mamy sobie zrefaktoryzowany mechanizm selekcji
- takze mozemy wrocic do naszych schowkowatych rozkminek

i teraz tak: pierwsza sprawa jest taka, ze byamy chcieli
serializowac selekcje

czyli np. [ a b ] [ c d ]
             ^       ^
takie cos bysmy chcieli serializowac do stringa
"b ] [ c"

ale jak to zrobic?

moze nie od tego powinnismy zaczac, tylko od kopowania calych
wyrazen

Kiedy selekcja dotyczy calego wyrazenia?
- kiedy jej zasieg wynosi 0
- kiedy selection-start ma postac `([ . ,kursor), a
  selection-end - `(] . ,kursor)

a ktorego wyrazenia dotyczy?
- jezeli jestesmy na spacji, to listy bezposrednio zawierajacej
  te spacje
- jezeli jestesmy na tekscie, to owego tekstu (czyli to moze byc
  tez komentarz liniowy albo blokowy)
- jezeli jestesmy na nawiasie otwierajacym albo zamykajacym,
  to rowniez listy
- jezeli jestesmy na atomie, to atomu

ponadto, jezeli zasieg jest rozny od zera, ale selection-start
ma postac `(,n . ,kursor) a selection-end - `(,m . ,kursor),
i kursor wskazuje na obiekt tekstowy, to kopiujemy zakres
obiektu tekstowego

jezeli zas idzie o oryginalny problem, to musimy miec sposob
na iterowanie po calych wyrazeniach: poczynajac od selection-start
sprawdzamy, czy jestesmy na spacji, nawiasie czy obiekcie tekstowym.

chodzi o to, ze chcemy sie znalezc na tym samym poziomie, na ktorym
jest selection-end, robiac w miare mozliwosci jak najwieksze kroki.

no to wezmy moze

[[[[a b] c] [d e] [f [g h]]] i]
     ^                 ^
     

* 7.02.2024

te wczorajsze pomysly wydaja aie ok, aczkolwiek lepiej
byloby pomyslec o jakims cache'owaniu

#+BEGIN_SRC scheme

    (define-parameter (the-selection-range) ::integer 0)

    (define-single-cache (selection-start+end cursor::Cursor
					      range::integer)
      ::(Values Cursor Cursor)
      (cond
       ((is range = 0)
	(values cursor cursor))

       ((is range < #;> 0)
	(values
	 (iterations (- range)
		     cursor-retreat
		     cursor)
	 cursor))

       ((is range #;< > 0) 
	(values
	 cursor
	 (iterations range
		     cursor-retreat
		     cursor)))))

    (define (the-selection)::(Values Cursor Cursor)
      (selection-start+end (the-cursor) (the-selection-range)))

#+END_SRC


* 6.02.2024

warto przemyslec dzialanie mechanizmu selekcji.

Chcielibysmy sobie celekcje reprezentowac jako pojedyncza liczbe,
gdzie 0 oznacza 'brak selekcji' (albo tylko biezacy obiekt),
liczba ujemna - selekcje zaczynajaca sie przed kursorem, zas
liczba dodatnia - selekcja zaczynajaca sie za kursorem.

I teraz wydaje sie, ze mamy kilka mozliwosci, jezeli idzie
o traktowanie selekcji:

- albo jak selekcje w edytorach tesktowych, gdzie traktujemy
  te liczbe jako ilosc iteracji 'cursor-advance' (dla liczb
  dodatnich)  badz 'cursor-retreat' (dla liczb ujemnych), ktore
  trzeba wykonac, zeby dojsc od kursora do zakotwiczenia selekcji
  
- albo w sposob bardziej strukturalny, czyli jezeli wyjedziemy
  kursore poza granice wyrazenia, w ktorym znajduje sie kursor,
  to przesuwamy kursor za to wyrazenie

tym niemniej, pierwsza mozliwosc jest implementowalna w ramach
drugiej

No dobra, to przyjmujemy na razie ren pierwszy wariant, a jesli
bedzie trzeba, to po prostu zmienimy zachowanie funkcji.

Czyli tak: zaczmiemy od tego, ze przemodelujemy sobie
zachowanie (the-selection) tak, zeby wywalic (the-selection-anchor),
bo to byl bardzo kiepski i upierdliwy design.

Jest zdefiniowany w (editor interfaces elements).

#+BEGIN_SRC scheme

  (define (the-selection)
    ;; temporary override:
    ;;(values (the-cursor) (the-cursor))
  
    ;; implicitly parameterized with (the-document),
    ;; (the-cursor) and (the-selection-anchor),
    ;; because cursor< is parameterized with (the-document)
    ;; and the remaining parameters are used directly

    (if (is (the-selection-anchor) cursor< (the-cursor))
	 (values (the-selection-anchor) (the-cursor))
	 (values (the-cursor) (the-selection-anchor))))

#+END_SRC

a chcielibysmy raczej cos w rodzaju:

#+BEGIN_SRC scheme

  (define selection-range ::int 0)

  (define (the-selection)::(Values Cursor Cursor)
    (cond
     ((is selection-range = 0)
      (values (the-cursor) (the-cursor)))

     ((is selection-range < #;> 0)
      (values
       (iterations (- selection-range)
		   cursor-retreat
		   (the-cursor))
       (the-cursor)))

     ((is selection-range #;< > 0) 
      (values
       (the-cursor)
       (iterations selection-range
		   cursor-retreat
		   (the-cursor))))))

#+END_SRC



* 5.02.2024

plany mamy takie mniej wiecej:
- integracja ze schowkiem (najfajniejsze!)
- wizualizacja stanu historii
- dlaczego zaquote'owane wyrazenie sie tak dziwnie renderuje?

* 4.02.2024

incydentalnie odkrylismy, ze funkcje w module (editor types spaces)
w ogole nie uwzgledniaja komentarzy

* 3.02.2024

no dobra, czyli patrzac oglednie, to mamy cos takiego, ze:
- na Androidzie jest cos takiego, jak Clip, zlozonego z wielu itemow
- na Desktopie musimy prosic o uprawnienia do schowka
- nie wiadomo czy w kliencie terminalowym jest jakakolwiek szansa
  na dostep do systemowego schowka

zasadniczy pomysl jest taki, zeby stworzyc 'wlasny schowek', ktory
dzialalby tak samo we wszystkich trzech klientach, a ktory
dodatkowo i niejako w tle synchronizowal sie ze schowkiem systemowym
tam gdzie to mozliwe

wowczas operacja wycinania i wklejania dodatkowo by przesylala
obiekty do schowka systemowego, natomiast operacja wklejania
sprawdzalaby, czy obiekt w schowku systemowym jest taki sam,
jak w lokalnym schowku


* 2.02.2024

ogolny zamysl jest taki:
1. jezeli jestesmy wewnatrz stringa albo komentarza blokowego,
   to wklejamy zawartosc schowka jako tekst
2. w przeciwnym razie probujemy zawartosc schowka
   przeparsowac i zwrocic wynik parsowania (a jesli to sie
   nie powiedzie, to wklejamy calosc jako tekst)

no dobra, ale teraz musimy jakos ogarnac uzywanie schowka

na JVM:

#+BEGIN_SRC scheme
  (define-alias Transferable ...)

  (let ((clipboard ::java.awt.datatransfer.Clipboard
		   (java.awt.Toolkit:getSystemClipboard)))
    (clipboard:setContents (as Transferable something)
			   (as ClipboardOwner (this)))
    (let ((content ::Transferable
		   (clipboard:getContents (this) #;unused)))
      ...))

#+END_SRC

na Androidzie:

#+BEGIN_SRC scheme
  (define-alias AndroidClipboard android.content.ClipboardManager)
  (define-alias AndroidClipData android.content.ClipData)

  (let ((clipboard ::AndroidClipboard
		   (activity:getSystemService
		    android.content.Context:CLIPBOARD_SERVICE)))
    (clipboard:setPrimaryClip some)
    (let ((clip ::AndroidClipData (clipboard:getPrimaryClip)))
      ;;getItemAt(int), getItemCount(), addItem(ClipData.Item)

#+END_SRC


* 1.02.2024

jupi! na Androidzie wszystko zasadniczo wydaje sie dzialac!

jest jeszcze klika drobnych problemow przy zchodzeniu na stringa,
i trzeba przetestowac w terminalu i na desktopie, ale wyglada na to,
ze wreszcie mozemy isc ze swoim zyciem dalej.

dobrze, tylko dokad?

na sobote mozemy sobie w zasadzie zcherrypickowac poprawke
w obsludze walka myszy i jestesmy urobieni.

natomiast z takich wiekszych konkretow, to bysmy chcieli sie zajac
mechanizmem selekcji.

i pierwsza zmiana, jaka bysmy zrobili, to zastapienie w selekcji
kursora (the-selection-anchor) pojedyncza liczba.

#+BEGIN_SRC scheme
(define-parameter (the-selection)::integer 0)
#+END_SRC

i oczywiscie nalezaloby odpowiednio zmienic definicje
'(the-selection)', i to dwojako
- po pierwsze zeby dobrze dzialala z nowa koncepcja
- po drugie, zeby robila cache-owanie

natomiast to jest dopiero poczatek, bo tym, co w tym wszystkim
najistotniejsze, jest integracja ze schowkiem systemowym


no i tutaj rzecz wyglada tak, ze JVM na swoje rozwiazanie
(java.awt.datatransfer.Clipboard), a Android swoje
(android.content.ClipboardManager)

I bedzie trzeba na ich temat poczytac nieco.

Ale my bysmy sobie - jak zwykle - uwspolnili interfejs
za pomoca parametru clipboard albo cos w tym stylu.

check AWTPermission("accessClipboard")

* 31.01.2024

wczoraj udalo sie rozwiazac mase problemow, i wyglada na to,
ze z tych zasadniczych pozostal jeden - mianowicie to, ze
(na co wyglada) jak w Space przepisujemy callback od klonu
do oryginalu, a pozniej traverse advance'uje oryginal, to
owo advance'owanie powoduje wywolanie callbacku on-end-line,
ktore nie powinno miec miejsca

stad pomysl jest taki, zeby przyjrzec sie wszystkim wywolaniom
new-line, ktore wg grepa sa takie:


#+BEGIN_SRC fs -n new-line 
./src/grasp-android.scm:1158: (traversal:new-line!) ; draw-text!
./src/grasp-desktop.scm:1064: (traversal:new-line!) ; draw-text!
./src/editor/text-painter.scm:692: (traversal:new-line!) ; draw-string!
./src/editor/interfaces/elements.scm:82: ((new-line!)::void
./src/editor/types/comments.scm:164: (traversal:new-line!))  ; LineComment expand!
./src/editor/types/primitive.scm:677: (next:new-line!) ; line-ending-embracing
./src/editor/types/spaces.scm:278: (t:new-line!) ; Space:draw!
./src/editor/types/spaces.scm:325: (t:new-line!) ; Space:cursor-under*
./src/editor/types/spaces.scm:377: (t:new-line!) ; Space:expand
#+END_SRC

moze zamiast tego zrobimy tak, zeby usunac wywolanie on-end-line
z new-line, i wywolywac je recznie tam gdzie trzeba?

* 30.01.2024

pomysl jest taki, zeby dodac do interfejsu painter metode draw-line

ale ale! przeciez my juz mamy taka metode! no to jej uzyjmy!

* 29.01.2024

callback, ktory ustawia mark-cursor!, wyglada na razietak:

#+BEGIN_SRC scheme
  (let* ((original-traversal ::Traversal (the-traversal))
	 (cursor-top ::real (+ original-traversal:top
			       original-traversal:parent-top)))
    ;;...
    (set! original-traversal:on-end-line
	  (lambda (continued?::boolean)
	    (painter:draw-point! 0 0 #xffff00) ;; yellow
	    (let* ((traversal ::Traversal (the-traversal))
		   (parent-top ::real (+ traversal:top
					 traversal:parent-top))
		   (distance ::real (- traversal:max-line-height
				       (if (eq? traversal:parent
						original-traversal:parent)
					   0
					   (- cursor-top parent-top)))))
	      (painter:draw-point! traversal:left
				   traversal:top #xffaa00) ;; orange
	      (cond
	       (continued?
		(set! distance-to-next-line distance)
		(set! traversal:on-end-line nothing))
	       ((isnt traversal:parent eq? #!null)
		(set! traversal:parent:on-end-line
		      traversal:on-end-line)))))))
#+END_SRC

no to moze powinnismy sobie opowiedziec slowami, co sie powinno
dziac:
- jezeli callback wywolano z argumentem #t, to po prostu powinnismy
  jako odleglosc do nastepnej linii ustawic wysokosc biezacej linii
- jezeli wywolano go z argumentem #f, to chcemy przekazac dzialanie
  'pietro wyzej' - do momentu, az argument nie przyjmie
  wartosci #t

* 28.01.2024

no to musimy sobie ponownie przeanalizowac dzialanie calego
systemu

to mamy tak:
- wolamy sobie metode draw! na DocumentEditor
  
- powoduje to wywolanie metody draw! klasy Document,
  ktora zasadniczo wywoluje draw-sequence! na swoim 'car'ze
  
- draw-sequence jest zaimplementowany jako traverse, ktory
  wywoluje 'draw!' na poszczegolnych elementach (plus
  jakies dodatkowe czary mary)
  
- w szczegolnosci draw! moze byc wywolany na Space, ktory
  tworzy sobie kopie robocza dla the-traverse
  
- podczas rysowania tesktu oraz spacji wywolywany jest
  mark-cursor!, ktory w ostatwcznym rozrachunku ustawia
  callback on-end-line biezacego Traverse'a
  
- callback jest wywolywany z boole'owskim argumentem,
  ktory orzeka, czy przechodzimy do nowej linii, czy
  konczymy renderowanie [i na tej podstawie aktualnie stwierdzamy,
  czy mamy ustawic odleglosc kolejnej linii bezposrednio,
  czy raczej rozpropagowac ustawienie pietro wyzej]
  
- same nawiasy sa rysowane w taki sposob, ze jak mamy elementy
  typu cons, to ich metoda draw! wywoluje draw-box!, po czym
  rekurencyjnie wywoluje (z odpowiednim przesunieciem)
  draw-sequence! na swoich elementach.

i teraz tak: nieco problematyczna wydaje sie nam sytuacja,
w ktorej linia jest lamana, i jestesmy za podzialem linii
- albo w ktorej znajdujemy sie na nawiasie otwierajacym
  albo zamykajacym w podobnej sytuacji


* 25.01.2024

wczorajsza reorganizacja spalila na panewce - co w sumie
jest ok, bo zrobilsmy finalnie cos duzo prostszego
- mianowicie przypisanie on-end-line od klona do oryginalu.

teraz jednak mamy jeszcze kilka innych problemow.

po pierwsze, kiedy lamiemy spacje, to wyglada tak, jakby
brana byla wysokosc sprzed zlamania spacji

dlatego teraz pojawia sie pomysl, zeby do on-end-line
dodac jako argumenty:
- biezacy kontekst
- biezacy widget

* 24.01.2024

zagadka, od ktotej powinnismy rozpoczac, to: dlaczego
w metodach draw! oraz cursor-under* klasy Space
musimy klonowac Traversal?

i rzecz wyglada tak, ze jak mamy traverse, to ono
po wywolaniu action na spacji wywoluje tez
traversal:advance! na tej spacji

no, ale to chyba powstawalo jeszcze zanim mielismy traverse,
i wydaje sie, ze teraz mamy wieksza elastycznosc w zmianie
implementacji

no dobra, to moze sprobujmy po prostu
- wywalic traversal:advance! z traverse'a
- wywalic clone z metod Space:draw! i Space:cursor-under*

Ale ale! Nie mozemy tego zrobic, poniewaz sequence-extent
uzywa traverse'a, ktorego action to nothing.

No ale wowczas mozeny zamiast nothing dac po prostu
traverse:expand! space i powinno byc po krzyku?

#+BEGIN_SRC scheme
  (define (expand-space! item::Element traversal::Travesal)
    (match item
      (space::Space
       (traversal:advance! space))
      (_
       (nothing))))
#+END_SRC

* 23.01.2024

no dobra, to teraz musimy zrozumiec co sie tam dzieje ze ten
max-line-height jest wiekszy od dystansu do kolejnej linii

na razie bowiem problem udalo sie rozwiazac jedynie polowicznie,
stosujac brzydki hack [i nie wiadomo czy w klientach poza androidowym
to czegos nie napsuje]

do tego dochodzi taka kwestia, ze jak kursor jest na spacji,
to sie chyba callback on-end-line nie wywoluje poprawnie

no to tak. w sytuacji, gdy kursor jest mniej wiecej tu
(w kliencie androidowym):

#+BEGIN_SRC
                                   
 define  ! n                       
                                   
                                 
    if  <= n 0                   
                                 
                      
          1   BASE CASE          
           ^          
                             
           * n  !  - n 1     
                             
#+END_SRC

distance 0 
traversal:max-line-height 52.0
cursor-top 516.0
parent-top 464.0
traversal:top 52.0
traversal:parent-top 412.0
original-traversal:top 52.0
original-traversal:parent-top 412.0



* 22.01.2024

teraz mamy nieco luzniejszy tydzien, wiec bysmy sie skupili
na poprawie tego bledu z poruszaniem kursorem przy komentarzu

wydaje sie, ze tutaj problem jest jakos zwiazany z wyrazeniem

#+BEGIN_SRC scheme
  (as int (+ total (min width (quotient (- x t:left) space-width))))
#+END_SRC

gdzie total to calkowita liczba wyprobowanych do tej pory
indeksow na danej spacji

* 21.01.2024

Trzeba zdecydowanie jak najszybciej skonczyc prace nad kursorem.
Ponadto:
- dodajmy jakies koloryzowanie do ewaluacji
- zrobmy wsparcie dla zewnetrznego pliku inicjalizujacego
(tak zeby mozna go bylo zapisywac)
- i ewentualnie jakies "toasty" z informacjami o bledach

* 19.01.2024

dobrze by bylo wreszcie skonczyc te wszystkie hocki klock
z poruszaniem kursora, bo na razie jest jakas padaka


* 17.01.2024

dzisiaj bysmy zaczeli od tego, zeby nie wprowadzac
nowego traverse'a przy markowaniu nawiasu - najpierw
w kliencie androidowym, nastepnie teeminalowym i
desktopowym.

warto by jeszcze bylo naprawic pozycje rysowanego
kursora, w szczegolnosci w trybie androidowym,
i przyjrzec sie, dlaczego nie dziala cursor-under*
w quote'ach


* 16.01.2024

no to plan jest taki, zeby nie dodawac zadnych wartosci
przy wywolywaniu mark-cursor!, ale za to zeby dodawac
te wartosci przy samym rysowaniu

i bysmy tez poprawili te traversy przy nawiasach



* 15.01.2024

plan jeden z dwojga:
- "uniewrazliwic wysokosc skoku na przesuniecia kursora"
- linia przerywana wokol stringow w kliencie desktopowym?
  

* 14.01.2024

dzis moglibysmy sprobowac zrobic rysowanie linii
przerywanej w kliencie desktopowym i androidowym

#+BEGIN_SRC scheme
(paint:setPathEffect dashed-line)
(canvas:drawLine x0 y0 x0 y1 paint)
(canvas:drawLine x0 y0 x1 y0 paint)
(canvas:drawLine x0 y1 x1 y1 paint)
(canvas:drawLine x1 y0 x1 y1 paint)
(paint:setPathEffect #!null)
#+END_SRC
* 13.01.2024

plan poprawek w ruchu kursora:
1. nie wprowadza nowego traversa na nawiasach,
   tylko modyfikowa aktualnego
   (moe to pomoe z tym, e wysoko skoku 
   na nawiasach jest le wyliczama)
2. uniewraliwi wysoko skoku ma przesunicia
   kursora
3. przyjrze si sytuacji, gdy kursor jest
   przed komentarzem blokowym, albo na komentarzu
   wyraeniowym

   a jak to bdzie, to bymy si zajli selekcjami
   oraz integracj ze schowkiem

#+BEGIN_SRC java
  Paint fgPaintSel = new Paint();
  fgPaintSel.setARGB(255, 0, 0,0);
  fgPaintSel.setStyle(Style.STROKE);
  fgPaintSel.setPathEffect(new
			   DashPathEffect(new
					  float[] {10f,20f},
					  0f));
#+END_SRC


* 12.01.2024

nad pionowym ruchem kursora prace dalsze:
- jak kursor jest pomiedzy spacja a komentarzem blokowym,
  to jego wysokosc (z calym szacunkiem) nie jest
  wyliczana prawidlowo (wynosi 0)
- po kliknieciu chcielibysmy wymusic aktuakizacje
  kolumny
- i podobnie po kazdej edycji
- nadto gdy jestesmy w komentarzu wyrazeniowym,
  to jej wysokosc nie jest wyliczana

poza tym warto by bylo sie zaczac przygladac edycji
- nie dziala odczarowywanie quote'ow

no ale tak:
- aktualnie prace nad kursorem najlepiej prowadzic
  na desktopie, bo tam jest najwygodniejszy dostep
  do danych debugowycj

- mozemy zrobic rysowanie obwoluty wokol stringow,
  bo to zawsze cos


* 11.01.2024

na razie zrefaktoryzowalismy klienta desktopowego.
trzeba to przetestowac, i dla androida zrobic cos analogicznego.

no dobra, to sie chyba udalo

tyle ze w obu tych klientach *quote-markers sa zepsute
[i trzeba je bedzie naprawic]

natomiast inna rzecz, to pozbyc sie abstrakcji rozmiaru nawiasu

ale i z tym jakos sie uporalismy



* 10.01.2024

dzis bysmy dalej zrefaktoryzowali klienta androidowego
i desktopiwego, zeby moze rowniez w nich wyodrebnic
funkcje draw-custom-box

#+BEGIN_SRC scheme
  (define (draw-custom-box!
	   draw-left-paren!::(maps (real) to: void)
	   draw-right-paren!::(maps (real) to: void)
	   paren-width::(maps () to: real)
	   width::real height::real context::Cursor)
    ::void
    (let ((left-color ::long (parenthesis-color))
	  (right-color ::long (parenthesis-color)))
      (match (the-cursor)
	(`(#\[ #;#\] . ,,context) 
	 (set! left-color (focused-parenthesis-color))
	 (set! right-color (matching-parenthesis-color))
	 (mark-cursor! 0 0))
	(#;#\[ `(#\] . ,,context)
	       (set! left-color (matching-parenthesis-color))
	       (set! right-color (focused-parenthesis-color))
	       (mark-cursor! 0 0))
	(_
	 (values)))
      (set-color! left-color)
      (draw-left-paren! height)
      (with-translation ((- width (paren-width)) 0)
	(set-color! right-color)
	(draw-right-paren! height))))

  (define (draw-box! width::real height::real
		     context::Cursor)
    ::void
    (draw-custom-box!
     (lambda (width::real)::void
	     (invoke (this) 'open-paren! height))
     (lambda (width::real)::void
	     (invoke (this) 'close-paren! height))
     (lambda ()::real
	     (invoke (this) 'paren-width))
     width height context))

  (define (draw-quote-box! width::real
			   height::real
			   context::Cursor)
    ::void
    (draw-custom-box!
     (lambda (width::real)::void
	     (invoke (this) 'open-quote-paren! height))
     (lambda (width::real)::void
	     (invoke (this) 'close-quote-paren! height))
     (lambda ()::real
	     (invoke (this) 'quote-paren-width))
     width height context))


  (define (draw-quasiquote-box! width::real
				height::real
				context::Cursor)
    ::void
    (draw-custom-box!
     (lambda (width::real)::void
	     (invoke (this) 'open-quasiquote-paren! height))
     (lambda (width::real)::void
	     (invoke (this) 'close-quasiquote-paren! height))
     (lambda ()::real
	     (invoke (this) 'quasiquote-paren-width))
     width height context))

    (define (draw-unquote-box! width::real
			     height::real
			     context::Cursor)
    ::void
    (draw-custom-box!
     (lambda (width::real)::void
	     (invoke (this) 'open-unquote-paren! height))
     (lambda (width::real)::void
	     (invoke (this) 'close-unquote-paren! height))
     (lambda ()::real
	     (invoke (this) 'unquote-paren-width))
     width height context))




#+END_SRC

* 09.01.2024

wydaje sie wstepnie, ze podejscie zastosowane w kliencie
terminalowym z grubsza dziala [chociaz jakosc kodu
nie jest zadowalajaca]

pytanie zatem teraz jest takie: czy mozemy to jakos
sensownie zrefaktoryzowac?

tym, co budzi zagwozdki, jest fakt, ze oznaczenie wydaje sie
znajdowac zupelnie gdzie indziej niz kursor

moze wiec caly podsystem wymags poteznej refaktoryzacji?

#+BEGIN_SRC scheme
  ;; grasp-android

  (define (mark-editor-cursor! +left::real +top::real
			       editor::WithCursor)
    ::void
    (let* ((cursor-extent ::Extent (the-cursor-extent))
	   (cursor-offset ::Position (the-cursor-offset))
	   (left ::real (+ +left cursor-offset:left))
	   (top ::real (+ +top cursor-offset:top))
	   (traversal ::Traversal (the-traversal)))
      (editor:mark-cursor! (+ traversal:parent-left +left)
			   (+ traversal:parent-top +top))
      (set-color! text-color)
      (canvas:drawRect left top
		       (+ left cursor-extent:width)
		       (+ top cursor-extent:height)
		       paint)))

  (define (mark-cursor! +left::real +top::real)::void
    (mark-editor-cursor! +left +top (the-editor)))

  (define (editor-cursor-position editor::WithCursor)::Position
    (editor:cursor-position))

  (define (cursor-position)::Position
    (editor-cursor-position (the-editor)))

  (define (draw-box! width::real height::real context::Cursor)::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-paren! height context)
    (with-translation ((- width (paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-paren! height context)))

  (define (draw-quote-box! width::real
			   height::real
			   context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-quote-paren! height context)
    (with-translation ((- width (quote-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-quote-paren! height context)))

  (define (draw-quote-markers! width::real
			       height::real
			       context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (set-color! (opening-parenthesis-color context))
    (canvas:drawPath quote-marker paint))

  (define (draw-quasiquote-box! width::real
				height::real
				context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-quasiquote-paren! height context)
    (with-translation ((- width (quasiquote-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-quasiquote-paren! height context)))

  (define (draw-unquote-box! width::real
			     height::real
			     context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-unquote-paren! height context)
    (with-translation ((- width (quasiquote-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-unquote-paren! height context)))

  (define (draw-unquote-markers! width::real
				 height::real
				 context::Cursor)
    ::void
    (with-translation (0 (- height bottom-left-quote-extent:height))
      (and-let* ((`(#\[ . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (set-color! (opening-parenthesis-color context))
      (canvas:drawPath bottom-left-quote-paren paint)
      (with-translation ((+ width (quasiquote-marker-width)) 0)
	(and-let* ((`(#\]
 . ,,context) (the-cursor)))
	  (mark-cursor! 0 0))
	(set-color! (closing-parenthesis-color context))
	(canvas:drawPath bottom-right-quote-paren paint))))

  (define (draw-unquote-splicing-box!
	   width::real
	   height::real
	   context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-unquote-splicing-paren! height context)
    (with-translation ((- width (unquote-splicing-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-unquote-splicing-paren! height context)))

  (define (draw-unquote-splicing-markers!
	   width::real
	   height::real
	   context::Cursor)
    ::void
    (with-translation (0 (- height bottom-left-quote-extent:height))
      (and-let* ((`(#\[ . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (set-color! (opening-parenthesis-color context))
      (canvas:drawRect 0 10 2.5 20 paint)
      (canvas:drawRect 5 10 10 20
		       paint)
      (with-translation (10 0)
	(canvas:drawPath bottom-left-quote-paren paint)
	(with-translation ((+ width (quasiquote-marker-width)) 0)
	  (and-let* ((`(#\] . ,,context) (the-cursor)))
	    (mark-cursor! 0 0))
	  (set-color! (closing-parenthesis-color context))
	  (canvas:drawPath bottom-right-quote-paren paint)
	  (canvas:drawRect 20 10 25 20 paint)
	  (canvas:drawRect 27.5 10 30 20 paint)))))

  ;; a takze w metodzie draw-text!
#+END_SRC

#+BEGIN_SRC scheme
  ;; grasp-desktop

    (define (draw-box! width::real height::real
		     context::Cursor)
    ::void
    (let ((cursor (the-cursor)))

      (and-let* ((`(#\[ . ,,context) cursor))
	(mark-cursor! 0 0))

      (open-paren! height context)

      (with-translation ((- width (paren-width)) 0)
	(and-let* ((`(#\] . ,,context) cursor))
	  (mark-cursor! 0 0))
	(close-paren! height context))))


  (define (draw-quote-box! width::real
			   height::real
			   context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-quote-paren! height context)
    (with-translation ((- width (quote-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-quote-paren! height context)))

  (define (draw-quasiquote-box! width::real
				height::real
				context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-quasiquote-paren! height context)
    (with-translation ((- width (quasiquote-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-quasiquote-paren! height context)))


  (define (draw-quasiquote-markers! width::real
				    height::real
				    context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (set-color! (opening-parenthesis-color context))
    (graphics:fill top-left-quote-paren)
    (with-translation ((+ width (quasiquote-marker-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (set-color! (closing-parenthesis-color context))
      (graphics:fill top-right-quote-paren)))


  (define (draw-unquote-box! width::real
			     height::real
			     context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-unquote-paren! height context)
    (with-translation ((- width (quasiquote-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-unquote-paren! height context)))


  (define (draw-unquote-markers! width::real
				 height::real
				 context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (with-translation (0 (- height bottom-left-quote-bounds:height))
      (set-color! (opening-parenthesis-color context))
      (graphics:fill bottom-left-quote-paren)
      (with-translation ((+ width (quasiquote-marker-width)) 0)
	(and-let* ((`(#\] . ,,context) (the-cursor)))
	  (mark-cursor! 0 0))
	(set-color! (closing-parenthesis-color context))
	(graphics:fill bottom-right-quote-paren))))

  (define (draw-unquote-splicing-box!
	   width::real
	   height::real
	   context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (open-unquote-splicing-paren! height context)
    (with-translation ((- width (unquote-splicing-paren-width)) 0)
      (and-let* ((`(#\] . ,,context) (the-cursor)))
	(mark-cursor! 0 0))
      (close-unquote-splicing-paren! height context)))

  (define (draw-unquote-splicing-markers!
	   width::real
	   height::real
	   context::Cursor)
    ::void
    (and-let* ((`(#\[ . ,,context) (the-cursor)))
      (mark-cursor! 0 0))
    (with-translation (0 (- height bottom-left-quote-bounds:height))
      (set-color! (opening-parenthesis-color context))
      (graphics:fillRect 0 5 1 10)
      (graphics:fillRect 3 5 5 10)
      (with-translation (5 0)
	(graphics:fill bottom-left-quote-paren)
	(with-translation ((+ width (quasiquote-marker-width)) 0)
	  (and-let* ((`(#\] . ,,context) (the-cursor)))
	    (mark-cursor! 0 0))
	  (set-color! (closing-parenthesis-color context))
	  (graphics:fill bottom-right-quote-paren)
	  (graphics:fillRect 10 5 13 10)
	  (graphics:fillRect 14 5 15 10)))))

    (define (mark-editor-cursor! +left::real +top::real
			       editor::WithCursor)
    ::void
    (let ((cursor-extent ::Extent (the-cursor-extent))
	  (cursor-offset ::Position (the-cursor-offset))
	  (traversal ::Traversal (the-traversal)))
      (editor:mark-cursor! (as int (+ traversal:parent-left +left))
			   (as int (+ traversal:parent-top +top)))
      (graphics:fillRect (+ +left cursor-offset:left)
			 (+ +top cursor-offset:top)
			 cursor-extent:width
			 cursor-extent:height)))

  (define (mark-cursor! +left::real +top::real)::void
    (mark-editor-cursor! +left +top (the-editor)))

  (define (editor-cursor-position editor::WithCursor)::Position
    (editor:cursor-position))

  (define (cursor-position)::Position
    (editor-cursor-position (the-editor)))

  (define (cursor-height)::real
    (let ((offset ::Position (the-cursor-offset))
	  (extent ::Extent (the-cursor-extent)))
      (+ offset:top extent:height)))

  ;; a takze w metodzie draw-text!
  
#+END_SRC

#+BEGIN_SRC scheme
  ;; text-painter

  (define (mark-editor-cursor! +left::real +top::real
			       editor::WithCursor)
    ::void
    (let ((t ::Traversal (the-traversal)))
      (editor:mark-cursor! (+ t:parent-left +left)
			   (+ t:parent-top +top 1))))

  (define (editor-cursor-position editor::WithCursor)::Position
    (editor:cursor-position))

  (define (mark-cursor! +left::real +top::real)::void
    (mark-editor-cursor! +left +top (the-editor)))

  (define (cursor-position)::Position
    (editor-cursor-position (the-editor)))

  (define (draw-horizontal-bar! width::real
				highlighted?::boolean)
    ::void
    (let ((width (nearby-int (* width
				horizontal-stretch))))
      (when highlighted?
	(mark-cursor! 0 1)
	(enter-selection-drawing-mode!))
      (for i from 0 below width
	   (when (eq? (get -1 i) #\space)
	     (put! #\_ -1 i)))
      (when highlighted?
	(exit-selection-drawing-mode!))))

  (define (draw-vertical-bar! height::real
			      highlighted?::boolean)
    ::void
    (let ((height (nearby-int (* height
				 horizontal-stretch))))
      (when highlighted?
	(mark-cursor! 0 1)
	(enter-selection-drawing-mode!))
      (put! #\ 0 0)
      (for i from 1 below (- height 1)
	   (put! #\ i 0))
      (put! #\ (- height 1) 0)
      (when highlighted?
	(exit-selection-drawing-mode!))))

  (define (draw-custom-box!
	   top-left::gnu.text.Char
	   top-right::gnu.text.Char
	   bar::gnu.text.Char ;;
	   bottom-left::gnu.text.Char
	   bottom-right::gnu.text.Char
	   width::real
	   height::real
	   context::Cursor)
    ::void
    (let-values (((selection-start selection-end)
		  (the-selection))
		 ((width height) (values
				  (nearby-int (* width
						 horizontal-stretch))
				  (nearby-int (* height
						 vertical-stretch))))
		 ((t) (the-traversal)))
      (when (and (pair? (the-cursor))
		 (equal? context (cdr (the-cursor))))
	(parameterize ((the-traversal (Traversal
				       parent: t
				       parent-left:
				       (+ t:left t:parent-left)
				       parent-top:
				       (+ t:top t:parent-top))))
	  (match (head (the-cursor))
	    (#\[
	     (mark-cursor! 0 1))
	    (#\]
	     (slot-set! (the-traversal) 'left (- width 1))
	     (mark-cursor! (- width 1) (- height 2)))
	    (_ (values)))))
      (when (and (pair? selection-start)
		 (equal? (tail selection-start) context)
		 (is (head selection-start) in '(#\[ #\])))
	(enter-selection-drawing-mode!))
      (put! top-left 0 0)
      (for i from 1 to (- height 2)
           (put! bar i 0))
      (put! bottom-left (- height 1) 0)

      (put! top-right 0 (- width 1))
      (for i from 1 to (- height 2)
           (put! bar i (- width 1)))
      (put!  bottom-right (- height 1) (- width 1))

      (when (and (pair? selection-end)
		 (equal? (tail selection-end) context)
		 (is (head selection-end) in '(#\[ #\])))
	(exit-selection-drawing-mode!))
      ))  

#+END_SRC

#+BEGIN_SRC scheme
  (module-name (editor input pane))

  (define (mark-cursor! left::real top::real)::void
    (let* ((traversal ::Traversal (the-traversal))
	   (cursor-top ::real (+ traversal:top traversal:parent-top)))
      (set! marked:left left)
      (set! marked:top top)
      (set! distance-to-previous-line
	    (traversal:preceding-line-height))
      (set! traversal:on-end-line
	    (lambda (continued?::boolean)
	      (let* ((traversal ::Traversal (the-traversal))
		     (parent-top ::real (+ traversal:top traversal:parent-top))
		     (distance ::real (- traversal:max-line-height
					 (- cursor-top parent-top))))
		(cond
		 (continued?
		  #;(WARN "setting distance to "distance)
		  (set! distance-to-next-line distance)
		  (set! traversal:on-end-line nothing))
		 ((isnt traversal:parent eq? #!null)
		  #;(WARN "propagating to parent")
		  (set! traversal:parent:on-end-line
			traversal:on-end-line))
		 #;(else
		 (WARN "to the top!"))))))))
#+END_SRC

No dobra, to widzimy, ze ten mark-cursor! wewnatrz edytora
sobie bierze traversala

Ale eby to byo moliwe, traversal musi mie aktualn informacj.

Rozwamy zatem tak hipotez: co gdyby with-translation
zmieniao rwnie wartoci traverse:left i traverse:top?

#+BEGIN_SRC scheme
  (module-name (editor types primitive))

  (define (draw-sequence! #!optional
			  (elems::list (head (the-document)))
			  #!key (context::Cursor (recons 1 '())))
    ::void
    (escape-with end-drawing
      (let*-values (((selection-start selection-end) (the-selection)))
	(define (action item ::Element traversal ::Traversal)
	  (escape-with skip-element
	    (with-translation (traversal:left
			       traversal:top)
	      (when (is item instance? Tile)
		(let* ((document-left ::real (+ traversal:left
						traversal:parent-left))
		       (document-top ::real (+ traversal:top
					       traversal:parent-top))
		       (e ::Extent (extent+ item))
		       (document-right ::real (+ document-left
						 e:width))
		       (document-bottom ::real (+ document-top
						  e:height)))

		  (unless (visible? document-left document-top
				    document-right document-bottom)
		    (when (is document-top > (view-edge-bottom))
		      (end-drawing))
		    (skip-element))))

	      (let ((context (recons traversal:index
				     context)))
		(when (equal? context selection-start)
		  (painter:enter-selection-drawing-mode!))
		(item:draw! context)
		(when (equal? context selection-end)
		  (painter:exit-selection-drawing-mode!))))))
	(traverse elems doing: action))))

  ;; cons
  (define (draw! context::Cursor)
    ::void
    (let* ((inner ::Extent (sequence-extent (this)))
	   (t ::Traversal (the-traversal))
	   (paren-width ::real (painter:paren-width)))
      (painter:draw-box! (+ inner:width (* 2 paren-width))
			 inner:height
			 context)
      (with-translation (paren-width 0)
	(set! t:parent-left (+ t:parent-left paren-width))
	(try-finally
	 (draw-sequence! (this) context: context)
	 (set! t:parent-left (- t:parent-left paren-width))))))

#+END_SRC

Tutaj mamy

(with-translation (traversal:left traversal:top) ...)

czyli traverse nam zmienia traversal pod spodem, i dodanie
tego do with-translation by nam napsulo

Stad wydaje sie, ze rozwiazaniem powinno byc reczne zmodyfikowanie
traverse'a przy wywolywaniu mark-cursor! na nawiasach.

* 08.01.2024

to teraz bysmy sie zajeli tymi nieszczesnymi nawiasami

i tutaj sytuacja wyglada tak, ze w kliencie androidowym
i desktopowym mark-cursor! jest wolany (nieco wbrew intuicji)
wewnatrz opening/closing-parenthesis-color

W kliencie terminalowym i tekstowym mamy metode draw-custom-box,
w ktorej jest robiony mark-cursor!

Wiec plan bylby taki:
- do klienta tekstowego powinnismy moc wprowadzic zmiany
  bez problemu (choc ich nature bedzie jeszcze trzeba nieco
  przemyslec)
- klienty androidowy i desktopowy wymagalyby jeszcze
  refaktoryzacji, tak zeby mark-cursor! byl wolany poza
  funkcja od koloru?

no to te dwa klienty mamy zrefaktoryzowane. teraz bysmy przeniesli
wywolania mark-cursor

* 07.01.2024

No, to teraz probujemy zrozumiec, jak dziala mark-cursor!. Zasadniczo jest tak,
ze sobie rysujemy po kolei elementy wraz ze sledzeniem kontekstu, i jezeli akurat
kontekst jest tozsamy z kursorem, to wywolujemy mark-cursor!.

Do niedawna, jedynym, co "mark-cursor!" robilo, bylo narysowanie prostokata
i zapamietanie pozycji. Tymczasem jednak wywolujemy editor:mark-cursor!
przekazujac (+ traversal:parent-left +left) oraz (+ traversal:parent-top +top).

I owa metoda wydaje sie jako tako dzialac dla atomow oraz stringow, natomiast
dla spacji (z nowymi liniami) juz niekoniecznie.

OK, i dla spacji sie udalo to poprawic. To teraz bysmy sie zajeli nawiasami.

A moze jutro?

* 06.01.2024

Udalo sie jako tako zaimplementowac wyliczanie kolejnej pozycji
na dole (a w kazdym razie tak sie wydaje) - choc nalezaloby to jeszcze
zrobic dla klienta terminalowego.

Mamy jednak jeszcze kilka problemow:
- na spacjach, nawiasach i komentarzach rzecz nie dziala prawidlowo
- momentami kursor znika, i wtedy z tym adjust-view! dzieja sie
dziwne rzeczy

No dobra, to teraz trzeba zobaczyc co sie dzieje jak robimy mark-cursor!
na spacji.

Oglnie kopot jest taki, e sam do koca nie rozumiem, 
jak to wszystko dziaa :/

By moe warto by byo si skupi wanie na zrozumieniu tego?

No dobra, ale rozumiec to se mozna nawet na kiblu na telefonie :P

* 03.01.2023

#+BEGIN_SRC scheme
      (define-syntax-rule (test-that-operation operation
					       #;transforms
					       initial-view
					       #;into
					       final-view)
	(assert (equal? (snapshot) initial-view))
	operation
	(assert (equal? (snapshot) final-view))
	(undo!)
	(assert (equal? (snapshot) initial-view))
	(redo!)
	(assert (equal? (snapshot) final-view)))

      (define-syntax test-edit-sequence
	(syntax-rules ()
	  ((_ initial-view operation final-view . rest)
	   (begin
	     (test-that-operation operation #;transforms initial-view
				  #;into final-view)
	     (test-edit-sequence final-view . rest)))
	  ((_ final-view)
	   (assert (equal? (snapshot) final-view)))))

    (test-edit-sequence "
" (insert-character! #\[ #;#\]) "
  
  
 |
" (for-each insert-character! '(#\d #\e #\f #\n #\e)) "
       
 defne 
      ^
" (times 2 delete-backward!) "
     
 def 
    ^
" )

#+END_SRC

Wiemy juz, ze to nie zadziala, bo bywaja w kodzie miejsca,
w ktorych opieramy sie na undo. Zatem lepiej byloby zrobic

#+BEGIN_SRC scheme
  (define-syntax-rule (with-undo-redo operation)
    (let ((initial (snapshot)))
      operation
      (let ((final (snapshot)))
	(undo!)
	(let ((reverted (snapshot)))
	  (unless (equal? initial reverted)
	    (fail "Unexpected output after undoing "'operation
		  "\nexpected:\n"
		  initial
		  "\ngot:\n"
		  reverted)))
	(redo!)
	(let ((redone (snapshot)))
	  (unless (equal? final redone)
	    (fail "Unexpected output after redoing "'operation
		  "\nexpected:\n"
		  final
		  "\ngot:\n"
		  redone)))
	final)))
#+END_SRC

* 02.01.2023

Wydaje sie, ze na telefonie nawet nie da sie przeprowadzic
sensownych eksperymentow, ale moze uda sie chociaz dokonac
jakiejs auto-analizy.

Po prostu wyglada na to, ze opieranie sie na pojeciu
wysokosci poprzedniej i biezacej linii to kiepski pomysl.

Zamiast niego chcemy raczej miec 'odleglosc do poprzedniej
/nastepnej linii'. I teraz: w przypadku cofania sie do gory
to raczej nie powinno nam az tak mocno przeszkadzac, bo
ze wzgledu na sama mechanike dzialania musimy tylko uwazac,
zeby odleglosc, o ktora cofamy, nie byla zbyt duza
(moze nawet wystarczy przyjac 1?). Natomiast jezeli idzie
o odleglosc do nastepnej linii, to winna ona byc zdefiniowana
jako roznica pomiedzy biezaca pozycja, a pozycja otrzymana
w wyniku dodania 'wysokosci biezacej linii' do pierwszego
'nie-terminujacego' rodzica

No dobra. To wydaje sie miec sens. Byc moze nawet bedzie
dzialac dla stringow bez zadnych dodatkowych zmian?

Natomiast wydaje sie tez, ze fajnie by bylo rowniez
opracowac zestaw testow do wyrazania pionowego ruchu
kursora, a ponadto uproscic test-editor-operations.

Zamiast

#+BEGIN_SRC scheme
  
  (insert-character! #\[)

  (e.g.
   (snapshot) ===> "
    
    
   |
  ")

  (undo!)

  (e.g.
   (snapshot) ===> "
  ")

  (redo!)

  (e.g.
   (snapshot) ===> "
    
    
   |
  ")


#+END_SRC

chcielibysmy miec

#+BEGIN_SRC scheme
      (test-edit-sequence "
    "
			  (insert-character! #\[)

      (surely-the-operation

	   transforms "
	"
	   into "
	    
	    
	   |
	  "))

  (define-syntax-rule (test-edit-sequence initial-view
					  operation
					  final-view
					  . rest)
    (assert ...)
    operation
    (assert ...)
    (undo!)
    (assert ...)
    (redo!)
    (assert ...)
    (test-edit-sequence final-view . rest))


#+END_SRC

* 01.01.2024

Najsamprzd naleaoby wyjani, dlaczego - w sytuacji, gdy klikniemy
myszka na swiezym edytorze, to wyglada na to, ze callback on-end-line 
nie jest wywolywany, a co za tym idzie, current-line-height nie jest
ustawiana. Natomiast gdy najedziemy w to samo miejsce z pozycji spacji,
wydaje sie, ze owa wysokosc jest ustawiana prawidlowo (moze byc jednak
tak, ze wcale nie jest prawidlowo ustawiana, tylko posiada poprzednio
zapamietana wartosc)

Po drugie, gdy jestesmy na spacjach albo nawiasach, to wyglada na to,
ze cursor-column jest ustawiane nieprawidlowo.

Po trzecie, kiedy jestesmy na ostatniej linii wyrazenia, to rzeczywiscie
prawidlowo wyznaczamy wysokosc linii -- ale zamiast tego powinnismy wyznaczyc
pozycje kolejnego wyrazenia.

No bo tak: wydaje sie, ze nasz interfejs WithCursor jest o tyle dobrze
zaprojektowany, ze wymiary (current-line-height, previous-line-height)
sa inwariantne wzgledem przesuniecia polozenia, wiec stanowia najmniejszy
problem podczas uzywania (oczywiscie wymiary sa wyrazone we wspolrzednych
dokumentu)

Natomiast tak naprawde tym, co nas interesuje, nie sa wysokosci linii,
tylko przesuniecia do poprzedniej/nastepnej linii. I tutaj rzecz wyglada
w taki sposob, ze w momencie, kiedy wywolujemy on-end-line, mamy wszelkie
informacje do tego, zeby okreslic, gdzie znajduje sie kolejny punkt.

Tylko ze w takim razie nazwa "current-line-height" nie oddaje adekwatnie
tego, co powinna wyrazac - a powinna wyrazac "odleglosc do nastepnej linii",
czyli "distance to next line", i nazwalibysmy ja to-next-line.

Natomiast te druga wielkosc bysmy nazwali "to-previous-line" - i chociaz
wydaje sie, ze ona zachowuje sie z grubsza poprawnie, jest mozliwe, ze to
nie do konca prawda.

* 19.12.2023

dzis bysmy sie zajeli tym ukladem wspolrzednych - moze tez
by sie udalo wyrzucic metody current-translation-* z Paintera


* 17.12.2023

post-draw-actions zrobione, uklad wspolrzednych do
zrobienia - a po nim trzeba przemyslec co sie ma dziac
z tym traversem

* 16.12.2023

bysmy zaczeli od tego, ze bysmy dodali do edytora
'post-draw-actions' i poprawili uklad wspolrzednych,
w ktorym zachowujemy pozycje kursora

* 14.12.2023

mamy taki problem, ze biezaca metoda nie zawsze dziala

w szczegolnosci, nie dziala gdy chcemy zjechac ponizej
biezacego stringa, ale takze w innych okolicznosciach

innym problemem jest to, ze set-cursor-column! jest
wywolywane przed przerysowaniem ekranu, a nie po
(co daloby sie rozwiazac, wprowadzajac kolejke
funkcji ktore mialyby byc wywolane po rysowaniu)

jednnak nasze dzialania zaczelibysmy od wyrysowywania
na ekranie punktu oznaczonego kursora, i kiedy to bedziemy
mieli, bedziemy kontynuowac prace nad naprawa ruchu
pionowego

* 13.12.2023

dzis/jutro bysmy zaimplementowali traverse w metodach draw-string!
w kliencie androidowym i desktopowym, i uzyli tego do zaimplementowania
nowej nawigacji

i trzeba jeszcze przemyslec kwestie reprezentowania wspolrzednych
w taki czy inny sposob (tzn najpewniej bysmy chcieli je wyrazac
we wspolrzednych dokumentu)

* 12.12.2023

bysmy przeniesli (cursor-column) do WithCursor / CursorMarker
(i dodali set-cursor-column!)

oraz ser-current-line-height!, current-line-height,
set-previous-line-height!, previous-line-height

to teraz bysmy zrobili, zeby zamiast (cursor-column)
uzywac (editor:cursor-column), a po tym, zeby traverse
ustawialo wartosci previous-line-height oraz current-line-height

i dalej: w painterze grasp-desktop i grasp-android mamy metode
draw-text!, a w text painterze - metode draw-string. I chcielibysmy,
zeby te metody wprowadzaly swoj traversal.

* 11.12.2023

nalezaloby wzbogacic interfejs WithCursor o funkcje
mark-cursor! oraz cursor-position.

dobra, to juz zrobione

I co dalej?

Chcielibysmy, zeby rysowanie stringow i komentarzy
wprowadzalo swojego Traverse'a, i chcielibysmy, zeby
wszystkie dane potrzebne do pionowej nawigacji kursora
byly gromadzone w CursorMarker (czyli de facto w edytorze)

I teraz tak:

#+BEGIN_SRC scheme
  (define (move-cursor-up!)
    (let* ((editor ::Editor (the-editor))
	   (current ::Position (editor:cursor-position)))
      (set! (the-cursor)
	    (cursor-under (cursor-column)
			  (- current:top
			     (editor:previous-line-height))))))

  (define (move-cursor-down!)
    (let* ((editor ::Editor (the-editor))
	   (current ::Position (editor:cursor-position)))
      (set! (the-cursor)
	    (cursor-under (cursor-column)
			  (+ current:top
			     (editor:current-line-height))))))
#+END_SRC


Tego cursor-column tez bysmy chcieli zintegrowac z CursorMakerem.

* 10.12.2023

Mamy juz intetfejs Editor (choc na razie bez metody mark-cursor!).

Wiec teraz bysmy dodali mark-cursor! do Editor, i przemianowali
mark-cursor! z paintera na draw-cursor!, i przeniesli
cursor-position i cursor-height do editor.

no niestety wydaje sie, ze tutaj jest problem, bo obsluga kursora
zalezy od klienta, a to jedynie painter jest "client-specific"

a poza tym chcemy zrobic
- zmiane rozmiaru listy pustej
- kopiowanie wyrazen podwojnym tapnieciem
- usuwanie wyrazen szybkim ruchem palca
- drag&drop na komentarzach i tekscie
  
* 08.12.2023

Na razie plan jest taki, zeby:
- stworzyc interfejs Editor jako podtyp Embeddable
- przemianowac dotychczasowy Editor na DocumentEditor
- dodac metode 'mark-cursor!' do interfejsu Editor

Musimy sobie mniej wiecej wyobrazic co sie wtenczas powinno dziac.

A konkretnie: podczas renderowania wywolujemy
(the-editor):mark-cursor!, ktory z kolei powinien
wywolac painter:draw-cursor!.

Metody "mark-cursor!" oraz "cursor-position" powinny
zostac przeniesione do edytora. 

* 07.12.2023

No to teraz musimy sobie wyobrazic jak bysmy chcieli, zeby to bylo
wszystko zrobione.

Ot bymy chcieli, eby wywoywa ((the-editor):mark-cursor!),

* 06.12.2023

No dobra, to mamy kilka zagwozdek.

Jezeli idzie o poruszanie kursorem w gore i w dol,
to sprawy maja sie tak, ze:
- jak robimy traverse, to licza sie tylko listy i atomy

Wydaje sie, ze w tej dziedzinie nasza nowa metoda mialaby
nawet szanse zadzialac

* 05.12.2023

Przeanalizujmy sobie "mark-cursor!".

Na pewno jest uzywany w (editor types spaces).

Poza tym w:

text-painter:
- draw-horizontal-bar!
- draw-vertical-bar!
- draw-custom-box!
- draw-quote-markers!
- draw-quasiquote-markers!
- draw-unquote-markers!
- draw-unquote-splicing-markers!
- draw-string!

grasp-android:
- operning-parenthesis-color
- closing-parenthesis-color
- draw-text!

grasp-desktop:
- opening-parenthesis-color
- closing-parenthesis-color
- draw-text!


#+BEGIN_SRC
  0  5 10 15 20 25
 0X  X
 5    
10
15X  X
20      X
25      X

  0  5 10 15 20 25
 0X  X
 5
10      X
15      X



#+END_SRC

* 05.12.2023 (telefon)

+Plan jest taki, zeby pozostac przy aktualnym rozwiazaniu
w kwestii pionowego ruchu kursora, ale z jednym malym twistem:
- chcemy zapamietac polozenie linii poprzedzajacej kursor,
  oraz polozenie linii nastepujacej po kursorze

Aktualnie mamy w painterze:

  (mark-cursor! +left::real +top::real)::void
  (cursor-position)::Position
  (cursor-height)::real

  pierwsza rzecz jest taka, ze one nie powinny byc
  w painterze, tylko w Editorze [oczywiscie rysowanie
  kursora moze byc]

  To bysmy robili tak, ze bysmy wywolywali "mark-cursor!"
  na elemencie (the-editor) - ktory by musial implementowac
  odpowiedni interfejs


* 04.12.2023

dzis bysmy sie zajeli tymi klawiszami w gore i w dol.
wyobrazam sobie, ze to powinno dzialac tak:
1. najpierw wywolujemy 'index-above' albo 'index-below'
   na docelowym elemencie. Jezeli indeks sie zmieni,
   to konczymy. Jezeli nie, to
2. wywolujemy odpowiednia funkcje na rodzicu danego
   elementu

...

n. i tak dalej, az trafimy na indeks, ktory sie zmieni, albo
   dojdziemy do korzenia kursora


#+BEGIN_SRC scheme
  (define (cursor-above #!optional
			(cursor::Cursor (the-cursor))
			(document (the-document)))
    (and-let* ((`(,tip . ,root)  cursor)
	       (parent ::Element (cursor-ref document root))
	       (target ::Element (parent:part-at tip))
	       (above (target:index-above tip)))
      (cond ((isnt above equal? tip)
	     (recons above root))
	    ((eq? parent target)
	     (and-let* ((`(,leaf . ,stem) root))
	       (cursor-above stem document)))
	    (else
	     (cursor-above root document)))))

  (define (cursor-below #!optional
			(cursor::Cursor (the-cursor))
			(document (the-document)))
    (and-let* ((`(,tip . ,root)  cursor)
	       (parent ::Element (cursor-ref document root))
	       (target ::Element (parent:part-at tip))
	       (below (target:index-below tip)))
      (cond ((isnt below equal? tip)
	     (recons below root))
	    ((eq? parent target)
	     (and-let* ((`(,leaf . ,stem) root))
	       (cursor-below stem document)))
	    (else
	     (cursor-below root document)))))
  
#+END_SRC


* 03.12.2023

no to teraz mamy plan taki, zeby zrobic pionowy ruch kursora - ale zeby zrobic go dobrze

i jak zwykle w takich okolicznosciach dobrze jest zaczac od tego, zeby zapytac,
w jaki sposob jest to aktualnie zrobione

#+BEGIN_SRC scheme
(define (move-cursor-up!)
  (let* ((target (the-expression))
	 (initial-position ::Position (painter:cursor-position))
	 (cursor-height (painter:cursor-height))
	 (initial-cursor (the-cursor)))
    (let probe ((attempt 1))
      (let* ((shift (* attempt cursor-height))
	     (cursor (cursor-under (cursor-column)
				  (- initial-position:top
				     shift))))
	(cond ((isnt cursor equal? initial-cursor)
	       (set! (the-cursor) cursor)
	       (set! (the-selection-anchor) cursor))
	      ((is 0 < shift < initial-position:top)
	       (probe (+ attempt 1))))))))

(define (move-cursor-down!)
  (let* ((target (the-expression))
	 (initial-position ::Position (painter:cursor-position))
	 (cursor-height (painter:cursor-height))
	 (document-extent ::Extent (sequence-extent))
	 (initial-cursor (the-cursor)))
    (let probe ((attempt 1))
      (let* ((shift (* attempt cursor-height))
	     (cursor (cursor-under (cursor-column)
				  (+ initial-position:top
				     shift))))
	(cond ((isnt cursor equal? initial-cursor)
	       (set! (the-cursor) cursor)
	       (set! (the-selection-anchor) cursor))
	      ((is 0 < shift < (+ initial-position:top shift)
		   < document-extent:height)
	       (probe (+ attempt 1)))
	      )))))
#+END_SRC

* 02.12.2023 (telefon)

1. zmieniamy Map2D na BiMap2D
2. tworzymynnowe Map2D z metoda outside-in
3. tworzymy UnMap2d z metoda inside-out

i teraz chcemy, zeby Embeddable bylo Map2D

* 02.12.2023

jak juz przywrocimy ten gest ewaluacji (zeby dzialal tak jak dzialal wczesniej), to bysmy sie zajeli
moze ruchem strzalek w gore i w dol?

To brzmi OK.

A po tym bysmy sie zajeli z powrotem edycja, tak zeby:
- dzialal drag&drop na komentarzach i stringach
- nie bylo bledow przy edycji z klawiatury
- dalo sie wprowadzac znaki #\[, #\] itd.

Ale poki co jednak rzeczywiscie - ruch strzalek.

I tutaj mamy tak:

- ruch strzalek wewnatrz tekstu/komentarza blokowego
- ruch strzalek wewnatrz listy (spacji, atomow)

* 01.12.2023

Czesc problemow z Resize udalo sie rozwiazac (i usunac screen-position
w zamian wprowadzajac document-position),

Ale nadal jest problem jezeli probujemy zmienic rozmiar z innego miejsca, niz
lewy gorny edytor, to cos jeszcze nie dziala, i chyba to bysmy chcieli dzis
naprawic

Tosmy naprawili.

To teraz pozostaje nam gest ewaluacji chiba.


* 30.11.2023

- naprawic Resize
- naprawic Drag
- naprawic gest ewaluacji

idealnie byloby zrobic te 3 rzeczy do konca tygodnia

#+BEGIN_SRC scheme
(define (document-position-of-element-pointed-by cursor document 
                                                 #!key (context::Cursor (recons 1 '())))
  ::(Values real real)
  (escape-with return
    (define (action item ::Element traversal ::Traversal)
      (let ((c (recons traversal:index context)))
        (cond ((equal? c cursor)
               (return (+ traversal:left traversal:parent-left)
                       (+ traversal:top traversal:parent-top)))
	      ((is c suffix? cursor)
               (document-position-of-element-pointed-by cursor document c)))))
    
    (define (fallback t::Traversal)
      (values (+ t:left t:parent-left) (+ t:top t:parent-top)))

  (traverse document doing: action returning: fallback)))
#+END_SRC


* 29.11.2023

mapowanie zrobilismy, ale chyba cos przy okazji zepsulismy w tescie
widocznosci.

i chyba chcemy tez miec mozliwosc badania gestu ewaluacji

to jezeli idzie o te pierwsza kweste, musimy mapowac wszystkie
4 rogi edytora do wspolrzednych dokumentu (i to najlepiej to robic
w funkcji rysujacej panel)

to wydaje sie dzialac znakomicie!

Co nam zatem pozostaje?

- chcielibysmy sie pozbyc zaleznosci od "screen-position" w module "pane"
- byc moze jednak zdecydujemy sie usunac tego transform-stacka


#+BEGIN_SRC scheme
(define (document-position document cursor #!key (context::Cursor (recons 1 '())))::(Values real real)
  (escape-with return
    (define (action item ::Element traversal ::Traversal)
      ...)
    
    (define (fallback t::Traversal)
      (values (+ t:left t:parent-left) (+ t:top t:parent-top)))

  (traverse document doing: action returning: fallback)))
#+END_SRC

* 25.11.2023

chcemy:
- dodac translacje do splitow
- zrobic tak, zeby aktualizowac translacje przy zmianie rozmiaru splitu
- propagowac transformacje w metodach "propagate", "key-typed" oraz "draw!"
  obiektow "embeddable"

OK, wydaje sie, ze to juz mamy. I co dalej?

Chyba bysmy sprobowali uzyc tego nowego mechanizmu do mapowania wspolrzednych
dokumentu na wspolrzedne ekranu

* 24.11.2023

teraz plan jest taki, zeby sie pozby tablicy
'screen-positiin' i ja zastapic 'document-position',
co byc moze bedzie sie wiazalo ze zmianami w Traversalu

chcemy tez znalezc warunki dla 'early-returna'
z funkcji rysujacej (i ew pozostalych, ale to
pozniej)

(jednak wydaje sie, ze zrobienie tego jest
na razie zbyt trudne, zeby sie tym zajmowac)

No dobra, to zobaczmy, co nam daja API Javy
i Androida do mierzenia sie z takimi rzeczami
czyli android.graphics.Matrix
oraz java.awt.geom.AffineTransform

i otoz ta pierwsza ma metode nap, ale nie ma unmap,
zas ta druga nie ma zadnej

No dobra. To bysmy dodali:
- the-transform-stack
- with-post-transform do metod splitu:
  - propagate
  - draw!
  - key-typed

I to zapewne zrobimy przez weekend.
Ale na razie pomyslmy co chcemy zrobic dalej

mamy 3 cele: 
- wystapienie na bobconf (a moze i lambda-days)
- uzywanie GRASPa do edycji jego samego
- wydanie GRASPa

te dwa ostatnie cele wiele ze soba laczy.
ten pierwszy za to jest ciekawy

mozna je ze soba laczyc

jezeli idzie o doprowadzenie do uzytecznosci, to mamy:
- uzupelnienie funkcji edytujacych
- naprawa bugow w edycji i historii
- ewentualne optymalizacje
- poprawa czcionki, rozmiaru, nawiasow
- pionowy ruch kursorem
- wyszukiwanie i zamiana
- filtr zapisu i odczytu (do zmian w indentacji)
- nawigacja kursorem po rozszerzeniach

jezeli zas idzie o bobkonf, to wiadomka: chcemy sobie
zdefiniowac algorytm A* w sposob mozliwie maksymalnie
wizualny, a nastepnie chcemy zeby nasz wizualny ewaluator
pozwolil nam sobie zwizualizowac jego prace jako animacje

#+BEGIN_SRC scheme
(define (RankedPath path::Path ranking: real estimate: real)
  (Beside
    left: path right: (Below top: (Bordered element: ranking)
			  bottom: (Clouded element: estimate)))

#+END_SRC

* 23.11.2023

no to dzis bysmy zaczeli od dodania 'insert-at!' do
Embeddable i przywrocenia funkcjonowania drag&dropa

co wydaje sie dosc proste

a nastepnie bysmy sie zajeli tym screen-position
(przy czym najpierw chyba poprawa buga, a pozniej
zamiana na document-position)

ale do tego jeszcze dochodzi to, ze 
gest evaluate-expression-by-wedge wciaz zaklada, ze
Embeddable posiada metode outside-in

wiec musimy wymyslic:
- jak naprawic bledy spowodowane "wycinajaca" optymalizacja
- jak naprawic gest ewaluacji
- jak przemigrowac ze screen-position do document-position

Do tego jeszcze zrobilismy zmiane z wyciaganiem elementu
- i tutaj tez dobrze by bylo miec jakis sposob
  na przeksztalcanie wspolrzednych dokumentu w ekranowe

Wycinajaca optymalizacja wydaje sie (w Androidzie)
przynajmniej w czesci naprawiona

* 22.11.2023

Ok, czyli planem na dzis jest sprawienie, zeby
Embeddable nie bylo Map2D.

Ale zeby tego dokonac, najpierw trzeba sie dowiedziec
dlaczego Embeddable jest Map2D.

Otoz mamy zasadniczo dwie instancje Embeddable: Splity
oraz Editory.

W przypadku Splitow mapowanie outside-in jest zaimplementowane
w taki sposob, ze w zaleznosci od wspolrzednych wejsciowych
wybieramy odpowiednia transformacje - i wlasnie ze wzgledu na ow
nieliniowy wybor nie mozemy odwrocic tej operacji

A raczej powinnismy robic tak, ze dodajemy odpowiednia operacje
na dno stosu transformacji (w zaleznosci od wspolrzednych)


No dobra: zasadniczo wywalilismy Map2D z Embedded i swiat sie
nie zawalil. Trzeba bylo tylko w metodzie DragAround:drop!
wywalic odniesienie do screen:top:outside-in i zastapic
je funkcja values. To nie jest do konca tak jak powinno byc
- jakos trzeba bedzie moc zmapowac wspolrzedne dokumentu
  na wspolrzedne edytora, i wlasnie teraz chcemy to wymyslic

Dodatkowo musimy miec gdzies z tylu glowy, ze chcemy sie pozbyc
screen-position, i albo zastapic ja document-position, albo nawet
po prostu metoda traverse

Musimy zatem wyobrazic sobie, co sie powinno dziac, kiedy
robimy DragAround albo Resize.

No to tak:

1. naciskamy na ekran
2. ekran tlumaczy wspolrzedne ekranu na wspolrzedne edytora
   (rekurencyjnie wglab, az docieramy do dokumentu)
3. wywolana zostaje metoda, ktora wyodrebnia element
   z dokumentu i zwraca obiekt Drag
4. przy kazdym ruchu palca jest wywolywana metoda move!
5. po podniesieniu palca zostaje wywolana metoda drop

I to wlasnie tutaj pojawia sie problem.

Zarowno Editor jak i Split powinny miec jakas metode,
ktora wywolujemy, np.

(insert-at! x::real y::real expression)::boolean

* 21.11.2023

no i jeszcze zgloszenie na BOBKonf!

no ale zeby to wszystko moglo zadzialac, oto co musimy zrobic:
- prawidlowa optymalizacja wyswietlania
  (z uwzglednieniem przeskakiwania elementow w dokumencie
  oraz wyskakiwania)
- uzycie wspolrzednych dokumentu i poprawa bugow edycji dotykowej
- pulling-the-rug splicing
- ograniczenia na zoomowanie i scrollowanie

zacznuemy dzis od tego, zeby przemianowac map i unmap
na outside-in oraz inside-out

ok to sie chyba udalo

to teraz bysmy sie zajeli tym, zeby zamiast screen-position
miec document-position, przy czym screen-position jest uzywany
w dwoch modulach:
- (editor types primitive), gdzie jest ustawiany (i od niedawna
  uzywany do optymalizacji)
- (editor input pane), gdzie jest uzywany przy Resize i przy
  Drag&Drop

i teraz tak: nie bedzie niczym zlym, jezeli sprobujemy teraz uporac
sie z bugiem, bo nawet jesli pozniej zmienimy architekture, wydaje sie,
ze mozemy osiagnac cel w postaci rozumienia tego, co sie tutaj
dzieje

no to plan jest mniej wiecej taki, ze bysmy chcieli miec
parametr (the-transform), ktory pozwalalby nam przechodzic od
wspolrzednych edytora do wspolrzednych dokumentu i z powrotem

moglibysmy stworzyc sobie takie cos:

#+BEGIN_SRC scheme
  (define-object (TransformStack)::Map2D
    (define transforms ::($bracket-apply$ List Map2D)
      (($bracket-apply$ ArrayList Map2D)))

    (define (outside-in x::real y::real)::(Values real real)
      (for transform::Map2D in transforms
	(let-values (((x* y*) (transform:outside-in x y)))
	  (set! x x*)
	  (set! y y*)))
      (values x y))

    (define (inside-out x::real y::real)::(Values real real)
      (for transform::Map2D in-reverse transforms
	(let-values (((x* y*) (transform:inside-out x y)))
	  (set! x x*)
	  (set! y y*)))
      (values x y))

    (define (addLast transform::Map2D)::void
      (transforms:addLast transform))

    (define (addFirst transform::Map2D)::void
      (transforms:addFirst transform))

    (define (removeLast transform::Map2D)::Map2D
      (transforms:removeLast))

    (define (removeFirst transform::Map2D)::Map2D
      (transforms:removeFirst))
    )

  (define the-transform-stack ::TransformStack (TransformStack))

  (define-syntax-rule (with-post-transform t . actions)
    (transform-stack:addLast t)
    (try-finally
     (begin . actions)
     (transform-stack:removeLast)))

  (define-syntax-rule (with-pre-transform t . actions)
    (transform-stack:addFirst t)
    (try-finally
     (begin . actions)
     (transform-stack:removeFirst)))
#+END_SRC

No dobra, ale teraz jak bysmy tego uzywali?

I jak to sie ma do tego, co mamy teraz?

Po pierwsze, Embeddable jest zdefiniowane jako Map2D - co
w pewnym sensie jest dosc klopotliwe, bo Split - ktory jest
Embeddable, ma metode inside-out, ktora nie ma swojej
implementacji.

Ponysl zatem jest taki, zeby Embeddable nie bylo Map2D.


* 20.11.2023

no dobra, to mamy pare bugow w naszym mechanizmie optymalizujacym

natomiast kluczowe kwestie to:
- zaczac uzywac GRASP do edycji jego samego
- wydac wersje 1.0.0 edytora do sklepu Play

  
* 17.11.2023 (komputer)

mamy takie oto problemy:
1. draw-sequence! zapamietuje "screen-position" (a nie "document-position")
2. to mogloby zadzialac od reki, gdybysmy mieli dostepne wartosci "the-pane-left"
oraz "the-pane-top"
3. ale modul (editor types primitive) nic nie wie o parametrach
the-pane-width i the-pane-height, ktore sa zdefiniowane w (editor input pane)
dla ktorego (editor types primitve) jest zaleznoscia

Byc moze moglibysmy przeniesc definicje (the-pane-width) i (the-pane-height)
do (editor types primitive)

* 17.11.2023

#+BEGIN_SRC scheme
  (define (overlap? Amin Amax Bmin Bmax)
    (assert (is Amin <= Amax))
    (assert (is Bmin <= Bmax))
    (and (is Amin <= Bmax) (is Amax >= Bmin)))

  ;; 0    1    2    3
  ;; Amin Amax Bmin Bmax
  (e.g. (not (overlap? 0 1 2 3)))

  ;; Amin Bmin Amax Bmax
  (e.g. (overlap? 0 2 1 3))

  ;; Amin Bmin Bmax Amax
  (e.g. (overlap? 0 3 1 2))

  ;; Bmin Bmax Amin Amax
  (e.g. (not (overlap? 2 3 0 1)))

  ;; Bmin Amin Bmax Amax
  (e.g. (overlap? 1 3 0 2))

  ;; Bmin Amin Amax Bmax
  (e.g. (overlap? 1 2 0 3))

  (define (rectangles-overlap? Axmin ::real Aymin ::real
			       Axmax ::real Aymax ::real

			       Bxmin ::real Bymin ::real
			       Bxmax ::real Bymax ::real)
    ::boolean
    (and (overlap? Axmin Axmax Bxmin Bxmax)
	 (overlap? Aymin Aymax Bymin Bymax)
    ))
#+END_SRC


* 16.11.2023

no to jak?

zalozmy, ze podczas renderowania mamy dostep do
wspolrzednych wyrazenia wewnatrz dokumentu.

za pomoca transformacji edytora mozemy je
sobie przetransformowac do wspolrzednych edytora

i to zasadniczo nam wystarczy do tego, zeby
okreslic, czy dany obiekt jest widoczny

co wiecej mozemy zrobic tak, ze nie bedziemy
transformowac wspolrzednych dokumentu, tylko
sobie przetransformujemy wspolrzedne edytora
do wspolrzednych dokumentu

#+BEGIN_SRC scheme
  (define (overlap? Axmin ::real Aymin ::real
		    Axmax ::real Aymax ::real

		    Bxmin ::real Bymin ::real
		    Bxmax ::real Bymax ::real)
    ::boolean

   
    )

#+END_SRC

* 15.11.2023

powstal nowy pomysl na optymalizacje:
zrobic makro traverse/inline, ktore by mialo taka sama
definicje, jak traverse, i tego makra uzyc do zdefiniowania
funkcji aktualnie definiowanych za pomoca traverse.

Dodatkowo mozna sprobowac zrobic cos, zeby lambdy byly
inline'owane w ciele twgo makra

bo jak to zrobimy, i jak zoptymalizujemy wyswietlanie,
to bysmy sie zajeli Usability, czyli tym, zeby:
- ograniczyc scrollowanie i usunac rotacje
- zrobic poprawna nawigacje kursorem
- naprawic edycje dotykowa


no dobra, nie wydaje sie, zeby inline'owanie makra duzo
zmienilo (aczkolwiek warto podejrzec wynikowe asemblery)

mozemy jeszcze sprobowac hardware'owa akceleracje

* 14.11.2023

teraz plan jest skromny, taki, zeby nie rysowac niewidocznych
elementow, tzn:
- jezeli dany element nie jest widoczny, to go przeskakujemy
- jezeli dany element jest na takuej wysokosci, ze juz wiecej
  nie bedzie widoczny, to go w ogole przeskakujemy

no ale dobra, teraz mamy taki problem, zeby ustalic,
czy dany prostokat znajduje sie na ekranie, co wiaze sie
z takim problemem, zeby w ogole ustalic, jakie ow prostokat
ma wspolrzedne

i teraz: mamy 3 sposoby okreslania wspolrzednych:
- na ekranie
- w dokumencie
- w edytorze

aktualnie zapisujemy sobie wspolrzedne ekranowe, ale
chyba najlepiej byloby zapisywac wspolrzedne dokumentu
i je przeksztalcac do wspolrzednych edytora i ekranu

na razie to jest tak zapisywane (w draw-sequence!):

#+BEGIN_SRC scheme
  (let ((position ::Position (screen-position item)))
    (set! position:left
	  (painter:current-translation-left))
    (set! position:top
	  (painter:current-translation-top)))
#+END_SRC


oki, no to zalozmy ze wymyslimy sposob jak wyliczac wspolrzedne
dokumentu (zapewne poprzez rekurencyjne odwolywanie sie
do traversali)

to postawi przed nami dwa pytania:
1. co z dotychczasowym kodem?
2. jak tego uzyc do implementacji nowej funkcjonalnosci?

No to tak: screen-position jest uzywane w
(editor input pane) przez Resize oraz w okolicach DragAround,
czyli w sumie to zasadniczo tam, gdzie teraz mamy bugi

Tymczasem mamy taka idee, zeby zamiast tego miec
document-position. Do tego dochodzi jeszcze taka kwestia,
ze fajnie by bylo, zeby tych pozycji nie trzymac
w haszu, tylko bezposrednio w obiektach (podobnie
jak extentow), no ale oczywiscie nie wszystko na raz

no dobra, czyli wiemy na razie, ze:
- chcemy sie przelaczyc ze screen-position na document-position
- musimy mapowac wspolzedne ekranowe dotyku w dokument

i w takim razie renderowanie musi wygladac tak, ze:
- bierzemy sobie wspolrzedne dokumentu (wyliczamy je z traverse'a
  podczas renderowania)
- musimy uwzglednic dwie rzeczy: wspolrzedne biezacego
  edytora (wzgledem splitu) oraz aktualna transformacje
- na tej podstawie okreslamy, czy prostokat biezacego
  elementu znajduje sie w swietle ekranu

* 13.11.2023

wydaje sie, ze zmiany z properties na membery nie przyniosly
duzej poprawy wydajnosci - choc zapewne nalezaloby to zmierzyc
profilerem. (ale w sumie wydaje sie ze jest nieco szybciej)

byc moze tez jakies inne propertiesy psuja nam
charakterystyki wydajnosciowe, i moze np. extent powinnismy
rowniez cache'owac w memberach

inny pomysl na optymalizacje jest wszak taki, zeby:
1. edytor pamietal pierwsze wyrazenie, ktore jest widoczne, i to
   od niego rozpoczynal rysowanie
2. albo nawet prosciej: jezeli dany fragment dokumentu nie jest
   widoczny, to po prostu robmy return z funkcji rysujacej

zacznijmy od tego drugiego. moglubysmy tez robic tak, zeby
inwalidacja cache'u dotyczyla tylko elementow widocznych
na ekranie

no to mamy tak:

(0,0),         (szerokosc, 0)

(0, wysokosc), (szerokosc, wysokosc)

i teraz tak:
- dokonujemy transformacji wspolrzednych podczas rysowania
 (wspolrzedna bazowa i z dodanym extentem)
- jezeli wszystkie punkty sa:
  - po lewej od 0
  - po prawej od szerokosc
  - powyzej 0
  - ponizej wysokosc

    to robimy return z draw-sequence

no dobra, to mozna zrobic, ale najpierw bysmy sie pozbyli
the-painter

pierwej jednak trzeba owo makro with gdzies umiescic

no dobra, to nie ma the-painter

i to chyba wcale duzo nie pomoglo

(co mogloby pomoc to port do chez scheme)

natomiast moze byc tak, ze nierysowanie niewidocznych
rzeczy pomoze?


* 10.11.2023

#+BEGIN_SRC scheme
  (define-syntax with
    (lambda (stx)
      (syntax-case stx ()
	((with ((variable value) ...) . actions)
	 (with-syntax (((previous-value ...)
			(generate-temporaties #'(variable ...))))
		      #'(let ((previous-value variable) ...)
			  (set! variable value)
			  ...
			  (try-finally
			   (begin . actions)
			   (begin
			     (set! variable previous-value)
			     ...))))))))
#+END_SRC

takie cos bysmy chcieli miec

i zamiast parametru "the-painter" bysmy chcieli miec
po prostu zmienna globalna "painter", zeby uniknac narzutu
i ewentualnie nieco uproscic kod

a tymczasem mamy sobie slynne A*:


#+BEGIN_SRC scheme
(define (optimial-path #;on weighted-graph #;from initial-state 
			    #;until success?
				    #;guided-by remaining-cost-estimate)
  (define (probably-shorter? `(,estimate-a . ,_)
			     `(,estimate-b . ,_))
    (is estimate-a < estimate-b))

  (define (walk paths visited-nodes)
    (and-let* ((`((,_ ,cost-so-far ,path) . ,paths) paths)
	       (`(,current-node . ,_) path))
      (define (estimate-total-cost `(,node ,weight))
	(let* ((total-cost (+ cost-so-far weight))
	       (estimate (+ total-cost
			    (remaining-cost-estimate node))))
	  `(,estimate ,total-cost ,node)))

      (define (update-paths paths `(,estimate
				    ,alternative-cost
				    ,node))
	(let ((new-path `(,estimate
			  ,alternative-cost
			  (,node . ,path))))

	  (match (find (lambda (`(,_ ,_ (,end . ,_)))
			 (equal? end node))
		       paths)
	    (`(,previous-estimate ,established-cost ,_)
	     (if (is established-cost <= alternative-cost)
		 paths
		 (let ((paths (only (lambda (`(,_ ,_ (,end . ,_)))
				      (isnt end equal? node))
				    paths)))
		   (merge `(,new-path) paths probably-shorter?))))
	    (_
	     (merge `(,new-path) paths probably-shorter?)))))

      (if (success? current-node)
	  (values (reverse path) cost-so-far)
	  (let* ((neighbors (weighted-graph current-node))
		 (new-neighbors (only (lambda (`(,node ,weight))
					(isnt node member visited-nodes))
				      neighbors))
		 (judged-neighbors (map estimate-total-cost new-neighbors))
		 (paths (fold-left update-paths paths judged-neighbors)))
	    (walk paths (union `(,current-node)
			       visited-nodes))))))

  (walk `((+inf.0 0 (,initial-state))) '()))
#+END_SRC

Najgoretsze wyrazenie w algorytmie to (po zwinieciu):

#+BEGIN_SRC scheme
  (walk (fold-left update-paths paths
		    (map estimate-total-cost
			 (only (lambda (`(,node ,weight))
				 (isnt node member visited-nodes))
			       (weighted-graph current-node))))
      (union `(,current-node) visited-nodes))
#+END_SRC

chodzi o to, ze:
- mamy sobie liste sciezek
- zawsze rozpoczynamy od pierwszej sciezki na liscie (bo ona jest
  naszym zdaniem najkorzystniejsza)
- 

* 09.11.2023

dalsze poprawki w edycji

teraz bysmy moze zrobili tak, ze jak jestesmy w trybie
'evaluating', i mamy do czynienia z Extension, to zwracamy
jego 'as-expression'

to z grubsza chodzi o to, zeby Extension bylo Shadowed, i zeby
"value" robilo to, co robi as-expression

ok

a teraz pomysl jest taki, zeby sie pozbyc tych propertisow w spacjach

A to by wygladalo tak mniej wiecej:

#+BEGIN_SRC scheme

  (define-syntax-rule (define-accessor (name object::type)::result)
    (define-early-constant name
      (let ((getter (lambda (object::type)
		      ::result
		      (slot-ref object 'name))))
	(set! (setter getter)
	      (lambda (object::type value::result)
		::void
		(slot-set! object 'name value)))
	getter)))

  (define-accessor (dotted? cell::cons)::boolean)
  (define-accessor (pre-head-space cell::cons)::Space)
  (define-accessor (post-head-space cell::cons)::Space)
  (define-accessor (pre-tail-space cell::cons)::Space)
  (define-accessor (post-tail-space cell::cons)::Space)

  (define-object (cons car cdr)::MatchableTile
    ...
    (define pre-head-space ::Space (Space fragments: (cons 0 '())))

    (define dotted? ::boolean
      (not (or (empty? cdr)
	       (pair? cdr))))

    (define post-head-space ::Space
      (if (and (not dotted?)
	       (empty? cdr))
	  (Space fragments: (cons 0 '()))
	  (Space fragments: (cons 1 '()))))

    (define pre-tail-space ::Space
      (Space fragments: (cons 1 '())))

    (define post-tail-space ::Space
      (Space fragments: (cons 0 '())))

    ...
    (pair car cdr))

#+END_SRC

* 08.11.2023

jestesmy w *jakims punkcie* naprawiania zmiany rozmiaru
pudelek - ale wyglada na to, ze bedziemy musieli to sobie
jakos rozrysowac

no bo chodzi o to, ze mamy:

- wspolrzedne ekranu
- wspolrzedne edytora
- wspolrzedne dokumentu

i latwo sie w tym zapultac

a druga sprawa to wyszukiwanie

no bo pomysl jest taki, ze jak ciskamy (ctrl f)
to sie nam powinien biezacy edytor dzielic w pionie
na 2, i focus powinien isc do tego dolnego

tam rowniez powinien byc tworzony tymczasowy dokument.

i kiedy bedziemy wpisywac tekst, to w gornym widoku
powinno sie odbywac wyszukiwanie pasujacych elementow
(a jak nie znajdziemy, to powinnismy robic zoom-out
na caly dokument, a w kazdym razie do dopuszczalnej
skali)

no ale na razie zajmijmy sie czyms bardziej przyziemnym,
tzn. tym, zeby software'owa klawiatura na Androidzie
zmieniala rozmiar ekranu

#+BEGIN_SRC java
  void setKeyboardVisibilityListener(OnKeyboardVisibilityListener
				     onKeyboardVisibilityListener) {
      View parentView = ((ViewGroup) findViewById(android.R.id
						  .content))
	  .getChildAt(0);
      parentView.getViewTreeObserver()
	  .addOnGlobalLayoutListener(new
				     ViewTreeObserver
				     .OnGlobalLayoutListener() {

		  private boolean alreadyOpen;
		  private final int defaultKeyboardHeightDP = 100;
		  private final int EstimatedKeyboardDP =
		      defaultKeyboardHeightDP
		      + (Build.VERSION.SDK_INT
			 >= Build.VERSION_CODES.LOLLIPOP
			 ? 48 : 0);
		  private final Rect rect = new Rect();

		  @Override
		  public void onGlobalLayout() {
		      int estimatedKeyboardHeight = (int)
			  TypedValue.applyDimension(TypedValue
						    .COMPLEX_UNIT_DIP,
						    EstimatedKeyboardDP,
						    parentView
						    .getResources()
						    .getDisplayMetrics());
		      parentView.getWindowVisibleDisplayFrame(rect);
		      int heightDiff = parentView.getRootView()
			  .getHeight() - (rect.bottom - rect.top);
		      boolean isShown =
			  heightDiff >= estimatedKeyboardHeight;

		      if (isShown == alreadyOpen) {
			  Log.i("Keyboard state",
				"Ignoring global layout change...");
			  return;
		      }
		      alreadyOpen = isShown;
		      onKeyboardVisibilityListener
			  .onVisibilityChanged(isShown);
		  }
	      });
  }


#+END_SRC

* 07.11.2023

wydaje sie, ze jestesmy w takim punkcie, z ktorego trudno
sie ruszyc.

ogolnie chcielibysmy naprawic bledy zwiazane z drag&dropem
i moze w konkretniejszy sposob uzupelnic dotykowa edycje,
a takze unormowac kwestie zoomowania i scrollowania
(i najlepiej zeby scrollowanie odbywalo sie na zasadach
Super Mario)

poniewaz jednak teraz korzystamy ze 'screen-position',
to nam sie wszystko krzaczy

wiec pomysl jest taki, zeby:
- zmienic screen-positiion na document-position
- wszystkie odniesienia do screen-position zaposredniczyc
  przez transformacje

albo drugi pomysl:
- zamienic screen-position na editor-position

wydaje sie, ze opcja 2 jest ontyle lepsza, ze potrzeba
mniej transformacji

tyke ze screen-position powinno byc parametrem

* 06.11.2023

no dobra, to teraz robimy ograniczenia na zoomowanie i scrollowanie

i przy okazji dobrze by bylo naprawic:
- resize
- drag&drop

to tak:
- jezeli idzie o zoom, to musimy sobie wyswietlac aktualna wartosc
- jezeli idzie o scrolla, to

getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE|WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);

ok, trzeba chyba bedzie delikatnie przebudowac architekture

chodzi o to, ze transformacje musza w jakis sposob miec dostep
do rozmiaru dokumentu

zatem bedziemy chcieli stworzyc nowe transformacje, bo bysmy
chcieli zmienic dzialanie funkcji "stretch" tak, zeby nie zmieniala
przesuniecia dokumentu (tzn zeby lewy gorny piksel pozostawal
bez zmian)

ogolnie tez nie chcemy teraz za bardzo szalec. tzn idealnie byloby
wprowadzic minimalna ilosc zmian do tego, zeby:
- moc przeprowadzac w GRASP normalna edycje (w szczegolnosci
  chodzi o edycje samego GRASPa)
- rozwijac Androidowego GRASPa w nim samym
- zaimplementowac "komiksowy" algorytm A*

no ok, ale co jest potrzebne do rozwijania androidowej wersji
w niej samej?

No mniejsza z tym wszystkim na razie.

Moze poprawimy pozycje paleczki podczas rysowania komentarzy?

Pomysly:
- podwojne klikniecie w lewy nawias: minimalizacja wyrazenia
- w prawy nawias - maksymalizacja wyrazenia



* 05.11.2023

no to plan na najblizszy czas jest taki:
1. wprowadzic ograniczenia na najwiekszego i najmniejszego
   zooma oraz na pozycje scrolla (i ewentualnie usunac
   mozliwosc obracania)
2. zrobic tak, zeby obiekty, ktore nie sa widoczne na ekranie
   - nie mialy inwalidowanego extent cache'u
   - nie byly w ogole rysowane
3. rysowac ramki wokol dokumentu

dobrze byloby tez:
 - wprowadzic kolorowanie wyewaluowanych wyrazen
- zaimplementowac gest steppera
- rysowanie guzikow


No dobra, ale co ma nam szanse przyblizyc najszybciej
samoedytowalnosc GRASPa?

Ogolnie to bysmy chcieli raczej operowac na projektach, niz
na pojedynczych plikach. Projekt bysmy utozsamiali z gitowym
repozytorium, zas jego zaleznosci to by byly gitowe
submoduly. I wowczas owe submoduly by sie miescily
w internal storage'u.

Od razu tez chcemy oczywiscie miec nawigacje po kodzie
zrodlowym.

* 03.11.2023

aktualnie mamy na kompie poprawki w parserze, a na telefonie
podswietlanie "paleczki" pomiedzy glowa a ogonem

jeszcze bysmy chcieli w kliencie desktopowym poprawic wyswietlanie
quote'ow, ograniczyc scrollowanie i zoomowanie dokumentu,
wyswietlac pop-upy wewnatrz edytorow, a nie ponad nimi,
oraz zaimplementowac mechanizm wyszukiwania wyrazen
(wlaczajac w to slowa kluczowe oraz wyrazenia regularne,
a takze zagniezdzone struktury)

* 03.11.2023 (telefon)

no dobra, to w sumie teraz naszym celem jest wypolerowanie
doswiadczenia uzytkownika

- pierwsza brakujaca funkcjonalnosc to search&replace
- chcielibysmy tez wyswietlac informacje o tym, czy byly
  w pliku jakies zmiany (oraz nazwe pliku)
- i tak w sumie to bysmy chcieli, zeby scratch byl zawsze
  domyslnie otwierany, i automatycznie zapisywany
- ach no i oczywiscie chcemy
  - podswietlac HeadTailSeparator
  - miec mozliwosc drag&dropowania HeadTailSeparatora
  - kasowania go backspacem i deletem
- no i bardziej wybiorcza inwalidacja cache'u +
  renderowanie tylko tych rzeczy, ktore sa widoczne na ekranie

zaczniemy od kolorowania paleczki

to teraz jest tak, ze metoday draw! implementacji
HeadTailSeparator olewaja kontekst i wywoluja
draw-horizontal-bar! albo draw-vertical-bar! malarza
i teraz propozycja jest taka, zeby te metody dostaly
dodatkowy argument - boolean - ktory by decydowal o tym,
czy jest "highlighted".


* 02.11.2023

no dobra, to teraz trzy duze tematy, ktore bysmy chcieli miec
rozwiazane w listopadzie:
- poruszanie strzalkami w gore i w dol
- poruszanie kursorem po rozszerzeniach (w szczegolnosci
  po stepperze, no ale wiadomka)
- selekcja i integracja ze schowkiem

w sumie to tez spoko by bylo miec mozliwosc wyszukiwania rzeczy,
bo to daloby nam szanse na uzycie GRASPa do faktycznej edycji
kodu

no ale zacznijmy od ttch strzalek nieszczesnych

z grubsza rzecz powinna przebiegac w taki sposob, ze:
- w przypadku tekstu i komentarzy blokowych sprawa jest jasna
  (o ile pominiemy warunki brzegowe)
  
- w przypadku spacji/komentarzy liniowych sprawa jest
  dosc tajemnicza

- w przypadku atomow jest tak jak w przypadku tekstu

wiec teraz fundamentalny problem to owa tajemniczosc

czyli tak:
- jezeli jestesmy na tekscie, wiemy co robic
- w przeciwnym razie to lista, na ktorej jestesmy,
  powinna wiedziec

No ale jakze to?!

#+BEGIN_SRC scheme
  (define (move-cursor-up!)::void
    (let ((cursor ::Cursor (the-cursor))
	  (document ::Document (the-document)))
      (set! (the-cursor) (document:cursor-above* cursor))))

  (define (move-cursor-down!)::void
    (let ((cursor ::Cursor (the-cursor))
	  (document ::Document (the-document)))
      (set! (the-cursor) (document:cursor-below* cursor))))

  (define (cons:cursor-below* cursor::Cursor context::Cursor)::Cursor*
    )
 #+END_SRC

Czy jest jakis sposob zeby wykorzystac traverse?

* 01.11.2023

trzeba zrobic tak, zeby parser po kropce obsugiwal wszystkie
quote'y

ale w tym celu bedzie tez trzeba najpierw dopisac testy!

No dobra, wydaje sie, ze Mamy To.

W takim razie jutro bysmy sie zajely dalszymi testami,
tzn. test-editor-operations, bo je trzeba robic na telefonie


* 31.10.2023

No dobra, to teraz kwestia tego, w jaki sposob chcemy obsluzyc
cursor-above* oraz cursor-below*.

Zaczniemy od spacji.

Ale mozemy tez zajac sie innymi rzeczami, takimi jak:
- obsluga entera kiedy jestesmy na spacjach
- kasowanie rozszerzen
- rysowanie szarego tla wokol dokumentu
- albo chociaz tym, zeby podwojne klikniecie na atom albo lewy nawias
robilo nam kopie danego elementu
- oraz jeszcze chcemy miec pulling-the-rug-splicing
- (i moze tez zechcemy wrocic do naszego filtru Kalmana)
- a no i tez trzeba by bylo przywrocic dzialanie testow
- i "normalne" kopiowanie za pomoca podwojnego tapniecia

* 30.10.2023

no dobra, to musimy znow zgromadzic nieco wiedzy odnosnie tego:
- jak dzialaja teraz move-cursor-up! oraz move-cursor-down!
- jakie mamy implementacje interfejsu Element w naszej bazie
  kodu
- jak powinny wygladac implementacje cursor-above* oraz
  cursor-below* dla poszczegolnych implementacji

No to tak: mamy sobie oczywiscie
Space
oraz
wiele implementacji Tile, takich jak:
- Atom
- cons
- Text
- BlockComment
- LineComment
- ExpressionComment
- HorizontalBar
- VerticalBar  

* 29.10.2023

No to teraz plan jest taki, zeby:
- dodac metody "cursor-above*" oraz "cursor-below*" do interfejsu Element
- za ich pomoca wyrazic "move-cursor-up!" oraz "move-cursor-down!"

Ale moze najpierw sprobujmy moze rozwiazac ten blad z rysowaniem linii.

* 27.10.2023

no dobra, mamy napisany juz fragment "rozpoznawaczki" dla gestu ewaluacji,
ale zeby to skonczyc, musimy zbudowac takie oto zdanie:

- pierwszy punkt i ostatni punkt sa na tym samym poziomie
 (daja ten sam kursor)
- srodkowy punkt jest na glebszym poziomie
- ewaluujemy wyrazenie na poziomie "stemu", i za nim umieszczamy wynik

[Docelowo pewnie bedziemy chcieli moc sobie definiowac target danego
edytora jako jakis inny edytor, i wtedy bedzie to trzeba pozmieniac,
ale na razie jeszcze nie]

* 26.10.2023

trzeba tak zrefaktoryzowac Recognizera, zeby przybieral dodatkowy argument
- zwracany przez funkcje "recognizes" ktora powinna zwracac Object
zamiast boolean, i jezeli ta wartosci jest rozna od #f i #!null,
to wtedy powinnismy wywolywac "action"

* 24.10.2023

musimy na pewno naprawic zachowanie (ctrl enter) w sytuacji, gdy jestesmy
na spacji

do tego dochodzi kwestia tego, czy moze bysmy chcieli kolorowac definicje

(i ewentualnie przyklady)

* 23.10.2023

mamy juz ten modul. teraz chcemy napisac funkcje, ktora dokona
ewaluacji wyrazenia pod kursorem, i wpisze wynik tej ewaluacji
na nastepna pozycje

* 19.10.2023

stworzylibysmy modul (editor input evaluation) do ktorego
bysmy przeniesli niektore metody zwiazane z ewaluacja

* 18.10.2023

na razie proby zaktualizowania sdk spalily na panewce - byc moze
to kwestia odpowiedniego pliku android.jar (ale zmiana na szybko
nie sprawila, ze zaczelo dzialac, a i byc moze konieczne byloby
przebudowanie Kawy)

jutro zrobimy commit ze slajdow na JUG, natomiast w miedzyczasie
bysmy sie zajeli ewaluacja w edytorze

(i moze jeszcze zbudowaniem GRASP w oparciu o CheerpJ)

przy czym tutaj jest taka kwestia, ze:
- docelowo bysmy pewnie chcieli robic ekspansje makr po naszej stronie
- teraz mamy dwa interpretery: Kawe oraz stepper. Kiedy sie bedzie
  dalo, bedziemy wysylac definicje do obu z nich. Jak sie
  nie bedzie dalo do steppera, to powinnismy przynajmniej wypluc
  warning

wiec poczatkowo przyjmiemy sobie, ze rzeczy typu
`(define (,name . ,args) . ,value) oraz `(define ,name ,value)
wysylamy do steppera.

No dobra, ale ogolnie od czegos trzeba zaczac.

To zaczniemy od tego, zeby ctrl+enter oraz ctrl+e powodowaly
ewaluacje biezacego/poprzedniego wyrazenia

* 16.10.2023 (telefon)

sprobowalibysmy teraz obsluzyc zmiany w skrypcie do budowania
na Androidzie (tak zeby dalo sie budowac dla SDK>=30)


* 14.10.2023 (komputer)

plan jest taki:
- jutro commitujemy zmiany z komputera
- w poniedzialek zmiany z telefonu
- do tego implementujemy (na komputorze) obracanie ekranu (sroda)
- i moze jeszcze obsluge rolki myszki na Androidzie (czwartek)

i wtedy w kolejnym tygodniu bysmy sie zajeli integracja ewaluatora
(wlaczajac w to gest klinu), a kiedy to juz bedziemy mieli, to
zrobimy poprawki 

* 13.10.2023 (komputer)

jezeli chcemy miec mozliwosc scrollowania zawartosci pop-upu,
to prawdopodobnie powinnismy zrobic tak, zeby te metody do
scrollowania byly albo w Interactive

ok, scrollowanie popupu juz dziala. czyli w zasadzie
zostalo nam zoomowanie i scrollowanie edytora

* 13.10.2023 (telefon)

zidentyfikowalismy kilka problemow zwiazanyvh z wybieraczka,
i trzeba troche zrefaktoryzowac kod

- zmienilibysmy nazwe z open-document na open-document-file!
- musimy tez dodac opcje wczytania dokumentu z portu/strumienia

i jak to zrobimy, zintegrujemy wybieraczke
a po niej takze zapisywaczke

a na kompie bysmy zrobili te zoomy i scrolle

* 10.10.2023 (telefon)

#+BEGIN_SRC java
  import android.content.Intent;
  import android.net.Uri;
  import android.content.Context;

  private static final int OPEN_REQUEST_CODE = 1;
  private void pickFile() {
      Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
      intent.addCategory(Intent.CATEGORY_OPENABLE);
      intent.setType("*/*");
      startActivityForResult(intent, OPEN_REQUEST_CODE);
  }

  @Override
  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
      if (requestCode == OPEN_REQUEST_CODE
	  && resultCode == RESULT_OK
	  && data != null) {
	  open(data.getData());
      }
  }
#+END_SRC

musimy teraz jakos zintegrowac wybieraczke z nasza architektura.

konkretnie chcielibysmy miec mozliwosc wyboru, czy chcemy
uzywac wbudowanej wybieraczki, czy systemowej (na androidzie
i ew. desktopie)
  
nalezaloby to zrobic tak, ze aktualna funkcja bylaby
parametrem

#+BEGIN_SRC scheme
  (define-parameter (open-file)::(maps (byte java.io.File Editor)
				       to: (maps _ to: void))
    (lambda (finger::byte editor::Editor)
      (lambda _
	(let ((keeper ::Keeper
		      (the-keeper)))
	  (keeper:with-read-permission
	   (lambda ()
	     (let ((window ::PopUp (open-file-browser
				    (keeper:initial-directory)
				    (this)))
		   (position ::Position
			     (last-known-pointer-position
			      finger)))
	       (window:center-around! position:left position:top)
	       (screen:overlay:add! window))))))))

  (define-parameter (save-file)::(maps (byte java.io.File Editor)
				       to: (maps _ to: void))
    (lambda _
      (let ((keeper ::Keeper
		    (the-keeper)))
	(keeper:with-write-permission
	 (lambda ()
	   (safely
	    (let ((window ::PopUp (save-file-browser
				   (keeper:initial-directory)
				   "filename.scm"
				   (this)))
		  (position ::Position
			    (last-known-pointer-position
			     finger)))
	      (window:center-around! position:left position:top)
	      (screen:overlay:add! window))))))
      #t))
#+END_SRC

* 10.10.2023 (komputer)

no to teraz rzecz tak wyglada, ze bysmy chcieli zrobic scrollowanie
myszka. Ale zeby to mialo sens, nalezaloby zrobic prolongowanie animacji.

Ale tego nie idzie zrobic ot tak, na szybko.

* 09.10.2023 (komputer)

bysmy zrobili zoomowanie i scrollowanie na myszce

no dobra, ale jak to musi dziaa?

to ciki orzech do zgryzienia!

powinno by tak, e kiedy obracamy walkiem w dol, to wywolujemy
metode scroll-down! na obiekcie Screen

* 09.10.2023 (telefon)

tych wszystkich zoomow i tak raczej na telefonie nie przetestujemy
wiec sie zajmijmy czym innym

najlepiej ewaluacja

czyli: wciskamy ctrl+e albo ctrl+enter albo jakis
klawisz funkcyjny (np. F3), albo rysujemy dziubek,
i w trybie ewaluacyjnym wolamy eval


ale moze na androidzie skupmy sie na razie na tym bledzie
z przesunietym y?

albo wybieraczka?

no dobra, wydaje sie ze przesuniete y juz jest naprawione

to teraz wybieraczka

Na pewno musimy zaimportowac Intent i Url

* 08.10.2023

No dobra, to teraz plan jest taki, zeby:

- zdarzenie od mouse-wheela bylo traktowane jako page-up/page-down
- zaimplementowac funkcje scroll-up! i scroll-down! 
  oraz scroll-left! i scroll-right!
- zaimplementowac funkcje zoom-in! i zoom-out!
- obsluzyc rolke myszki w kliencie terminalowym

* 07.10.2023

no dobra, to teraz plan chyba powinien byc jasny, mianowicie
w najblizszym czasie chcemy miec zoomowanie i scrollowanie
za pomoca rolki myszki, oraz mozliwosc ewaluacji (i to sie
powinno wydarzac w nadchodzacym tygodniu)

przy okazji chcemy tez obsluzyc page up/down oraz
gest ewaluacji

a jak to sie uda, to sie zajmiemy bugami w cursor-under
oraz renderowaniem krawedzi dokumentu, i refaktoryzacja
kombinatorow

scrollowanie do gory:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(409,257),absolute(415,284),button=0,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=1,preciseWheelRotation=1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

scrollowanie w dol:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(238,156),absolute(244,183),button=0,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=-1,preciseWheelRotation=-1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

zoom in:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(213,176),absolute(219,203),button=0,modifiers=Ctrl,extModifiers=Ctrl,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=-1,preciseWheelRotation=-1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

zoom out:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(219,164),absolute(225,191),button=0,modifiers=Ctrl,extModifiers=Ctrl,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=1,preciseWheelRotation=1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

Plan jest taki, zeby:
1. dodac last-known-pointer-position
2. ...

hmm, no wlasnie, i tutaj mamy problem.

konkretnie problem jest taki, ze obsluge klawiszy mamy zrobiona inaczej,
niz obsluge przycisku myszy.

wiec to rodzi pytanie, czy nie powinnismy tego ujednolicic?
(tak jak bylo w SLAYERze)

rzecz jednak w tym, ze jest zasadniza roznica pomiedzy wciskaniem myszy,
a wciskaniem klawiszy - w przypadku myszy mamy jeszcze obsluge upuszczania

z kolei w przypadku rolki myszy, AWT daje nam takie rzeczy, jak:
- scrollAmount
- wheelRotation
- preciseWheelRotation

ale wyglada na to, ze one i tak zawsze maja takie same wartosci :/

* 06.10.2023

kilka idei:
- wybieraczka do pliku na androidzie
- wybieraczka do pliku na desktopie

* 05.10.2023

jeszcze mamy prawdopodobnie 2 moduly (co powinnismy
moc przetestowac kompilujac na zewnetrznym storage'u)

dobra, wyglada na to ze jest ok

czyli dalszy krok to bedzie:
- przeniesienie kodu z TODO do wlasciwego kodu
- zastapienie extent extent+
- dodanie czyszczenia extent-cache'u przed rysowaniem
- zastapienie wszystkich x:extent i (invoke x 'extent)
  uzyciem (extent+ x)

no dobra. ale skoro mamy troche czasu, moze warto by sie
zastanowic, jak bysmy chcieli, zeby to wygladalo w GRASPie

najpierw otwieramy plik project.grasp

jest to plik zawierajacy anotacje dla poszczegolnych modulow.
pobjego zaladowaniu otwiera sie przegladarka modulow - mozemy na moduly
albo klikac, albo zoomowac

No ale dobrze, teraz plan jest z grubsza taki, ze mamy sobie

#+BEGIN_SRC scheme
(define-property+ (last-known-pointer-position finger::byte)::Position
  (Position left: 0 top: 0))
#+END_SRC

i chcemy, zeby:
- pop-upy sie otwieraly wokol tej pozycji
- zoomowanie za pomoca ctrl + rolki myszki bylo wokol tej pozycji
- chcielibysmy tez pgup/pgdn
- i zeby combinators przyjmowaly wariadyczne argumenty
- i ewaluacje chcemy miec, a moze nawet kompilacje

dobrze by tez bylo napisac skrypty do budowania takie, zeby
z tych samych klas budowac wszystkie 3 klienty
i zeby sledzic zaleznosci podczas kompilacji

(i skrypty do budowania moglyby byc napisane w Kawie)

* 04.10.2023

wyglada na to, ze restrukturyzacja sie powiodla - poza modulem
(extent), ktorym musielibysmy sie zajac

i przy okazji bysmy chcieli zrobic cache'owanie:

#+BEGIN_SRC scheme
(define-property (extent-cached? tile::Tile)::boolean
  #f)
#+END_SRC

i przy renderowaniu bysmy robili

#+BEGIN_SRC scheme
(define-property+ (cached-extent tile::Tile)::Extent
  (Extent width: 0 height: 0))

(define (extent+ tile::Tile)::Extent
  (let ((cached ::Extent (cached-extent tile)))
    (unless (is tile extent-cached?)
      (let ((fresh ::Extent (tile:extent)))
        (cached:assign fresh)
	(set! (extent-cached? tile) #t)))
    cached))
#+END_SRC

i na poczatku renderowania dokumentu bysmy robili

#+BEGIN_SRC scheme
(reset! extent-cached?)
#+END_SRC

tadam!

poza tym trzeba w ramach restrukturyzacji zrobic jeszcze jedna zmiane,
mianowicie pozmieniac nazwy modulow. Tak na szybko:

#+BEGIN_SRC bash
./rename-module.sh "(editor types space)" "(editor types spaces)"
# ./rename-module.sh "(extent)" "(editor types measurements)"
./rename-module.sh "(editor types text)" "(editor types texts)"
./rename-module.sh "(editor types extensions extension)" "(editor types extensions extensions)"
./rename-module.sh "(editor interfaces painter)" "(editor interfaces painting)"
./rename-module.sh "(editor interfaces postponed)" "(editor interfaces delayed)"
./rename-module.sh "(editor types extensions button)" "(editor types extensions widgets)"
./rename-module.sh "(editor input recognizer)" "(editor input gestures)"
./rename-module.sh "(editor input transform)" "(editor input transforms)"
./rename-module.sh "(editor types extensions stepper)" "(editor types extensions visual-stepper)"
./rename-module.sh "(editor document history)" "(editor document history-tracking)"
#+END_SRC

mozna rozwazyc napisanie skryptu

no dobra, wydaje sie ze wiekszosc rzeczy juz tu mamy zalatwione,
jeszcze pozostaje nam nieco problematyczny (extent).

Na razie pomysl jest taki, zeby zawartosc tego modulu przeniesc do
(editor interfaces painting), ale czy to sie uda?

Sie udalo. To teraz jutro zrobimy to cache'owanie.

* 02.10.2023

zaczniemy od zmodyfikowania skryptu analdep.scm w taki sposob,
zeby dzialal w podkatalogach

* 01.10.2023

na razie plan jest taki, zeby podzielic pliki na foldery o tak:
(i ew. pozmieniac modulom nazwy)

** lang/
for.scm
assert.scm
while.scm
examples.scm
define-interface.scm
infix.scm
define-cache.scm
define-syntax-rule.scm
hash-table.scm
parameterize-up.scm
define-type.scm
mapping.scm
match.scm
define-object.scm
keyword-arguments.scm
curry.scm
define-parameter.scm
define-property.scm

** utils
functions.scm
server.scm
conversions.scm
string-building.scm
print.scm
io.scm

** editor/
*** types
text.scm
primitive.scm
fundamental.scm
space.scm
comments.scm
extent.scm

**** extensions/
combinators.scm
quotations.scm
button.scm
extension.scm
stepper.scm
interactive.scm

*** input/
android-keymap.scm
terminal-keymap.scm
desktop-keymap.scm
recognizer.scm
input.scm
pane.scm
editor-operations.scm
touch-event-processor.scm
transform.scm

*** interfaces/
painter.scm
postponed.scm
indexable.scm

*** document/
parse.scm
document-operations.scm
document.scm
cursor.scm
history.scm

** tests/
test-stepper.scm
test-document-operations.scm
test-editor-operations.scm
test-painter.scm
test-lanterna.scm
check-comments.scm
test-parser.scm

** tools/
braille.scm
analdep.scm
run.scm
reference-stepper.scm
play-test.scm

** clients
grasp-android.scm
grasp-terminal.scm
grasp-desktop.scm
grasp.scm
term.scm
text-painter.scm

** trash
primitive-terminal-client.scm
test-writing-map.scm

* 30.09.2023

Wyglada na to, ze problem mamy taki, ze komponenty wyrazenia, 
ktore powinny zostac dissolvowane, nie zostaja.

x/19 MORPHS INTO ((lambda/58 (x/59) (x/60 x/61))
                  (lambda/54 (x/55) (x/56 x/57)))

(x/20 x/21) MORPHS INTO (((lambda/54 (x/55)
                                 (x/56 x/57))
                                (lambda/58 (x/59)
                                 (x/60 x/61))
                               ))
(lambda/22 (x/23) (x/24 x/25)
) MORPHS INTO ((lambda/58 (x/59)
                                (x/60 x/61)))

** > 0.6

((lambda/54 (x/55) (x/56 x/57))
 (lambda/58 (x/59) (x/60 x/61))) MORPHS INTO ((x/20 x/21))

to jest OK

(lambda/54 (x/55) (x/56 x/57)) MORPHS INTO (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
to juz nam przeszkadza

lambda/54 MORPHS INTO (lambda/22)
(x/55) MORPHS INTO ((x/23))
(x/56 x/57) MORPHS INTO ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)
) MORPHS INTO (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 MORPHS INTO (lambda/22)
(x/59) MORPHS INTO ((x/23))
(x/60 x/61) MORPHS INTO ((x/24 x/25))

* 29.09.2023

postanowienie jest takie, zeby sie zajac ((lambda (x) (x x)) (lambda (x) (x x)))
ale zacznijmy od tego, ze sobie opiszemy, co jest nie tak z biezacym zachowaniem,
albo w jaki sposob chcielibysmy, zeby to wygladalo.

1(2(lambda1 3(x2) 4(x3 x4)) 5(lambda5 6(x6) 7(x7 x8)))

W wyniku oczekujemy nowego wyrazenia

A(B(lambdaA C(xB) D(xC xD)) E(lambdaE F(xF) G(xG xH)))

i teraz tak:

- wyrazenie 4(x3 x4) powinno przemorfowac w A(B E)
- argument x2 powinien przemorfowac w B i E,
  ktore sa kopiami 5
- nawiasy 1 powinny zniknac
- nawiasy 2 powinny zniknac
- lambda1 i nawiasy 3 powinny zniknac
- cale wyrazenie 5 i jego podwyrazenia powinny zniknac
  (ale jego kopie, czyli B i E, powinny byc progeny
  wyrazenia x2, i oczywiscie x2 powinno byc ich originem)

Na razie wyglada tak, ze operandy sie nie dissolvuja

Teraz niejako wymusilismy na nich dissolvowanie sie

OK, juz prawie to mamy, tylko jeszcze z jakichs wzgledow w drugiej
polowie sie nam narysowywuja wyrazenia

* 29.09.2023

postanowienie jest takie, zeby sie zajac ((lambda (x) (x x)) (lambda (x) (x x)))
ale zacznijmy od tego, ze sobie opiszemy, co jest nie tak z biezacym zachowaniem,
albo w jaki sposob chcielibysmy, zeby to wygladalo.

1(2(lambda1 3(x2) 4(x3 x4)) 5(lambda5 6(x6) 7(x7 x8)))

W wyniku oczekujemy nowego wyrazenia

A(B(lambdaA C(xB) D(xC xD)) E(lambdaE F(xF) G(xG xH)))

i teraz tak:

- wyrazenie 4(x3 x4) powinno przemorfowac w A(B E)
- argument x2 powinien przemorfowac w B i E,
  ktore sa kopiami 5
- nawiasy 1 powinny zniknac
- nawiasy 2 powinny zniknac
- lambda1 i nawiasy 3 powinny zniknac
- cale wyrazenie 5 i jego podwyrazenia powinny zniknac
  (ale jego kopie, czyli B i E, powinny byc progeny
  wyrazenia x2, i oczywiscie x2 powinno byc ich originem)

Na razie wyglada tak, ze operandy sie nie dissolvuja

Teraz niejako wymusilismy na nich dissolvowanie sie

OK, juz prawie to mamy, tylko jeszcze z jakichs wzgledow w drugiej
polowie sie nam narysowywuja wyrazenia


1(2(lambda1 3(x2) 4(x3 x4)) 5(lambda5 6(x6) 7(x7 x8)))

A(B(lambdaA C(xB) D(xC xD)) E(lambdaE F(xF) G(xG xH)))


                     
  lambda/18  x/19    
                     
                     
   x/20              
                     
                     
   x/21              
                     
  ~      ~           
  lambda/22  x/23    
                     
                     
   x/24              
                     
                     
   x/25              
                     

                    
  lambda/54  x/55   
                    
                    
   x/56             
                    
                    
   x/57             
                    
  ~      ~          
  lambda/58  x/59   
                    
                    
   x/60             
                    
                    
   x/61             
                    

** najpierw

x/19 morphs into ((lambda/58 (x/59) (x/60 x/61))
                  (lambda/54 (x/55) (x/56 x/57)))

(x/20 x/21) morphs into (((lambda/54 (x/55) (x/56 x/57))
                          (lambda/58 (x/59) (x/60 x/61)))
                         ((lambda/54 (x/55) (x/56 x/57))
                          (lambda/58 (x/59) (x/60 x/61))))

(lambda/22 (x/23) (x/24 x/25)) morphs into ((lambda/58 (x/59)
                                (x/60 x/61)))

** i w druga strone:

((lambda/54 (x/55) (x/56 x/57))
 (lambda/58 (x/59) (x/60 x/61))) morphs into ((x/20 x/21)(x/20 x/21))
(lambda/54 (x/55) (x/56 x/57)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/54 morphs into (lambda/22)
(x/55) morphs into ((x/23))
(x/56 x/57) morphs into ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 morphs into (lambda/22)
(x/59) morphs into ((x/23))
(x/60 x/61) morphs into ((x/24 x/25))
(lambda/54 (x/55) (x/56 x/57)
 . #<not a pair>) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/54 morphs into (lambda/22)
(x/55) morphs into ((x/23))
(x/56 x/57) morphs into ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 morphs into (lambda/22)
(x/59) morphs into ((x/23))
(x/60 x/61) morphs into ((x/24 x/25))

** po zmianach

*** najpierw

x/19 morphs into ((lambda/58 (x/59) (x/60 x/61)
                  )
                  (lambda/54 (x/55) (x/56 x/57)
                  ))
(x/20 x/21
) morphs into (((lambda/54 (x/55)
                                 (x/56 x/57))
                                (lambda/58 (x/59)
                                 (x/60 x/61))
                               ))
(lambda/22 (x/23) (x/24 x/25)
) morphs into ((lambda/58 (x/59)
                                (x/60 x/61)))


*** i w druga strone

((lambda/54 (x/55) (x/56 x/57))
 (lambda/58 (x/59) (x/60 x/61))) morphs into ((x/20 x/21))
(lambda/54 (x/55) (x/56 x/57)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/54 morphs into (lambda/22)
(x/55) morphs into ((x/23))
(x/56 x/57) morphs into ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)
) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 morphs into (lambda/22)
(x/59) morphs into ((x/23))
(x/60 x/61) morphs into ((x/24 x/25))

* 29.09.2023 (telefon)

na kompie dalej procesujemy lambdy, i moze sie to uda jakos
zrobic

natomiast co chcemy robic dalej?

jest sporo takich rzeczy, no powiedzmy, nieciekawych,
ktorymi jednak warto by sie bylo zajac, takimi jak edycja,
czy poruszanie sie kursorem po przyciskach, czy tez wiele
innych tego rodzaju rzeczy, ktore zapewne by trzeba bylo
skatalogowac

jest tez kwestia uporzadkowania repo, i to chyba lepiej
by bylo zrobic szybciej niz pozniej

a, no i integracja ewaluatora, i ewentualnie kolorowanie
wyrazen

i scrollowanie, pg-up/pg-dn, zoomowanie etc.

natomiast tym, co naprawde chcemy robic dalej, jest algorytm A*
i wizualizacja grafow

* 28.09.2023

bysmy sie zajeli tym, zeby nienazwane lambdy redukowac inaczej,
niz lambdy nazwane

w przypadku lambd nazwanych:
- wartosci argumentow rozszczepiaja sie do ciala

natomiadt w przypadku lambd nienazwanych
- wartosc argumentu znika, ale
- argumenty z lambdy morfuja w kopie argumentow

* 27.09.2023

przede wszystkim mamy do zrobienia renderowanie ramek w kliencie
androidowym, oraz przywrocenie dzialania klawiatury

na razie pomysl jest taki. zeby dodac haki

* 25.09.2023

dziaiaj nic nie musimy, bo jutro konferencja
czyli male swieto

natomiast dobrze by bylo zaimplementowac draw-border!
oraz border-size na Androidzie (i to by byl srodowy commit)

ale poza tym pizostaje nam w tym tygodniu:
- czwartek, piatek, sobota

i teraz bysmy wzieli na tapet, no, cos innego?

pomyslow jest kilka:
- wizualizacja grafow
- naprawianie bugow?
- obsluga rolki myszki

* 23.09.2023

dzisiaj bysmy sie zajeli tymi guzikami

no dobra, to poszlo szybko

to teraz nam jeszcze pozostaja takie rzeczy:
- po pierwsze, cos sie brzydko te nawiasy renderuja
- po drugie, musimy zrobic obwodkie wokol steppera
- po trzecie, musimy naprawc to, ze jak dochodzimy
do konca, to potem sie nie mozemy cofac

* 22.09.2023

bledy na dzis:
1. to ze sie nam 5 nie roztraja
2. jak dochodzimy do 120, to potem nie mozemy sie cofnac

(jak to sie uda zrobic, to bedzie niezle, ale w naszym backlogu
musi byc jeszcze zepsuta obsluga guzikow, i brak obwodki wokol
steppera)

To teraz zajmimy sie tym roztrajaniem piatek (bo sprawa wydaje sie
powazna)

Otoz chodzi o to, ze jak dokonujemy redukcji lambdy, to powinnismy
wtedy rowniez aktualizowac argumenty

OK, wydaje sie ze to juz jest robione, ale w dalszym ciagu cos
jest nie tak.

Mianowicie chodzi o to, ze:
- jezeli zrodlowa piatka jest rysowana jako foreground, to
wydaje sie OK (pomijajaca to, ze docelowa piatka jest rysowana
na backgroundzie)
- jezeli zas najpierw rysujemy destination, to zrodlowa piatka
w ogole nie jest rysowana


* 21.09.2023

Musimy sie teraz dowiedziec dlaczego jak mamy transformacje z

(* 5@1 (! (pred 5@2)))

do

(* 5@3 (! 4))

to odpowiednikiem 5@2 jest 5@3

bo to, ze 5@3 jest odpowiednikiem 5@1 nie jest w ogole
zaskakujace i tak powinno byc

No to przemyslmy.

ORIGIN of 5 1991027336: (n) (1456412048)
ORIGIN of 5 1319877582: (n n) (1456412048 1456412048)
ORIGIN of 5 823397198: (n n n) (1456412048 1456412048 1456412048)
drawing identical 5 1279377109 1991027336 (5) (1991027336)

No dobra, to teraz plan jest taki:
1. dodajemy interfejs "matchable" i warunek w pattern matcherze
2. implementujemy ten interfejs w Atomie
3. usuwamy implementacje hashCodei equals z Atomu
4. robimy wyszukiwanie oparte o "name" atomu

Wydaje sie, ze te rzeczy juz jako tako dzialaja.

Teraz do zrobienia mamy znowuz:
- wyjasnienie, dlaczego zamykajace nawiasy na siebie nachodza
- wyjasnienie, dlaczego ! -> (if ...) dziala OK, ale jak rysujemy
  w druga strone, tj. (if -> ...) -> !, to juz nie dziala
  (i naprawienie tego)
- sprawienie, zeby ta nieszczesna 5-tka sie roztrajala,
  bo to bedzie bardzo fajne

A jak to sie uda, to bysmy jeszcze sie zajeli naprawa guzikow
i rysowaniem obwodki wokol steppera.

* 21.09.2023 (telefon)

po pierwsze, z jakichs wzgledow "n" przy substytucji
jest zawsze zamienialne


no ale ale, wyglada na to, ze mamy naszego winowajce
- a jest nim tozsamosc atomu, ktorej uzywamy do wydobywania
  elementow ze srodowiska

zatem teraz plan jest raki, zeby pozbyc sie tozsamosci atomu,
i zeby uzywac nazwy tego atomu do wysxukiwania


* 20.09.2023

problemy, ktore chcemy teraz rozwiazac:

1. przy morfowaniu

(if (<= 5 0)
    1
    (* 5 (! (pred 5))))

do

(if #f
    1
    (* 5 (! (pred 5))))

nagle w tle pojawia sie <=, 0 oraz ostatnie 5

2. przy morfowaniu

(if #f
    1
    (* 5 (! (pred 5))))

do

(* 5 (! (pred 5)))

pozycje wyrazen sa odwrocone.

Byc moze jest tak, ze w "draw-morph!" zamieniamy
ze soba role argumentow?

3. jak mamy (* 5 (! (pred 5)))

to sie nam to wyswietla jako

(*   (! (pred 5)

Wyglada na to, ze tutaj problemem jest to, ze symbole * i 5
pojawiaja sie wiele razy

4. chcielibysmy jeszcze, zeby 5 z (! 5) bylo utozsamiane
z trzema wystapieniami 5 w definiensie
(i na to trzeba wypracowac jakis mechanizm)

Jednakowoz zajmijmy sie najpierw tym pierwszym problemem.

* 19.09.2023 (wieczor, komp)

na razie wyglada na to, ze mamy problem z tozsamoscia
obiektow. zatem plan jest pokrotce taki:
1. zmieniamy domyslne odwzorowanie pochodzenia/potomnosci
z (recons element '()) na '()
2. do reduce/substitute dodajemy kopiowanie atomow
+ sledzenie pochodzenia
3. musimy jeszcze jako uwzglednic tranzytywnosc
czegos takiego, ze mamy kilka n-ow, i one sa zastepowane
przez 5-tke

(! 5)

(lambda (n)
  (if (<= n 1)
     1
    (* n (! (- n 1)))))

(if (<= 5 1)
   1
  (* 5 (! (- 5 1))))

Na poziomie kodu odbywa sie to w taki sposob, ze wewnatrz
reduce'a robimy (reduce (cons (context:value operator) operands)),
i ten wewnetrzny reduce maczuje operator do `(lambda ,args ,body)
i robi (substitute args #;with operands #;in body).

* 19.09.2023 (telefon)

mamy stepper, ktory oglednie wydaje sie jakos dzialac,
ale w ktorym roi sie od bugow

wiec plan teraz jest taki:
- zdiagnozowac i naprawic to co sie tam dzieje
- zrobic obwodke wokol steppera
- ponaprawiac guziki

jezeli to wszystko sie uda, to dodalibysmy jeszcze
mozliwosc ewaluacji wyrazen (ctrl+enter / klin)
i bysmy mieli w zasadzie wszystko gotowe do wtorkowego
dema (i wtedy jeszcze moze bysmy zrobili animacje
wcisnietego guzika, i ewentualnie wciskanie guzikow
z klawiatury)

ale najpierw trzeba sie zajac tymi bledami w animacjach
i przemyslec to, jak je najlepiej diagnozowac

no to moze tak: bysmy zrobili, zeby guzik >| nie odpalal
animacji, a tylko zwiekszal progress w biezacym morphie,
a po dojsciu do 1.0 aktualizowal morpha - i wtedy bysmy sobie
krok po kroku ogladali co sie dzieje, najpierw z tlem,
a pozniej z foregroundem

jezeli to sie uda jako tako spiac, to bysmy najpierw zrobili
ramke wokol steppera, a nastepnie naprawili guziki,
zmieniajac kombinatory w taki sposob, zeby mogly przyjmowac
dowolnie wiele argumentow

* 18.09.2023

wyglada na to, ze musimy dostosowac nasz stepper
do wspolpracy z atomami.

do tego celu bedziemy potrzebowac:
- funkcji "grasp", ktora zmieni nam reprezentacje
lispowa obiektu na reprezentacje graspowa (czyli pairy na consy,
liste pusta na (empty), stringi na Text, a pozostale atomy
na Atomy)

 ;""
 ;" "
;;"  "
;" "
;""

* 17.09.2023

potrzebujemy terax sobie zdefiniowac:
- morph-from
- morph-to

* 16.09.2023

bysmy sie zajeli memoizacja:

(memoize proc) musi dzialac tak, ze rekurencyjnie
wydobywa cache, a w momencie, gdy


* 15.09.2023

wydaje sie, ze teraz nam pozostalo:
- kopiowanie cell-display-properties
- zbudowanie playera

no, to teraz juz tylko zbudowanie playera xD







    /    


#+BEGIN_SRC scheme

  (define (PlayerWithControls player::Playable)
    (Below
	 top: player
	 bottom:
	 (Beside
	  left:
	  (Beside left: (Button label: "|<<"
				action: (lambda () (player:rewind!)))
		  right: (Button label: " |<"
				 action: (lambda () (player:back!))))
	  right:
	  (Beside
	   left: (Button label: " > "
			 action: (lambda () (player:play!)))
	   right:
	   (Beside left: (Button label: ">| "
				 action: (lambda () (player:next!)))
		   right: (Button label: ">>|"
				  action: (lambda ()
					    (player:fast-forward!))))))))
#+END_SRC

przy tej okazji mozemy zrefaktoryzowac Beside, Below i Over w taki
sposob, zeby braly listy elementow (zamiast par)

A moze na razie nie?

ok, to robimy

#+BEGIN_SRC scheme
(define-interface Playable ()
  (rewind!)::void
  (back!)::void
  (play!)::void
  (pause!)::void
  (next!)::void
  (fast-forward!)::void
  (playing?)::boolean)
#+END_SRC


#+BEGIN_SRC scheme
  ;; potrzebujemy takiego czegos, co by nam reprezentowalo
  ;; ewaluacje
  ;; Na razie mamy sobie klase Morph, i instancje tej klasy
  ;; i teraz tak:

  ;; jak musi dzialac nastepny krok?

  (define (next!)::void
    (let-values (((reduced origins progenies) (reduce next-expression)))
      (unless (equal? reduced next-expression)
	(let ((morph ::Morph (morph-between next-expression reduced
					    origins progenies)))
	(set! next-expression reduced)))))



#+END_SRC


  
* 14.09.2023

wydaje sie, ze spora czesc do tej pory napisanego kodu udalo sie
inkorporowac do modulu (stepper).

zasadniczo pozostaje nam jeszcze kopiowanie cell-display-properties
oraz kwestia substytucji

cell-display-properties jakos rozwiazemy, natomiast teraz musimy
przemyslec pewne aspekty zwiazane z substytucja

chodzi mianowicie o to, ze ilekroc dokonujemy substytucji,
chcemy otrzymywac nie podstawiony element, tylko jego kopie
(i to ja chcemy dodawac do dokumentu)

oznacza to, ze kazdy Element, a w kazdym razie kazdy Tile,
powinien byc Cloneable

wiec na te chwile plan jest taki:
1. sprawdzic, czy to, co mamy w tej chwili, nie robi
   problemiw przy budowaniu (i ew. naprawic)
2. zrobic commita

3. zajac sie tym, zeby Element byl clonable

lista instancji Element:
- Atom
- cons
- text
- comment
- quotation

 
* 13.09.2023

no to dzosiaj co robimy?
- modul stepper oraz funkcje do sledzenia "progenies"
  

* 12.09.2023

udalo sie nam sprawdzic to co chcemy, dopisujac testa.
wiec na razie mozemy sie wstrzymac z implementacja
ewaluacji (choc niewatpliwie dobrze by to bylo zrobic
w niedlugim czasie)

natomiast teraz trzeba wrocic do naszej ewaluacji

na raxie problem jest taki, ze ten nasz interpreter
nie zalezy od modulu primitive, a powinien, zebysmy
mieli dostep do takich czarodziejstw, jak cons*

wiec rzecz wyglada tak, ze:
- mamy referencyjny interpreter o zminimalizowanych zaleznosciach
- na jego bazie chcemy zbudowac docelowy interpreter, ktory
  - bedzie uzywal 'cons' z (primitive)
  - bedzie kopiowal cell-display-properties
  - bedzie odpowiednio ustawial origins i progenies
  - bedzie unikal kopiowania elementow, ktore sie nie zmieniaja
  - bedzie kopiowal elementy wynikajace z substytucji

i jak juz to sie nam uda napisac, to bedzie trzeba zrobic
ten widget playera

* 11.09.2023

przed dalszymi pracami bysmy dodali mozliwosc
ewaluacji wyrazen, co musi sie dziac w nastepujacych
krokach
1. wybieramy wyrazenie poprzedzajace kursor
2. w trybie ewaluacji wywolujemy 'eval'
3. wynik wyrazenia konwertujemy do postaci
   graspo-strawnej
4. wyrazenie wklejamy do terget-view (na razie
   przyjmujemy po prostu biezacy edytor)
   w okolicach aktualnego kursora


#+BEGIN_SRC scheme
  (define (focused-expression #;inside document #;at cursor)
    (otherwise #!null
      (and (is #;< (length cursor) > 1)
      ...)))
#+END_SRC

* 10.09.2023

mamy juz nawet przetestowany modul interpretera

no i co tera?

tera by my chcieli, zeby podczas redukcji 
zachowywac informacje o tym, ktore wyrazenia
stanowia odpowiedniki ktorych

do tego dochodzi jeszcze taka kwestia, ze mamy
te 'dwa swiaty': swiat ewaluacji i swiat edycji.

i tak: patterny sa pisane w 'jezyku ewaluacji',
ale moglibysmy sie postarac robic tak, zeby to nie mialo
znaczenia

z pewnoscia bedziemy potrzebowac zapewnienia, ze
patterny dzialaja zarowno w trybie edycji, jak i
ewaluacji

kolejna rzecz jest taka:
- jezeli wyrazenie zrodlowe i docelowe sa equal?
  to robimy

   (add! ((the-origin) result) source)
   (add! ((the-progeny) source) result)

   i w przypadku list iterujemy dodatkowo po
   wsztstkich elementach

- jezeli jeden element jest zawarty w drugim,
  to zbajdujemy ten element i robimy

  (add! ((the-origin) child) parent)
  (add! ((the-progeny) parent) child)

  i dodatkowo rekurencyjnie kojarzymy
  ze sob wssystkie elementy child
  i podwyrazenia parent

Natomiast w przypadku substytucji powinno byc tak,
ze za kazdym razem, kiedy dokonujemy substytucji:
- generujemy nowa kopie symbolu
- jako origin tego symbolu dodajemy odpowiednia wartosc
  z tablicy 'origin'

#+BEGIN_SRC scheme
  (property (item) (recons item '()))

  (define-parameter (the-origins)::(!maps (Object) to: (list-of Object))
    (lambda (x) (recons x '())))

  (define-parameter (the-progenies)::(!maps (Object) to: (list-of Object))
    (lambda (x) (recons x '())))

  (define (tracking-relations source
			      target
			      origins := (the-origins)
			      progenies := (the-progenies))
    (cond
      ((equal? source target)
       ;; here we simply go with the default option
       target)

      ((and (pair? source)
	    (any. (is _ equal? target) source))
       (for x in source
	 (cond
	  ((equal? x target)
	   (set! (progenies x) (recons source '()))
	   (set! (origins target) (recons x '())))
	  (else
	   (set! (progenies x) '())
	   target))))
      ))

#+END_SRC


Ogolnie wydaje sie, ze najwygodniej bedzie dodac do edytora
mozliwosc ewaluacji wyrazen

* 09.09.2023

wydaje sie, ze mamy juz napisany reduktor wyrazen ktory ma
szanse zadzialac, ale trzeba go teraz przetestowac

dlatego bysmy stworzyli modul interpreter, ktory by zawieral
te nasze funkcje

* 08.09.2023

dotychczasowy progres chyba trzeba przepisac z komputera
(albo wrzucic na brancha czy cos)

natomiast warto sie zastanowic albo nad stworzeniem trackujacej
wersji matcha, albo nad jakas owijka

#+BEGIN_SRC scheme

    (define (reduce expression context::EvaluationContext)
      (match expression
	(`(if #f ,then ,else)
	 else)
	(`(if ,test ,then ,else)
	 (let ((test* (reduce test context)))
	   (if (equal? test reduced-test)
	       then
	       `(if ,test* ,then ,else))))
	(`(lambda ,args ,body)
	 expression)
	(`(quote ,_)
	 expression)
	(`(,operator . ,operands)
	 (if (and (symbol? operator)
		  (context:defines-macro? operator))
	     (error "Macros not supported (yet)")
	     (let ((operands* (reduce-operands operands context)))
	       (if (isnt operands equal? operands*)
		   `(,operator . ,operands*)
		   (match operator
		     (,@symbol
		      (cond ((context:primitive? operator)
			     (apply (context:value operator)
				    operands))
			    ((context:defines? operator)
			     (reduce `(,(context:value operator)
				       . ,operands)
				     context))
			    (else
			     `(,operator . ,operands))))
		     (`(lambda ,args ,body)
		      (substitute args #;with operands
				  #;in body))
		     (`(,_ . ,_)
		      (let ((operator* (reduce operator
					       context)))
			`(,operator* . ,operands)))
		     (_
		      `(,operator . ,operands)))))))
	(_
	 (if (and (symbol? expression)
		  (context:defines? expression))
	     (context:value expression)
	     expression))))

    (define (reduce-operators operators context::EvaluationContext)
      (match operators
	(`(,first . ,rest)
	 (let ((first* (reduce first context)))
	   (if (equal? first first*)
	       `(,first . ,(reduce-operators rest context))
	       `(,first* . ,rest))))
	('()
	 '())
	(_
	 (reduce operators context))))

    (define (in. element collection)
      (any. (is _ eq? element) collection))

    (define (substitute variables #;with values #;in expression)
      (match expression
	(`(quote ,_)
	 expression)
	(`(lambda ,args ,body)
	 (let-values (((variables* values*) (only. (isnt _ in. args)
						   variables values)))
	   `(lambda ,args
	      ,(substitute variables* #;with values*
			   #;in body))))
	(`(,operator . ,operands)
	 `(,(substitute variables #;with values #;in operator)
	   . ,(substitute variables #;with values #;in operands)))
	(_
	 (if (symbol? expression)
	     (counterpart #;of expression #;from variables
			       #;in values)
	     expression))))

    (define (counterpart #;of variable #;from variables
			      #;in values)
      (match variables
	(`(,,variable . ,_)
	 (car values))
	(,variable
	 values)
	(`(,_ . ,rest)
	 (counterpart #;of variable #;from rest
			   #;in (cdr values)))
	(_
	 variable)))

  (define-object (EvaluationContext)
    ;;(define macro-definitions ::)

    (define definitions ::java.util.Map
      (let ((table ::java.util.Map (java.util.HashMap)))
	(table:put '+ +)
	(table:put '- -)
	(table:put '* *)
	(table:put '/ /)
	(table:put '< <)
	(table:put '<= <=)
	(table:put '> >)
	(table:put '>= >=)
	(table:put '= =)
	(table:put 'eq? eq?)
	(table:put 'eqv? eqv?)
	(table:put 'cons cons)
	(table:put 'car car)
	(table:put 'cdr cdr)
	table))

    (define (value symbol)
      (cond ((definitions:contains-key symbol)
	     (definitions:get symbol))
	    (else
	     (error "undefined symbol: "symbol))))

    (define (defines-macro? symbol)
     #f)

    (define (defines? symbol)
      (definitions:contains-key symbol))

    (define (define! name value)
      (definitions:put name value))

    (define (primitive? symbol)
      (and (definitions:contains-key symbol)
	   (let ((value (definitions:get symbol)))
	     (procedure? value))))
    )

#+END_SRC

* 07.09.2023

wydaje sie ze mamy juz wszystkie polprodukty
do zaimplementowania Morpha

to teraz potrzebujemy planu co robic dalej

no bo przeciez chcielibysmy miec tego morpha w naszej
bazie kodu jak najszybciej?

1. przenosimy kod z TODO do nowego modulu,
   (visual-evaluator)
2. piszemy kod odpowiedzialny za redukcje wyrazen,
   ktory dodatkowo buduje tablice, origin i progeny
3. piszemy sobie klase EvaluationPlayer, ktora
   zawiera guziki i tworzy nowe wyrazenia na zadanie
4. integrujemy EvaluationPlayer z interfejsem
   za pomoca gestu zagla

No dobra, to sprobujmy napisac sam ewaluator - przy czym
dla kazdego zastepujacego wyrazenia musimy tworzyc
nowa kopie!

#+BEGIN_SRC scheme

  (define (reduce expression context)
    (match expression
      (`(quote ,_)
       (set! (context:origin expression)
	     (union (context:origin) expression))
       (set! (context:progeny expression)
	     (union (context:progeny) expression))
       expression)
      (`(if #false ,then ,else)
       else)
      (`(if ,test ,then ,else)
       (let ((reduced-test (reduce test context)))
	 (if (equal? test reduced-test)
	     then
	     `(if ,reduced-test ,then ,else))))
      (`(lambda ,args . ,body)
       expression)
      (`(,operator . ,operands)
       (if (macro? operator context)
	   ...
	   (let ((reduced-operands (reduce-operands
				    operands
				    context)))
	     (if (equal? operands reduced-operands)



#+END_SRC

* 07.09.2023 (wieczorem, laptop)

Teraz bysmy chcieli napisac sobie cos, co by nam przeprowadzalo
redukcje

#+BEGIN_src scheme
(define (reduce expression context)
  (match expression
    (`(if #f ,then ,else)
     else)
    (`(if ,test ,then ,else)
     (let ((test* (reduce test context)))
       (if (equal? test test*)
          then
          `(if ,test* ,then ,else))))
    (`(quote ,_)
      expression)
    (`(lambda ,args ,body)
     expression)
    (`(,operator . ,operands)
     (if (context:defines-macro? operator)
         (error "Macros not supported (yet)")
         (let ((operands* (reduce-operands operands context)))
	   (if (isnt operands equal? operands*)
               `(,operator . ,operands*)
               (match operator
                 (,@symbol?
                  (if (context:primitive? operator)
                     (apply (context:value operator) operands)
                     `(,operator . ,operands)))
		 (`(lambda ,args ,body)
                   (substitute args #;with operands #;in body))
                 (`(,_ . ,_)
                  (let ((operator* (reduce operator context))) 
                    `(,operator* . ,operands)))
                 (_
                  `(,operator . ,operands)))))))
    (_
     (if (symbol? expression)
        (context:value expression)
        expression))))
                    
(define (substitute variables #;with values #;in expression)
  (match expression
    (`(quote ,_)
     expression)
    (`(lambda ,args ,body)
     (let-values (((variables* values*) (remove args #;from variables #;& values)))
       `(lambda ,args ,(substitute variables* #;with values* #;in body))))
    
    
#+END_src

* 06.09.2023

mamy with-intensity dla klientow graficznych, zostaje nam jeszcze
wariant dla klienta terminalowego - i jak to zrobimy, to bysmy
sie zajeli with-stretch

No to w kliencie terminalowym rzecz wyglada tak, ze mamy jedna
funkcje, letter, ktora przyjmuje argumenty domyslne
(the-text-color) oraz (the-background-color).

Mozemy ja teraz tak zmienic ze dodamy parametr
(the-text-intensity), i ze ona sobie bedzie w srodku
obliczac fakyyczny text-color jako interpolacje
pomiedzy kolorem tekstu i tla

oks, with-intensity juz mamy. teraz trzeba zrobic mala analize

no to tak:
- w przypadku klientow graficznych powinna wystarczyc
  zmiana skali oraz takie przesuniecie, ktore skompensuje
  zmiane skali na pozycji current-translation-left
  oraz current-translation-top
- w przypadku klientow tekstoeych nalezaloby odpowiednio
  zmienic definicje put!, tak zeby mnozyl docelowa wspolrzedna
  przez okreslona wartosc i ja zaokraglal


* 05.09.2023

to teraz mamy dwie rzeczy:
- painter:with-intensity
- painter:with-stretch

zaczniemy od with-intensity, bo tak

i teraz namy 3 klienty

w kkientach graficznych zamysl jest taki, zeby przeanalizowac
uzycia setColor

* 04.09.2023

zostaje nam jeszcze do przemyslenia kwestia implementacji
render-foreground! w kontekscie implementacji 'draw-morph!'

no to rzecz wyglada tak, ze chyba bysmy chcieli miec troche
symetrii z render-background!

no bo tak:
- draw-morph! przeksztalca nam dwa wyrazenia
- draw-background! rysuje wyrazenia tla, ktore
  nie maja swoich odpowiednikow (w szczegolnosci
  rysuje dla pudelek same nawiasy)
- a draw-foreground! powinien
  - dla wyrazen bez swoich odpowiednikow dzialac
    analogicznie do 'draw-background!' (moze nawet
    go wywolywac, choc to mogloby powodowac, ze to
    samo wyrazenie byloby wywolywane wiecej niz raz)
  - dla pozostalych wyrazen powinien rysowac morphy
    pomiedzy nimi a odpowiednikami

#+BEGIN_SRC scheme
  (define (render-foreground! expression::Element
			      counterparts::(maps (Element)
						  to: (list-of
						       Element))
			      source-position::(maps (Element)
						     to: Position)
			      target-position::(maps (Element)
						     to: Position)
			      intensity::float)
    ::void
    (let ((links (counterparts item))
	  (painter ::Painter (the-painter)))
      (cond
       ((empty? links)
	(draw-emerging! expression
			(source-position expression)
			intensity)
	(when (gnu.lists.LList? expression)
	  (traverse
	   expression
	   doing:
	   (lambda (sub::element t::Traversal)
	     (render-foreground! sub counterparts
				 source-position
				 target-position
				 intensity)))))

       (else
	(for x in links
	  (draw-morph! item x counterparts
		       source-position
		       target-position
		       intensity))))))
#+END_SRC

ok, wydaje sie ze mamy to.

teraz pozostaja nam do zaimplementowania:

- painter:with-intensity
- painter:with-stretch

we wszystkich 3 klientach, czyli w klientach graficznych
trzeba zadbac o to, zeby wszystkie dotychczasowe renderowania
uwzglednialy przezroczystosc

* 03.09.2023

a dzis z kolei bysmy sprobowali zaimplementowac draw-morph

#+BEGIN_SRC scheme

  (define (draw-morph! foreground::Element
		       background::Element
		       counterparts::(maps (Element)
					   to: (list-of
						Element))
		       source-position::(maps (Element)
					      to: Position)
		       target-position::(maps (Element)
					      to: Position)
		       intensity::float)
    ::void
    (let* ((p0 ::Position (source-position foreground))
	   (p1 ::Position (target-position background))
	   (painter ::Painter (the-painter))
	   (left ::real (linear-interpolation
			 from: p0:left to: p1:left
			 at: progress))
	   (top ::real (linear-interpolation
			from: p0:top to: p1:top
			at: progress)))
      (cond
       ((equal? foreground background)
	;; here we just draw the foreground
	;; with full intensity
	(with-translation (left top)
	  (draw! foreground)))

       ((or (isnt foreground Tile?)
	    (isnt background Tile?))
	;; at least one of the elements is (presumably)
	;; a space, so the only way we can morph them
	;; is by fading
	(with-translation (left top)
	  (painter:with-intensity (- 1.0 intensity)
	    (lambda ()
	      (draw! background)))
	  (painter:with-intensity intensity
	    (lambda ()
	      (draw! foreground)))))

       ((and (gnu.lists.LList? foreground)
	     (gnu.lists.LList? background))
	(let* ((e0 ::Extent (extent foreground))
	       (e1 ::Extent (extent background))
	       (width ::real (linear-interpolation
			      from: e0:width to: e1:width
			      at: progress))
	       (height ::real (linear-interpolation
			       from: e0:height to: e1:height
			       at: progress)))
	  (with-translation (left top)
	    (painter:draw-box! width height))
	  (traverse
	   foreground
	   doing:
	   (lambda (item::Element t::Traversal)
	     (render-foreground! item
				 counterparts
				 source-position
				 target-position
				 intensity)))))
       ((and (Tile? foreground)
	     (Tile? background))
	(let* ((e0 ::Extent (extent foreground))
	       (e1 ::Extent (extent background))
	       (width ::real (linear-interpolation
			      from: e0:width to: e1:width
			      at: progress))
	       (height ::real (linear-interpolation
			       from: e0:height to: e1:height
			       at: progress)))
	  (with-translation (left top)
	    (painter:with-intensity (- 1.0 intensity)
	      (lambda ()
		(painter:with-stretch
		    (/ width e1:width)
		    (/ height e1:height)
		  (lambda ()
		    (draw! background)))))
	    (painter:with-intensity intensity
	      (lambda ()
		(painter:with-stretch
		    (/ width e0:width)
		    (/ height e0:height)
		  (draw! foreground)))))))
       )))
#+END_SRC

* 02.09.2023

to teraz bysmy sie zajeli draw-background!

#+BEGIN_SRC scheme
  (define (draw-emerging! expression::Element p::Position
			  intensity::float)
    ::void
    (let ((painter ::Painter (the-painter)))
      (painter:with-intensity intensity
	(lambda ()
	  (with-translation (p:left p:top)
	    (if (gnu.lists.LList? expression)
		(let ((outer ::Extent (extent expression)))
		  (painter:draw-box! outer:width outer:height))
		(draw! expression)))))))

  (define (render-background! expression::Element
			      counterparts::(maps (Element)
						  to: (list-of
						       Element))
			      position::(maps (Element)
					      to: Position)
			      intensity::float)
    ::void
    (when (empty? (counterparts expression))
      (draw-emerging! expression (position expression) intensiy))
    (when (gnu.lists.LList? expression)
      (traverse
       expression
       doing:
       (lambda (sub::element t::Traversal)
	 (render-background! sub counterparts position
			     intensity)))))
#+END_SRC

* 01.09.2023

wydaje sie, ze juz jestesmy blisko

trzeba jeszcze tylko zrobic draw-morph! oraz draw-background!.
Zacznijmy zatem moe od tego ostatniego.

zasadniczo chodzi tutaj o to, ze po pierwsze rysujemy tylko
elementy bez counterpartow, a po drugie to tak:
- jak rysujemy atomy, to ze zmniejszona intensywnoscia
- jak rysujemy pudelka, to tylko nawiasy, oraz rekurencyjnie
  wszystkie elementy wewnatrz

co do zasady nie musimy tez uzywac 'traverse', poniewaz pozycje
obiektow sa 'uwolnione' (aczkolwiek wygodniej jest po prostu
olac traversale)

no dobra, czyli mozna powiedziec, ze chcemy miec
painter:with-intensity, ustawiamy odpowiednia intensywnosc
na poczatku, dla pudelka po prostu rysujemy nawiasy, i rekurencyjnie
przemiatamy, a dla atomow, spacji i rozszerzen rysujemy je tylko
wtedy, kiedy nie maja odpowiednikow, korzystajac z tabeli
z pozycjami

i tak ten draw-background powinien wygladac (a glowna trudnosc
lezy w tym, zeby go dobrze obsluzyc w painterze)

natomiast w przypadku draw-morph:
- sami wyliczamy sobie pozycje, w ktorych morphy
  maja sie znajdowac
- jezeli dwa elementy sa eq?, to rysujemy je normalnie
- jezeli mamy dwa atomy, to jakos je ze soba morfujemy
  (mozemy zaczac od zwyklej zmiany intensywnosci,
  ale pewnie najlepszy by byl Levenshtein)
- jezeli mamy dwa pudelka, to morfujemy ich rozmiar,
  a pozniej rekurencyjnie wywolujemy render-foreground!
  na elementach pierwszego z nich
- jezeli mamy atom/pudelko albo pudelko/atom, to sciagamy
  rozmiary pudelka do rozmiarow atomu i renderujemy
  z odpowiednia przezroczystoscia (w klientach graficznych
  to zadziala, ale w terminalowym bedziemy mogli uzyc
  randomizacji do skondensowania elementow)


* 31.08.2023

mamy destylat, ktory wyglada tak:

#+BEGIN_SRC scheme
  (define/kw (measure-positions!
	      expression
	      left::real := 0
	      top::real := 0
	      into:
	      measurements::(!maps (Element) to: Position)
	      := (property+ (element::Element)::Position
			    (Position left: 0 top: 0)))
    ::(maps (Element) to: Position)
    (when (list? expression)
      (traverse
       expression
       doing:
       (lambda (item::Element t::Traversal)
	 (let ((p ::Position (measurements item)))
	   (set! p:left (+ t:left left))
	   (set! p:top (+ t:top top))
	   (when (list? item)
	     (measure-positions! item p:left p:top
				 into: measurements))))
       returning:
       (lambda (t::Traversal)
	 measurements))))

  (define-object (Morph initial::Tile
			final::Tile
			origin::(maps (Element) to: (list-of
						     Element))
			progeny::(maps (Element) to: (list-of
						      Element)))
    ::Enchanted
    (define progress ::float 0.0)

    (define initial-position ::(maps (Element) to: (list-of Element))
      (measure-positions! initial))

    (define initial-extent ::Extent
      (extent original))

    (define final-position ::(maps (Element) to: (list-of Element))
      (measure-positions! final))

    (define final-extent ::Extent
      (extent final))

    (define maximum-extent ::Extent
      (Extent width: (max initial-extent:width
			  final-extent:width)
	      height: (max initial-extent:height
			   final-extent:height)))

    (define (extent) ::Extent maximum-extent)

    (define shift ::(maps (Element) to: Position)
      (property+ (element::Element)::Position
		 (Position left: 0 top: 0)))

    (define (draw! context::Cursor)::void
      (cond ((is progress <= 0.5) ;>
	     (render-background! final origin final-position
				 progress)
	     (render-foreground! initial
				 progeny
				 initial-position
				 final-position
				 (- 1.0 progress)))
	    (else
	     (render-background! initial progeny
				 initial-position
				 (- 1.0 progress))
	     (render-foreground! final
				 origin
				 final-position
				 initial-position
				 progress))))    
    (Magic))
#+END_SRC

I teraz moglibysmy zrobic cos takiego, ze napiszemy sobie
funkcje podobna do draw-sequence!, tyle ze uwzgledniajaca
shift - a moze nawet pare funkcji?

tylko jak by to mialo dzialac?

1. najpierw 'renderujemy' warstwe pod spodem (czyli te mniej widoczna)
   w taki sposob, ze jezeli brakuje odpowiednikow danego obiektu,
   to renderujemy rzecz normalnie (tylko z obnizona intensywnoscia),
   natomiast w przeciwnym razie wyliczamy shift na podstawie progresu
   
2. nastepnie 'rendrujemy' warstwe na wierzchu, przy czym robimy
   to w taki sposob, ze dla elementow bez odpowiednikow
   renderujemy rzecz normalnie, zas dla pozostalych elementow
   robimy tak, ze rysujemy morphy pomiedzy elementem
   i jego odpowiednikiem w miejscu wynikajacym z ustalonego
   przesuniecia
   
3. jeszcze pewna uwaga odnosnie rysowania morphow:
   mamy 4 rodzaje morphow:
   - atom-atom
   - pudelko-pudelko
   - pudelko-atom
   - atom-pudelko

   poniewaz jednak morfy powinny byc symetryczne, dwa ostatnie
   rodzaje to tak naprawde jeden rodzaj

   uwaga: rozszerzenia traktujemy tak jak atomy

   i teraz tak:
   - morfy 'pudelko pudelko' powinny sie odbywac w taki sposob,
     ze morfujemy rozmiar pudelka i rysujemy nawiasy,
     a nastepnie iterujemy po bazowym pudelku, rysujac
     morfy jego elementow z przesunieciami   - morfy atom-atom moga
     byc painter-specific, ale dla tekstu
     moglibysmy zrobic cos bazujacego na odleglosci Levenshteina
     natomiast w ogolnym przypadku bysmy zrobili zwykle
     przenikanie
   - morfy atom-pudelko zrobilibysmy jako zmiane rozmiaru pudelka
     i ewentualna kondensacje jego elementow do punktu poczatkowego
     przy jednoczesnym wylanianiu sie atomu


* 30-29.08.2023

#+BEGIN_SRC scheme
  (define (morph-decaying! counterparts::(maps (Element)
					       to: (list-of Element))
			   step::int
			   progress::float)
    ::void
    (assert (is 0.0 <= progress <= 1.0)) ;>>
    (let ((next-step ::int (+ step 1))
	  (painter ::Painter (the-painter)))
      (for x::Element in (keys counterparts)
	(when (and (empty? (counterparts x))
		   (= (reduction-step x) next-step))
	  (painter:with-intensity (- 1.0 progress)
	    (lambda ()
	      (x:draw! '())))))))

  (define (morph-emerging! counterparts::(maps (Element)
					       to: (list-of Element))
			   step::int
			   progress::float)
    ::void
    (morph-decaying! counterparts (- step 1) (- 1.0 progress)))

  (define (morph-expressions! original
			      derived
			      counterparts::(maps (Element)
						  to: (list-of Element))
			      step::int
			      progress::float)
    ::void
    ;; zamysl jest taki (niekoniecznie sluszny), zeby:
    ;; - w pierwszej polowie progresu zaczynac renderowanie
    ;; od 'derived' (poniewaz ma byc zaslaniane przez original),
    ;; a w erugiej od 'original' (ktore ma byc zasloniete przez
    ;; 'derived')
    ;; - z tego samego powodu w pierwszej polowie chcemy
    ;; najpierw rysowac te elementy 'derived', ktore
    ;; wylaniaja sie z nicosci, a dopiero na nich wszystkie
    ;; pozostale, zas w drugiej polowie chceny zaczynac od tych,
    ;; ktore znikaja z 'original', i dopiero na nich rysowac
    ;; rzeczy
    (cond
     ((is progress <= 0.5) ;>
      (morph-emerging! counterparts step progress)
      (morph-from! original #;to counterparts
		   #;at progress))
     (else
      (morph-decaying! counterparts step progress)
      (morph-from! derived #;to counterparts
		   #;at (- 1.0 progress)))))

  (define (morph-from! expression #;to counterparts
		       #;with progress)
    ::void
    (assert (is progress <= 0.5)) ;>
    ;; no dobra, to tutaj rzecz jest taka, ze musimy
    ;; ze soba morfowac zwykle elementy, ale rowniez
    ;; spacje.
    ;; i teraz plan jest z grubsza taki, zeby zachowywac
    ;; tozsamosc obiektow.
    ;; to jednak oznacza, ze nie mozemy miec jednej tablicy
    ;; counterparts, tylko dwie: origins i progenies
    ;; - ale wtedy nie potrzebujemy parametru step

    )


  (define/kw (measure-positions!
	      expression
	      left::real := 0
	      top::real := 0
	      measurements::(maps (Element) to: Position)
	      := (property+ (element::Element)::Position
			    (Position left: 0 top: 0)))
    ::(maps (Element) to: Position)
    (when (list? expression)
      (traverse
       expression
       doing:
       (lambda (item::Element t::Traversal)
	 (let ((p ::Position (measurements item)))
	   (set! p:left (+ t:left left))
	   (set! p:top (+ t:top top))
	   (when (list? item)
	     (measure-positions! item p:left p:top measurements))))
       returning:
       (lambda (t::Traversal)
	 measurements))))

  (define-object (Morph initial::Tile
			final::Tile
			origin::(maps (Element) to: (list-of Element))
			progeny::(maps (Element) to: (list-of Element)))
    ::Enchanted
    (define progress ::float 0.0)

    (define initial-position ::(maps (Element) to: (list-of Element))
      (measure-positions! initial))

    (define initial-extent ::Extent
      (extent original))

    (define final-position ::(maps (Element) to: (list-of Element))
      (measure-positions! final))

    (define final-extent ::Extent
      (extent final))

    (define maximum-extent ::Extent
      (Extent width: (max initial-extent:width
			  final-extent:width)
	      height: (max initial-extent:height
			   final-extent:height)))

    (define (draw! context::Cursor)::void
      (let ((painter ::Painter (the-painter)))
	(cond
	 ((is progress <= 0.5) ;>
	  (for x::Element in (keys progeny)
	    (when (is (progeny x) empty?)
	      (let ((shift ::Position (final-position x)))
		(with-translation (shift:left shift:top)
		  (painter:with-intensity (- 1.0 progress)
		    (draw! x))))))
	  (draw-morph! initial progress))
	 (else 
	  ...))))


    (Magic)
    ;; zaczynamy od tego, ze sobie "renderujemy" original
    ;; i "derived" do "niczego", tak zeby miec polozenia
    ;; wszystkich elementow
    )


#+END_SRC


* 25.08.2023

(define (draw-tween! source target progress)
  ;; rzecz jest taka, ze musimy rysowac zarazem
  ;; zrodlo i cel, przy czym (draw-tween! source target 0.0)
  ;; ma byc rownowazne (draw-tween! target source 1.0)
  ;; ktore ma byc rownowazne po prostu (draw! source)
  ;;
  ;; no i super, ale jeszcze kilka rzeczy wchodzi w gre
  ;; moze algorytm powinien dzialac tak, ze
  ;; renderujemy tak dlugo, dopoki nie zostanie
  ;; wyrenderowane wszystko z tablicy counterpart

  ;; sztuczka polega chyba na tym, ze nie renderujemy
  ;; source'a ani targeta, tylko morphy pomiedzy
  ;; sourcem i jego counterpartami, oraz pomiedzy
  ;; targetem a jego counterpartami. przy czym kolejnosc
  ;; rysowania zalezy od progresu

  ;; jest jakis taki pomysl zeby skakac po counterpartach
  ;; do czasu osiagniecia punktu stalego, tzn wyczerpania
  ;; wszystkich kluczy
  (if (is progress < 0.5);>
     (morph-from target progress)
     (morph-from source (- 1.0 progress)));; albo na odwrot
  
  )

(define (morph-from expression progress)
  (let ((targets (counterparts expression)))
    (if (null? targets)
       (decay! expression progress)
       (for target in targets
         (morph! expression target progress)))))

* 24.08.2023

morph expression into expressions at progress

for x in expressions
  morph1 expression into x with progress

gdzie

morph1 original into derived at progress

to cos w rodzaju

(cond
  ((and (list? original) (list? derived))
   (morph-boxes original derived progress))
  ((list? original)
   (morph-box-to-atom original derived progress))
  ((list? derived)
   (morph-atom-to-box original derived progress))
  (else
   ;; domyslnie morfujemy dwa atomy, to znaczy:
   ;; - polozenie atomu wynika z interpolacji
   ;;   polozen original i derived
   ;; - rozmiar atomu rowniez wynika z interpolacji


tak by wygladal ten kejs, w ktorym jedno wyrazenie
sie nam zwielokrotnia

natomiast jest jeszcze kejs, w ktorym jedno
pudelko zostaje przeksztalcone w inne pudelko

* 22-21.08.2023

teraz bedziemy mieli dluzsza przerwe, co oznacza nieco
wiecej swobody w pracach

za 3 tygodnie zajmiemy sie juz naprawianiem bugow
(oraz moze tez implementacja metod do poruszania
kursorem w pionie, i zalataniem mechanizmu selekcji,
i cache'owaniem 'extent')

ale do tego czasu mozemy nieco pomyslec o ewaluatorze
wizualnym

mamy miec funkcje

beginning
back
play/pause
next
ending

(define-type (Evaluation step: int
                         expansions: sequence)
  implementing Player
  with
  ...)

ogolnie tak: musimy miec jakas implementacje Animation,
czyli musi byc metoda (advance! time-step/ms::int)::boolean

musi tez byc metoda draw!, ktora musi wiedziec,
czy rysujemy finalna klatke, czy miedzyklaccie,
dlatego tez musimy znac biezacy progres

No ale dobrze, rozwazmy teraz kwestie samej ekspansji.
Kpd dokonujacy podstawienia wyglada tak:

  (define (substitute variables with: values in: expression)
    (match expression
      (`(quote ,_)
       expression)
      (`(,head . ,tail)
       `(,(substitute variables with: values in: head)
         . ,(substitute variables with: values in: tail)))
      (_
       (or (any (lambda (variable value)
                  (and (equal? variable expression)
		       value))
	        variables values)
	   expression))))
	   
i na jakis tam uzytek moze byc ok, ale my bysmy chcieli
zrobic cos takiego, ze w momencie, gdy renderujemy
klatke posrednia, wiemy, ktore wyrazenie odpowiada
ktoremu

(define (draw-between! source target progress::float)::void
  (let* ((source-extent (extent source))
         (target-extent (extent target))
         (width (interpolate source-extent:width
                             target-extent:width
      	                     progress))
	 (height (interpolate source-extent:height
	                      target-extent:height
			      progress)))
    (cond
      ((and (pair? source)
            (pair? target))
       (draw-sequence-between! source target progress))
      ...)))

no ale poczekajta! jak mamy takie cos:


((lambda (x y)
   (+ x y)) 2 3)


   (+ 2 3)

to chcielibysmy, zeby (+ 2 3) pojawilo sie w miejscu
(+ x y)

czy ogolniej, przesledzmy

(define (! n)
  (if (is n <= 1) ;>
     1
     (* n (! (- n 1)))))

i redukujemy

(! 5)

to wzamian powinismy dostac
						
(if (is 5 <= 1) ;>
     1
     (* 5 (! (- 5 1))))

i teraz w tym wyrazeniu powinnismy najpier zredukowac warunek

(if #false
     1
     (* 5 (! (- 5 1))))

i na tym etapie wyrazenia powinby byc traktowane jako rownorzedne.

ale juz kolejna redukcja, do

(* 5 (! (- 5 1)))

powinna wskazac, ze drugie wyrazenie jest w kontekscie
(7) pierwszego wyrazenia.

na dalszym etapie redukujemy

(* 5 (! 4))

ponownie nie zmieniajac kontekstu. Tak samo bedzie w przypadku

(* 5 (if (is 4 <= 1) ;>
       1
       (* 4 (! (- 4 1)))))

(* 5 (if #false
       1
       (* 4 (! (- 4 1)))))

natomiast przy kolejnej redukcji

(* 5 (* 4 (! (- 4 1))))

mamy wydobycie wyrazenia (7 5). Dalej bedziemy mieli:

(* 5 (* 4 (if (is 3 <= 1) ;>
             1
            (* 3 (! (- 3 1))))))

(* 5 (* 4 (if #false
             1
            (* 3 (! (- 3 1))))))

i na (7 5 5) mamy
	    
(* 5 (* 4 (* 3 (! (- 3 1)))))

(* 5 (* 4 (* 3 (! 2))))

(* 5 (* 4 (* 3 (if (is 2 <= 1) ;>
                  1
                 (* 2 (! (- 2 1)))))))

(* 5 (* 4 (* 3 (if #false
                  1
                 (* 2 (! (- 2 1)))))))

na (7 5 5 5)

(* 5 (* 4 (* 3 (* 2 (! (- 2 1))))))

(* 5 (* 4 (* 3 (* 2 (! 1)))))

(* 5 (* 4 (* 3 (* 2 (if (is 1 <= 1) ;>
                        1
                      (* 1 (! (- 1 1))))))))

(* 5 (* 4 (* 3 (* 2 (if #true
                        1
                      (* 1 (! (- 1 1))))))))

na (5 5 5 5 5):
		      
(* 5 (* 4 (* 3 (* 2 1))))


czyli zasadniczo mamy takie opcje:

1. oba wyrazenia sa rownorzedne
2. drugie wyrazenie powstalo z podwyrazenia pierwszego
3. drugie wyrazenie powstalo z owiniecia pierwszego

ha ha, zeby to bylo takie proste.
teoretycznie mamy jeszcze jedna mozliwosc: ze
jedno wyrazenie pojawia sie w drugim kilka razy.

Zalozmy zatem, ze mamy takie tablice:

(define-property (source-cursor cursor::Cursor)::Cursor
  cursor)

(define-property (source-position cursor::Cursor)::Position
  (error "Unknown position of source at "cursor))
  
(define-property (target-position cursor::Cursor)::Position
  (error "Unknown position of target at "cursor))

no ale troche tu mieszasz, co by nie mowic: bo czy my
chcemy moc przesuwac wyrazenia na ekranie?

moze chcemy, a moze nie chcemy. zalozmy jednak ze chcemy.

wtedy nasze dzialanie musi tak wygladac:
1. renderujemy dokument 'na pusto', zeby wypelnic tablice
   source-position i target-position
2. musimy zidentyfikowac czesci wspolne zrodla i celu
  

* 19.08.2023

scalanie splitow juz zasadniczo dziala,
wiec teraz bysmy chcieli zrobic jeszcze dwie rzeczy:
1. dodawac odpowiednie przesuniecie do dolnego/prawego
   splita
2. utrzymywac dwa odrebne zestawy podzialow
   dla orientacji pionowej i poziomej
   (a przynajmiej aktualizowac rozmiar ekranu
   po zmianie orientacji)

* 18.08.2023

zrobilismy pare zmian w implementacji filtru,
ale teraz chcialoby sie je przetestowac, czyli zintegrowac
z touch-event-processorem.

w tym celu do procesora trzeba dodac dwie zmienne,
x-tracker i y-tracker

po podpieciu okazalo sie, ze rzecz nie dziala najlepiej,
a najprostszy model pomiaru predkosci dziala w sumie
nie najgorzej

(define (drop! x y vx vy)
  (and-let* ((target ::Split (split-ref split-path))
             (first-size line-size last-size
	                 (target:sizes))
	     (velocity (target:varying-dimension vx vy)))
    (cond
     ((or (is first-size <= (* 3 line-size)) ;>
          (is velocity < -1.5)) ;>
      (merge-split! at: split-path with: SplitFocus:Last))
     ((or (is last-size <= (* 3 line-size))
          (is velocity > 1.5))
      (merge-split! at: split-path with: SplitFocus:First)))))

(define (merge-split! at: split-path with: focus::SplitFocus)::boolean
  (if (null? split-path)
    (and-let* ((split ::Split screen:top))
      (set! screen:top (split:part focus)))
    (and-let* ((`(,tip . ,root) split-path)
               (parent ::Split (split-ref root))
	       (split ::Split (parent:part tip)))
      (match tip
        (,SplitFocus:First (set! parent:first (split:part focus)))
	(,SplitFocus:Last (set! parent:last (split:part focus)))))

* 17-15.08.2023

filtr Kakmana - kroki:

1. estymacja stanu z modelu

   ~x[k] = A*x[k-1]

2. estymacja kowariancji

   ~P[k] = A*P[k-1]*A^T + Q

3. residuum pomiaru (innowacja)

   y[k] = z[k] - H*~x[k]

4. innowacja kowariancji:

   S[k] = H*~P[k]*H^T + R

5. wzmocnienie Kalmana:

   K[k] = ~P[k]*H^T*S[k]^-1

6. korekta stanu:

   x[k] = ~x[k] + K[k]*y[k]

7. korekta kowariancji:

   P[k] = (I - K[k]*H)*~P[k]

bardziej kompaktowo mamy:

   ~x[k] = A*x[k-1]
   ~P[k] = A*P[k-1]*A^T + Q
   y[k] = z[k] - H*~x[k]
   S[k] = H*~P[k]*H^T + R
   K[k] = ~P[k]*H^T*S[k]^-1
   x[k] = ~x[k] + K[k]*y[k]
   P[k] = (I - K[k]*H)*~P[k]

i teraz tak:

x[k-1] = [position-estimate
          velocity-estimate]

P[k-1] = [position-variance cross-covariance
          cross-covariance velocity-variance]

H = [1 0]

A = [1 time-step/ms
     0            1]
     
Q = [position-update-uncertainty position-velocity-uncertainty
     position-velocity-uncertainty velocity-update-uncertainty]

R = [position-measurement-uncertainty]

~x[k] = [predicted-position
         velocity-estimate]

y[k] = [prediction-error]

A*P[k-1] =
[position-variance+time-step/ms*cross-covariance  cross-covariance+time-step/ms*velocity-variance
 cross-covariance                                 velocity-variance]

A^T = [1            0
       time-step/ms 1]

A*P[k-1]*A^T =
[position-variance+time-step/ms*cross-covariance+time-step/ms*(cross-covariance+time-step/ms*velocity-variance)   cross-covariance+time-step/ms*velocity-variance
 cross-covariance+time-step/ms*velocity-variance                                                                  velocity-variance                               ]

 ~P[k] = [predicted-position-variance predicted-cross-covariance
          predicted-cross-covariance predicted-velocity-variance]

H*~P[k]*H^T = [predicted-position-variance]

~P[k]*H^T = [predicted-position-variance
             predicted-cross-covariance]

S[k] = [predicted-position-variance+position-measurement-uncertainty]

K[k] = [position-gain
        velocity-gain]

(I-K[k]*H) = [1-position-gain 0
              -velocity-gain  1]

P[k] =
[(1-position-gain)*predicted-position-variance (1-position-gain)*predicted-cross-covarianxe
 predicted-cross-covariance:-:velocity-gain*predicted-position-variance predicted-velocity-variance:-:velocity-gain*predicted-cross-covariance]


(define-interface VelocityTracker ()
  (update! position::float time-step/ms::float)::void
  (current-velocity)::float
  (reset!)::void
  )

(define-object (KalmanVelocityTracker)::VelocityTracker
  (define velocity-estimate ::float +nan.0)
  (define position-estimate ::float +nan.0)
  
  (define position-variance ::float 10.0)
  (define velocity-variance ::float 25.0)
  (define cross-covariance ::float 0.0)

  (define position-update-uncertainty ::float 5.0)
  (define velocity-update-uncertainty ::float 1.0)
  (define cross-update-uncertainty ::float 3.0)
  
  (define position-measurement-uncertainty ::float 1.0)
  
  (define (update! measured-position::float time-step/ms::float)::void
    (cond
      ((nan? position-estimste)
       (set! position-estimate measured-position))
      ((nan? velocity-estimate)
       (set! velocity-estimate
             (/ (- measured-position
	           position-estimate)
		time-step/ms))
       (set! position-estimate measured-position))
      (else
       (let* ((predicted-position ::float (+ position-estimate
                                             (* velocity-estimate
					        time-step/ms)))
	      (prediction-error ::float (- predicted-position
	                                   measured-position))
	      (predicted-position-variance ::float
                                           (+ position-variance
                                              (* time-step/ms
                                                 (+ (* 2 cross-covariance)
                                                    (* time-step/ms
				                        velocity-variance)))
			                      position-update-uncertainty))
	      (predicted-cross-covariance ::float
	                                  (+ cross-covariance
                                             (* time-step/ms
                                                velocity-variance)
					     cross-update-uncertainty))
	      (predicted-velocity-variance ::float
	                                   (+ velocity-variance
					      velocity-update-uncertainty))
	      (correction ::float
	                  (/ (+ predicted-position-variance
	                        position-measurement-uncertainty)))
              (position-gain ::float (* predicted-position-variance
	                                correction))
	      (1-position-gain ::float (- 1.0 position-gain))
	      (covariance-gain ::float (* predicted-cross-covariance
	                                  correction)))
          (set! velocity-estimate
	        (+ velocity-estimate (* covariance-gain
		                        prediction-error)))
	  (set! position-estimate
	        (+ predicted-position (* position-gain
		                         prediction-error)))
	  (set! position-variance
	        (* 1-position-gain predicted-position-variance))

          (set! cross-covariance
                (* 1-position-gain
		   predicted-cross-covariance))

          (set! velocity-variance
	        (- predicted-velocity-variance
		   (* covariance-gain predicted-cross-covariance)))))))

					  
  (define (current-velocity)::float
    velocity-estimate)
  
  (define (reset!)::void
    (set! position-estimate +nan.0)
    (set! velocity-estimate +nan.0))



ChatGPT dal nam taka dekompozycje svd:

Dana macierz A = [[a b], [c d]]

Oblicz macierz AA^T:
AA^T = [[a^2 + b^2, ac + bd], [ac + bd, c^2 + d^2]]

Oblicz wartoci osobliwe (pierwiastki kwadratowe z eigenwartoci macierzy A*A^T):
1 = sqrt(a^2 + b^2 + c^2 + d^2)
2 = 0 (bo to jest macierz 2x2)

Oblicz pierwszy wektor osobliwy (kolumna macierzy V):
v1 = [a/sqrt(a^2 + b^2), c/sqrt(a^2 + b^2)]

Oblicz drugi wektor osobliwy (kolumna macierzy U):
u1 = [b/sqrt(a^2 + b^2), -d/sqrt(a^2 + b^2)]

Skonstruuj macierze U,  i V:
U = [u1]
 = [[1, 0], [0, 2]]
V = [v1]

* 14.08.2023

mamy na jutro poprawki do scommitowania. poza tym
implementujemy sledzenie predkosci, i uznalismy, ze
moze warto by bylo zrobic to przy pomocy filtru Kalmana

tymczasem niezaleznie od wyniku chcielibysmy zrobic
scalanie ze soba paneli

i to w dwoch sytuacjach: albo wtedy, kiedy jeden
z obszarow jest zbyt maly (powiedzmy, nie wiekszy niz
3*line-size), albo kiedy predkosc przy podnoszeniu
palca jest dostatecznie duza

w starym prototypie mielismy metode finishResizing,
ktora byla wywolywana z kontekstu przypisania, ale poniewaz
teraz nie operujemy bezposrednio na splitach, a na listach
indeksow, to bedziemy mogli dropa zaimplementowac inaczej
- a tak konkretnoe to mniej wiecej tak:

(define (drop! x y vx vy)
 ` (and-let* ((target ::Split (split-ref screen:top split-path))
             (first-size line-size last-size
	                 (target:sizes)))
    (cond
     ((is first-size <= (* 3 line-size)) ;>
      (merge-split! at: split-path with: SplitFocus:Last
                    in: screen:top))
     ((is last-size <= (* 3 line-size)) ;>
      (merge-split! at: split-path with: SplitFocus:First
                    in: screen:top)))))
* 13.08.2023

moze bysmy sie zajeli sledzeniem predkosci w event processorze

i od razu kilka uwag:

pierwsza jest taka, ze byc moze chcielibysmy
sobie reprezentowac punkty pomiarowe za pomoca
tablicy pamietajacej wskazania historyczne
z ostatnich 60-100 milisekund

natomiast inny pomysl jest taki, zeby uzyc
filtru Kalmana, gdzie nasz wektor stanu
ma postac

X = [x y vx vy]^T

* 11.08.2023

no i mamy SplitBelow gotowe (mniej wiecej)

tylko teraz tak:
- wydaje sie ze mamy jakiegos buga przy
  resize'owaniu zagniezdzonych splitow
- i chyba tez nie wszystko jest do konca teges
  jezeli idzie o zmiane orienracji na androidzie

pezyjmijmy (V a b) = (SplitBeside first: a last: b)
(H a b) = (SplitBelow first: a last: b)

i wowczas mamy

p = (V (H (V 1 (V 4 5)) 3) 2)

i teraz wezmy (pane-ref p '(Z A A))

to tak:

(pane-ref P '(A))

(H (V 1 (V 4 5)) 3)


* 10.08.2023

dzis/jutro bysmy sprobowali zrobic SplitBelow

ale w tym celu trzeba elegancko wyodrebnic Split
ze SplitBeside

* 09.08.2023

mamy troche jakby dzialajaca zmiane rozmiaru splita.
co dalej?
- refactor SplitBeside tak zeby latwiej zrobic SplitBelow
- implementacja SplitBelow
- sledzenie predkosci w touch event procesorze
- laczenie splitow
- naprawa resize/screen position
- osobne podzialy dla orientacji poziomej i pionowej
  (jak to sie uda do konca sierpnia to bedzie ekstra)
  
* 08.08.2023

jest kilka aspektow
po pierwsze, nie wiemy jaka jest 'sciezka' wiodaca do biezacego
splitu. Nalezaloby to rozwiazac w taki sposob, ze tworzymy
sobie parametr the-split-path, ktory obslugujemy wewnatrz
'propagate' w taki sposob, ze reconsujemy okreslony focus

(define (cursor-ref #!optional
		    (tile (the-document))
		    (cursor::Cursor (the-cursor)))
  (match cursor
    ('()
     tile)
    (`(,head . ,tail)
     (let ((parent (cursor-ref tile tail)))
       (part-at head parent)))
    (_
     (error "Unable to refer to cursor "cursor
	    " in "tile))))

analogicznie bysmy mieli

(define/kw (screen-area at: path := (the-split-path)
                        from: pane::Embeddable := screen
                        into: area::Area
                        := (Area left: 0 top: 0
                                 width: screen:extent:width
                                 height: screen:extent:height))
  ::Area
  (match path
    ('()
     area)
    (`(,head . ,tail)
     (match pane
      ((SplitBeside left: left right: right)

)))))

moze opiszmy sobie jak powinien wygladac ten proces.

iterujemy zaczynajac od ekranu

tak naprawde najlepiej by bylo miec cos w rodzaju cursor-ref,
tyle ze chcemy robic dwie rzeczy na raz: po pierwsze, poruszac
sie po 'drzewie' podzialow, a po drugie, sledzic polozenia
i rozmiary biezacego podzialu

(define (pane-ref top::Embeddable path::list)::Embeddable
  (match path
    ('()
     (top:final))
    (`(,h . ,t)
     (let ((parent (pane-ref top tail)))
       (match pane
         ((SplitBeside left: left right: right)
	  (match head
	    (,SplitBesideFocus:Left (left:final))
	    (,SplitBesideFocus:Right (right:final))))
	 ((SplitBelow top: top bottom: bottom)
	  (match head
	    (,SplitBelowFocus:Top (top:final))
	    (,SplitBelowFocus:Bottom (bottom:final)))))))))

no dobra, wydaje sie ze to mamy. A teraz bysmy chcieli
dodac do tego wartosci polozen i rozmiarow

(define (screen-area split-path::list pane::Embeddable := screen:top)
  ::(Values Embeddable real real real real)
  (match split-path
    ('()
     (values (pane:final)
             0 0 screen:extent:width screen:extent:height))
    (`(,h . ,t)
     (let-values (((parent x y w h) (screen-area top tail)))
       (match pane
         ((SplitBeside left: left right: right at: at)
	  (let* ((painter ::Painter (the-painter))
	         (line-width ::real (painter:vertical-split-width))
                 (inner-width ::real (- w line-width))
                 (left-width ::real (as int (round (* at inner-width))))
                 (right-width ::real (- inner-width left-width)))
	    (match head
	      (,SplitBesideFocus:Left
	       (values (left:final) x y left-width h))
	      (,SplitBesideFocus:Right
	       (values (right:final) (+ x left-width line-width) y
	                             right-width h)))))
	 ((SplitBelow top: top bottom: bottom)
	  (match head
	    (,SplitBelowFocus:Top
	     (values (top:final) x y w ...))
	    (,SplitBelowFocus:Bottom
	     (values (bottom:final) x ... w ...)))))))))


* 07.08.2023

jako sie rzeklo, robimy tak, zeby Editor byl Cloneable.

no to to juz mamy

teraz chcemy miec gruba czarna kreche

ona tez jest

wiec moze sprobujmy ja teraz resize'owac

bedziemy musieli zaimplementowac takie cos

(define-object (ResizeSplitBeside target::SplitBeside)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    ...)

  (define (drop! x::real y::real vx::real vy::real)::void
    ...))

co jednak rodzi pytanie: na jaka wartosc powinnismy
ustawic 'at'?

co wiemy: ze x i y sa we wspolrzednych ekranu

zalozmy, ze px i py to wspolrzedne ekranowe rodzica
nadzego SplitBeside'a, natomiast pw i ph to jego rozmiar.
wowczas at musi wynosic (x - px)/pw

no dobra, ale teraz skad wziac wspolrzedne rodzica?

* 06.08.2023

dzis bysmy sprobowali zaimplementowac te wczorajsze
kopiowania tak, zeby sie dalo kopiowac propertisy

a jutro bysmy uczynili Editor instancja Cloneable,
i ewentualnie sprobowali rysowac czarna kreche
(i do tego moze jeszcze robienie Drag jak sie zrobi
press! na SplitBeside)

no i pamietajmy, zeby zamiast screen-position
sledzic sobie document-position

moze w tym tygodniu sie uda mnuej wiecej te splity
obsluzyc, to w kolejnym bysmy sprobowali dodac
sledzenie predkosci do touch-event-processora


* 05.08.2023

na pewno chcemy, zeby:

- Editor zostal Cloneable
- dalo sie klonowac 'propertiesy'

trzeba tez sie zastanowic, bo jezeli ten sam dokument
mozna otworzyc w wiecej niz jednym edytorze, to
(screen-position expression) staje sie wieloznaczne
- i zamiast niego raczej chcielibysmy uzywac
(document-position expression), ktore z kolei bysmy
mogli wzglednie latwo sobie konwertowac do
polozenia wewnatrz edytora.

(define-syntax property
  (syntax-rules (::)
    ((property (object::key-type)::value-type default)
     (let* ((table (($bracket-apply$ make-weak-key-hash-table
				     key-type value-type)))
            (getter (lambda (object::key-type)
                      (hash-ref table object
				(lambda () default)))))
       (set! (setter getter)
	 (lambda (arg::key-type value::value-type)
           (hash-set! table arg value)))
       (set-procedure-property! getter 'table table)
       getter))))


(define-syntax property
  (syntax-rules (::)
  ((property (object::key-type)::value-type default)
     (let ((table (($bracket-apply$ make-weak-key-hash-table
				    key-type value-type))))
       (define (create table)
         (let ((getter (lambda (object::key-type)
                         (hash-ref table object
		            (lambda () default)))))
            (set! (setter getter)
	      (lambda (arg::key-type value::value-type)
                (hash-set! table arg value)))
	    (set-procedure-property! getter 'table table)
	    (set-procedure-property! getter 'clone
	      (lambda ()
	        (create (table:clone))))
	    getter))

       (create table)))))

* 04.08.2023

na razie mamy wydmuszki metod. dzis/jutro bysmy zrobili tak:

- zaimplementowali dobry detektor w Editor (mozemy troche
  zmienic interfejs)

- dobrze zaimplementowali detektor w SplitBeside

i wowczas moze juz dzis udaloby sie miec ekran dzielony
w pionie

no ale dopsz, chcielibysmy zrefaktoryzowac SplitBeside
na modle - czego? propagatora w ColumnGrid w (button)


* 03.08.2023

dzis chcemy zaimplementowac metody

  (can-split-beside? line::Area)::boolean
  (split-beside! line::Area)::Embeddable
  
  (can-split-below? line::Area)::boolean
  (split-below! line::Area)::Embeddable


* 02.08.2023

trzeba by dodac do paintera parametr, line-simplification-resolution,
ktory moze dla klienta terminalowrgo wynosilby 3, dla desktopu
10, a dla androida 20.

No dobra, jest, i co dalej?

mozemy zaczac od tego zeby wyswietlac nazwe rozpoznanej rzeczy
do loga

(define-cache (f x y) ?)

(define-early-constant f
  (let ((cached (cache (x) (cache y) ?)))
    (lambda/kw (x y) ((cached x) y))))

problem mamy taki, ze chcielibysmy jakos
zinwalidowac ten kesz

czyli bysmy to jakos tak zrobili, ze by to wygladalo tak:

(define-early-constant f
  (let* ((cached (cache (x) (cache y) ?))
         (invoker (lambda/kw (x y) ((cached x) y))))
    (set-procedure-property! invoker 'cache cached)
    invoker))

(define (invalidate! cache . point)
  (let ((table (procedute-property cache 'table)))
    (match point
      ('() (table:clear))
      (`(,head . ,tail)
       (apply invalidate! (cache head) tail)
       (table:remove head)))))

(define (invalidate-cache! invoker . point)
  (apply invalidate! (procedure-property invoker 'cache) point))

ok, jakos to wyglada. Wykrywanie linii poziomej tez wydaje
sie dzialac.

to teraz zerknijmy sobie jak to bylo robione kiedys
(no bo przeciez 'kiedys to bylo')


mielismy metody w panelu:
canBeSplittedVertically(rect)
splitVerticallyBy(rect)

i teraz zrobimy to dokladnie tak samo!

tylko zdefiniujemy sobie

(define-type (Area left: real top: real
                   right: real bottom: real))

i znajdzmy sposob wyliczania

(define (area points::(sequence-of Position))::Area
  (let* ((result ::Area (Area left: +inf.0 top: +inf.0
                              right: -inf.0 bottom: -inf.0)))
    (for p::Position in points
      (set! result:left (min result:left p:left))
      (set! result:top (min result:top p:top))
      (set! result:right (max result:right p:left))
      (set! result:bottom (max result:right p:left)))
    result))

(pane:can-be-splitted-vertically-by? (area points))

(set! pane (pane:split-vertically-by! (area points)))

* 01.08.2023

(define (simplify points::java.util.List epsilon::real)
  ::java.util.List
  (let* ((n ::int (length points))
         (n-1 ::int (- n 1)))
    (if (is n <= 2) ;>
        (let ((result ::java.util.List (java.util.ArrayList)))
	  (result:addAll points)
	  result)
	(let* ((first ::Position (points 0))
	       (last ::Position (points n-1))
	       (interior (points:subList 1 n-1))
	       (distance-to ::(maps (Position) to: real)
	                    (distance-to-line-through first last))
	       (furthest-distance ::real (distance-to (interior 0)))
	       (index ::int 0))
	  (for i::int from 1 below (length interior)
	    (let* ((element ::Point (interior i))
	           (distance ::real (distance-to element))) ;<
               (when (is distance > furthest-distance)
	         (set! index i)
		 (set! furthest-distance distance)))) ;<
	    (if (is distance > epsilon)
	      (let* ((left (points:subList 0 (+ index 1)))
	             (right (points:subList index n))
		     (left* (simplify-stroke left epsilon))
		     (right* (simplify-stroke right epsilon)))
                (left*:addAll right*)
		left*)
	      (java.util.ArrayList first last))))))

no dobra, mamy chyba dzialajacy RDP. Jutro bysmy sprobowali
dodac dzielenie ekranu.
	      
* 31.07.2023

Oto RDP ktoregosmy napisali 2 lata temu dla zabawy
w (grand scheme):

(define ((perpendicular-distance [x1 y1] [x2 y2]) [x y])
  (let ((dx (- x2 x1))
        (dy (- y2 y1)))
    (/ (abs (+ (* dy x) (* -1 dx y) (* x2 y1) (* -1 y2 x1)))
       (sqrt (+ (* dx dx) (* dy dy))))))

(define (Ramer-Douglas-Peucker points epsilon)
  (if (is (length points) <= 2)
      points
      (let* (([first middle ... last] points)
             (furthest distance index-1
		       (apply argmax
                              (perpendicular-distance first last)
                              middle))
             (index (+ index-1 1)))
        (if (is distance > epsilon)
            (let* ((left right (split-at points (+ index 1)))
                   ([_ ... pivot] left)
                   (left* (Ramer-Douglas-Peucker left epsilon))
                   ([pivot . right*] (Ramer-Douglas-Peucker
				      `(,pivot . ,right) epsilon)))
              `(,@left* ,@right*))
            `(,first ,last)))))

(e.g. ;; cf. https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification
 (Ramer-Douglas-Peucker
 '((0 0) (1 0.1) (2 -0.1) (3 5) (4 6)
    (5 7) (6 8.1) (7    9) (8 9) (9 9))
  1.0) ===> ((0 0) (2 -0.1) (3 5) (7 9) (9 9)))

I mamy kilka uwag. Przede wszystkim okreslenie
'perpendicular-distance' mowi niewiele, podczas gdy
tak naprawde chodzi o odleglosc pomiedzy prosta wyznaczana
przez punkty [x1 y1], [x2 y2].

Czyli de facto interesuje nas

(define-type (Line direction: Position
                   displacement: real))

odleglosc punktu od plaszczyzny mozna wyznaczyc w taki sposob, ze:

1. wyznaczamy rzut wektora na te linie (z iloczynu skalarnego)
2. odejmujemy ten rzut od wektora
3. liczymy dlugosc wektora, ktory nam pozostal

(define (distance-to-line-through p1::Position p2::Position)
  ::(maps (Position) to: real)
  (let* ((dx ::real (- p2:left p1:left))
         (dy ::real (- p2:top p1:top))
         (1/d ::real (/ (hypotenuse dx dy)))
	 (cross ::real (- (* p1:left p2:top)
	                  (* p2:left p1:top))))
     (lambda (p::Position)::real
       (* (- (* dy p:left) (* dx p:top) cross) 1/d))))

* 30.07.2023

mamy juz nowy modul recognizera,
kolejnym krokiem bedzie [chyba] napisanie algorytmu
RDP w taki sposob, zeby dzialal na ArrayListach
[albo moze nawet na dowolnych Listach]

* 27.07.2023

plan na dzis:
- dodac oznaczanie pozycji kursora przy renderowaniu
  nawiasow w graficznych klientach
- do klienta androidowego dodac uwzglednienie
  rozmiaru klawiatury przy wyliczaniu rozmiaru ekranu
- zaczac przygotowania do implementacji podzialow ekranu


* 26.07.2023

wiemy juz, ze:
- cursor-position zwraca polozenie kursora we wspolrzednych
  ekranowych
- potrzebujemy mechanizmu do wyznaczenia wspolrzednych
  i rozmiaru edytora, zeby zmapowac polozenie kursora
  na wspolrzedne edytora
- stad mozemy latwo zmapowac polozenie kursora
  na wspolrzedne dokumentu

  ;<
  (define (screen->document xs::real ys::real)::(Values real real)
    (let-values (((xe ye) (screen->editor xs ys))
      (editor->document xe ye))

no i teraz wszystko jest pieknie (bo nie mamy optymalizacji
i "rysujemy" nawet rzeczy poza ekranem), ale co kiedy bedziemy
chcieli zrobic optymalizacje?

wowczas bysmy dodali metode cursor-marked? do interfejsu
Painter, i bysmy rysowali tak dlugo, az 'cursor-marked'
byloby oznaczone (to jednak wymaga tez wywolywania 'mark-cursor'
podczas renderowania nawiasow w klientach graficznych)

ewentualnie bysmy dodali nowa metode 'find-cursor'.
Albo po prostu bysmy uzyli screen-position, zeby dobrac sie
do rodzica, i pozniej bysmy wywolali jakas mwtode na spacji,
ktora by nam pozwolila wyznaczyc pozycje kursora (czy cos)

cos na pewno wymyslimy.

ok, czyli dzisiaj zasadniczo chcielibysmy stworzyc mechanizm,
ktory pozwolilby nam na okreslanie wspolrzednych ekranowych
edytora, czyli rzeczone

(the-pane-left)
(the-pane-top)
(the-pane-width)
(the-pane-height)

czy to ma sens?

czy moze zamiast tego powinnismy zapamietywac
(screen-position editor)?

oczywiscie mozna by tak robic, ale wtedy co z rozmiarem?



* 25.07.2023 (komputer)

Musimy przemyslec to i owo. Rozwazmy definicje z telefonu:

(define (adjust-view!)
  (let ((painter ::Painter (the-painter))
        (editor ::Editor (the-editor)))
    (unless (cursor-visible?)
       (painter:play!
          (Transition of: editor:transform
                      from: (copy editor:transform)
                      to: #| takie przesuniecie zeby kursor byl na srodku |#
                      duration/ms: 500)))))

I teraz tak: w Painterze jest metoda "mark-cursor!" oraz
(cursor-position), przy czym pojawia sie takie pytanie, w jakim
ukladzie wspolrzednych wyrazone sa te wartosci?

Otoz: mark-cursor! pobiera wartosci wzgledem biezacego przesuniecia,
natomiast cursor-position wyraza pozycje kursora na ekranie.

I od razu mamy kilka uwag, zwiazanych z tym, jak rzecz mozemy w ogole
zaimplementowac, tzn. jak zintegowac te kwestie z pojeciem edytora.

Poza tym - niby to przy okazji - w gre wchodzi jeszcze taka kwestia,
ze w kliencie terminalowym powinnismy oznaczac tylko kursor w aktywnym
edytorze (co moze nie byc problemem dopoki mamy tylko jeden edytor)

No ale dobra, pytanie numer 1: skad mozemy wiedziec, jaka pozycje ma kursor
wewnatrz dokumentu?

Bo jezeli wiemy to, to za pomoca transforma mozemy tez okreslic, jaka
jest jego pozycja w edytorze. Natomiast kiedy mamy rowniez i to, to
teoretycznie z pomoca (the-pane-extent) powinnismy byc w stanie okreslic,
czy wspolrzedna kursora jest poza ekranem

No to teraz wyobrazmy sobie, ze mamy do dyspozycji nastepujace parametry:

(the-editor-left)
(the-editor-top)
(the-editor-width)
(the-editor-height)

przechowujace wspolrzedne ekranowe poszczegolnych edytorow.

Ale jezeli mamy takie cos, to mozemy operowac na wspolrzednych ekranowych

Warto tez przyjrzec sie, gdzie ow "mark-cursor!" jest wywolywany:

w text-painter jest w:
- draw-custom-box!
- draw-quote-markers!
- draw-quasiquote-markers!
- draw-unquote-markers!
- draw-unquote-splicing-markers!
- draw-string!

w spaces:
- Space:draw!

w grasp-android:
- w draw-text!

w grasp-desktop:
- w draw-text!

Mozemy sobie zmapowac wspolrzedne ekranowe na wspolrzedne w edytorze,
a je z kolei na wspolrzedne w dokumencie

* 25.07.2023 (telefon)

mamy jako tako dzialajace animacje, moglibysmy jeszcze
zrobic tak, zeby sie focusowac na danej linii i dopasowywac
skale do szerokosci

no ale dobrze. skupmy sie na sledzeniu kursora. chodzi o to,
ze jezeli kursor wyjedzie poza ekran, to powinnismy
odtworzyc tranzycje, ktora sprawi, ze ow kursor znajdzie sie
w polowie wysokosci ekranu


poniedzialek - system animacji
wtorek - animacje przy podwojnym kliknieciu
sroda - sledzinie kursora
czwartek - rysowanie tla
piatek - dzielenie ekranu


ponadto dobrze byloby, zeby:
- po lewej stronie edytora byl pasek scrollujacy
- podczas scrollowania skala automatycznie by sie
  dopasowywala tak, zeby wszystko miescilo sie
  na szerokosc
- nie dalo sie obracac ekranu

no i swietnie, tylko co teraz?

zdefiniujmy funkcje tak:

(define (adjust-view!)
  (let ((painter ::Painter (the-painter))
        (editor ::Editor (the-editor)))
    (unless (cursor-visible?)
      (painter:play!
        (Transition of: editor:transform
	            from: (copy editor:transform)
		    to: #|takie przesuniecie, zeby kursor
byl na srodku|#
                    duration/ms: 500)))))

no dobra, to jak zdefiniowac cursor-visible?

* 24.07.2023

dzisiaj plan jest taki: chcemy zrobic, ze jak bedzie podwojne
klikniecie i niezerowy kat, to zeby byla dodawana tranzycja
do zerowego kata

od tego w kazdym razie zaczniemy

no dobra, to juz mamy zrobione

AAAA i trzeba jeszcze zrobic tak, zeby edytor pamietal
transformacje dla poszczegolnych dokumentow


* 23.07.2023

chcemy dodac animacje tranzycji do modulu (transform)


* 22.07.2023

dzis/jutro/pojutrze bysmy moze sprobowali zaimplementowac
animacje tranzycji oraz tweening oparty na sinusie,
i zintegrowali to z podwojnym kliknieciem (tak jak
to wczoraj omawialismy)

* 21.07.2023 (urodzinki corenki)

wydaje sie ze juz mamy jakies systemy animacji dla
klienta awt i terminalowego, i pozostaje nam
andtoidowy

stary system animacji byl oparty o zwykle javowe timery
- a one maja taka drobna niedogodnosc, ze nie da sie
ich zatrzymac. poza tym tego postpone'a jakos chyba
zrobilismy bez timerow to moze teraz tez sie uda.

tymczasem trzeba by bylo zajac sie tweeningiem.

i trzeba to moze tak zrobic:
- jezeli kat jest niezerowy, to dodajemy animacje,
ktora go zeruje
- jezeli przesuniecie pozione jest niezerowe albo pionowe
  dodatnie, to zerujemy oba parametry
- jezeli transformacja jest skalowalna i przesuniecie
  w obu kierunkach jest zerowe, a tapnelismy na toplevelowej
  spacji, to skalujemy tak, zeby wysokosc dokumentu
  pokrywala sie z wysokoscia ekranu
- w przeciwnym razie przesuwamy tak, zeby wysokosc klikniecia
  znalazla sie na srodku ekranu, i ewentualnie dobieramy taka
  skale (nie wieksza niz 1) zeby dokument miescil sie
  na szerokosc


* 20.07.2023

tak naprawde dzis glownie sie zajelismy renderowaniem
popupoq w kliencie terminalowym, co wynikalo
z podejrzenia, ze moze cos jest nie tak z tymi
ThreadedPoolExecutorService - okazalo sie jednak,
ze problem bierze sie z pisania poza zakres
w lanternowym buforze

teraz zatem pozostaje nam teraz do zrobienia
implementacja metodd play! we wszystkich nietrywialnych
painterach, przy czym teraz jest pomysl, zeby
uzyc ConcurrentLinkedQueue na interfejsie Collection


* 19.07.2023

tak jak i wczoraj, dzis byloby dobrze zaimplementowac
tranzycje i system animacji, ale zeby tranzycje
mogly dzialac na wszystkich transformacjach (a nie tylko
na Isogonal), trzeba by bylo dodac get-scale, set-scale!,
get-angle, set-angle! get-left, set-left!, get-top,
set-top! do interfejsu Transform.

(define-type (Transition of: Transform
                         from: Transform
			 to: Transform
			 around: Point := #!null
			 duration/ms: int
			 progress/ms: int := 0)
  implementing Animation
  with
  ((advance! timestep/ms::int)::boolean
   (set! progress/ms (+ progress/ms timestep/ms))
   (let ((progress ::float (/ progress/ms duration/ms)))
     (cond
      (around
       (let*-values (((x0 y0) (of:unmap around:x around:y))
                     ((scale) (tween (from:get-scale)
		                     (to:get-scale)
		                     progress))
		     ((angle) (tween (from:get-angle)
		                     (to:get-angle)
		                     progress))
	             ((x1 y1) (begin
		               (of:set-scale! scale)
			       (of:set-angle! angle)
			       (of:unmap around:x around:y))))
         (of:translate! (- x1 x0) (- y1 y0))))
      (else
       (of:set-scale! (tween (from:get-scale) (to:get-scale)
			     progress))
       (of:set-angle! (tween (from:get-angle) (to:get-angle)
			     progress))
       (of:set-left! (tween (from:get-left) (to:get-left)
			    progress))
       (of:set-top! (tween (from:get-top) (to:get-top)
			   progress))
       ))) ;<
    (is progress/ms > duration/ms))

  ((tween initial-value::real final-value::real progress::real)
   ::real
   (cond
     ((is progress <= 0) initial-value)
     ((is progress >= 1) final-value)
     (else
      (+ initial-value
         (* (- final-value initial-value)
	    (sin (* progress pi/2))))))))

(painter:play!
  (Transition of: transform
              from: (copy transform)
	      to: (Isogonal scale: (transform:get-scale)
	                    angle/rad: 0.0
			    left: (transform:get-left)
			    top: (transform:get-top))
	      around: (Point x y)
	      duration/ms: 100))

ok, to teraz jak zaimplementowac funkcje play! w poszczegolnych
klientach?

wydaje sie, ze w kazdym przypadku to bedzie z grubsza to samo.
moze nawet nie bedziemy tego spinac z painterem?
	      
* 18.07.2023

dzis byloby dobrze zeby zaimplementowac:
- tranzycje
- system animacji

na poczatku bysmy sie skupili na kliencie
androidowym, bo aktualnie tylko w nim
dziala obracanie widoku

(define-type (Transition of: Isogonal
                         from: Isogonal
			 to: Isogonal
			 around: Point)
  implementing Animation
  with
  ((advance! timestep/ms::int)::boolean
   ...))

ale wowczas trzeba by bylo wywalic 1/scale
oraz s i c z Isogonal (co pewnie nie robi
wielkiej roznicy)

(painter:play!
  (Transition of: transform
              from: (copy transform)
	      to: (Isogonal scale: transform:scale
	                    angle/rad: transform:angle/rad
			    )
	      around: ...))

(define-interface Animation ()
  (advance! timestep/ms::int)::boolean)

(define-type (Transition of: Isogonal
                         from: Isogonal
			 to: Isogonal
			 around: Point := #!null
			 duration/ms: int
			 progress/ms: int := 0)
  implementing Animation
  with
  ((advance! timestep/ms::int)::boolean
   (set! progress/ms (+ progress/ms timestep/ms))
   (let ((progress ::float (/ progress/ms duration/ms)))
     (cond
      (around
       (let*-values (((x0 y0) (of:unmap around:x around:y))
                     ((scale) (tween from:scale to:scale
		                     progress))
		     ((angle) (tween from:angle/rad
		                     to:angle/rad
		                     progress))
	             ((x1 y1) (begin
		               (set! of:scale scale)
			       (set! of:angle/rad angle)
			       (of:unmap around:x around:y))))
         (of:translate! (- x1 x0) (- y1 y0))))
      (else
       (set! of:scale ...))))))

* 17.07.2023

teoretycznie 'pierwsza rzecz' z czwartkowej listy
juz rozwiazana - i w jakiejs mierze siodma tez.

co do drugiej i czwartej, ich wspolnym mianownikiem
jest system animacji, i to na nim bysmy sie dzis
skupili

konkretnie, w prototypie Javowym mielismy dwie
klasy:
- Animation
- AnimationSystem

pierwsza z nich reprezentuje postep pojedynczej
animacji oraz tweening z funkcja sinus.

druga natomiast posiada Timer - animate - oraz
TimerTask, ktory co 40ms wola na obiekcie android.os.Handler
metode 'post' z callbackiem, ktory - dla wszystkich
animacji - wywoluje metode 'step', a na koncu
robi screen.invalidate()

Ale my wiemy, ze tym razem nie bedzie tak latwo,
bo musimy obsligiwac (co najmniej) 3 srodowiska.

Dodatkowo moze mamy tutaj tez jakas czesc wspolna
z implementacjami Postponed i Cancellable.

W kazdym razie powinnismy wyjsc od najwazniejszego
pytania, mianowicie: jak chcemy z tego korzystac.

Ach, bo tak: bo do tej pory Animation bylo klasa,
po ktorej dziedziczyly inne klasy, a w szczegolnosci
Transition (i tak naprawde chyba tylko ona)

No ale dobra, co bymy chcieli pisa w tym Edytorze?

;; w Editor
  (define (double-tap! finger::byte x::real y::real)::boolean
    (center-around! x y))


no swietnie, zesmy sie, kurwa, wysilili.

ale co ma robic 'center-around!'?

ma dodac nowy 'proces', czy tez nowa animacje,
do listy animacji, i ta animacja ma w kazdym
kroku wywolywac okreslona funkcje.

mozna by powiedziec tak:

(define-interface Animation ()
  (step!)::void
  (target)::Object
  )

no dobra. i teraz co?
czy animacja powinna sie odbywac z innego watku?

no raczej ze tak. z watku timera, odpalanego
co 40 ms, i zatrzymywanego gdy nasza lista jest
pusta.

w kazdym razie bysmy chyba musieli miec

(painter:animate!
  (CenterAround x y (this)))

a jeszcze raz, jak jest w starym prototypie?

jest tak, ze tworzymy obiekt Transition,
a potem wywolujemy na nim
setTargetAngle(0.0)
setTargetScale(1.0)
fixPoint(x, y)
start(duration)

kolejne pytanie by brzmialo: jaka czesc funkcjonalnosci
bedzie sie dawala przenosic pomiedzy klientami,
a jaka bedzie specyficzna?

czyli tak:

do Paintera bysmy dodali

(animate! animation::Animation)::void

oraz

(define-interface Animation ()
  (step! progress::float)::void
  (finished?)::boolean
  )


(define-object (Transition target::Isogonal)::Animation
  ...)

* 14.07.2023

okazuje sie ze z tych wszystkich rzeczy zajalem
sie problemem wstawiania elementow do dokumentu
- problem jest taki, ze w kontekscie drop! parametr
  (the-document) ma zla wartosc

stad tez trzeba bedzie dodac moze

(define-interface Embeddable (Pane Map2D)
  (pane-under x::real y::real)::Embdable
  )

* 13.07.2023

obracanie widokiem juz jako tako dziala (jupi), ale
jeszcze nie calkiem dziala mapowanie elementow
na dokument - i to jest pierwsza rzecz, ktora bysmy
sie zajeli

druga to zerowanie rotacji za pomoca podwojnego
klikniecia (i to bedzie wymagalo dodania mechanizmu
do kontrolowania animacji)

trzecia to rysowanie krawedzi dokumentu,

czwarta to niedopuszczanie do tego, zeby dokument
znalazl sie poza widokiem edytora

piata wreszcie to sprawienie zeby wyjechanie kursorem
poza krawedz widoku powodowalo przesuniecie tego
widoku

szosta, to oprogramowac walek myszki, i jeszcze
zrobic tak, zeby klawiatura dzialaka na windowsie

siodma to zrobic tak, zeby przenoszenie elementow
i zmiana ich rozmiaru z powrotem dobrze dzialaly


No dobra, chyba mamy maly problemix.
Jest sobie funkcja 'screen-position', ktora
podczas rysowania zapamietuje
'painter:current-translation-left' oraz
'painter:current-translation-top'.

A tymczasem my chcielibysmy raczej miec
document-position, czyli pozycje wzgledem dokumentu
- bo ja mozemy sobie wygodnie (za pomoca unmap?)
  przeksztalcic we wspolrzedne edytora

powinnismy tez znalezc jakis sposob, zeby te wspolrzedne
edytora przeksztalcic we wspolrzedne ekranu

* 12.07.2023

z jakichs wxgledow jak zmieniamy "default-transform"
to system nam wybucha :o (na androidzie)

* 10.07.2023

sama transformacja juz jest zaimplementowana.

teraz musimy zrobic jakiegos Draga

(define-object (Translate target::Transform)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    (target:translate! dx dy))

  (define (drop! x::real y::real vx::real vy::real)::void
    (values)))

i dodac go do drag! przy second-pressie.

To juz dziala. Mamy tez lokalne poprawki, zeby prawidlowo
mapowac wspolrzedne wskaznikow na wspolrzedne dokumentu.

Natomiast dalsze kroki, to:
- implementacja Isogonal i podpiecie stretch! do edytora
- rysowanie na szaro dokumentu poza jego
  krawedziami
- wymuszanie, zeby zawsze byla na ekranie widoczna
  jakas czesc dokumentu
- zerowanie rotacji, centrowanie na wyrazeniach itp.
  po dwukrotnym kliknieciu na pustej przestrzeni
  (co bedzie wymagalo dobudowania managera animacji)

i to by chyba byly najblizsze dwa tygodnie,
a po nich sie juz zajmiemy dzieleniem ekranu
i usprawnianiem edycji

No to teraz wrocmy z naszym tym:

;; ... wewnatrz on-press! ...
(cond
  ;; jeszcze bysmy sprawdzili czy nie ma tutaj
  ;; od razu jakiegos stretcha dla biezacego
  ;; edytora
 ((any (lambda (layer::Layer)
         (and-let* (((Stroke source-pane: ,(this)) layer))
	     layer))
           screen:overlay) ;<=
  => (lambda (stroke::Stroke)
       (screen:overlay:remove! stroke)
       (unset! (screen:dragging stroke:finger))
       (let ((p0 (stroke:points 0))
             (p1 (Point xe ye)))
         (set! (screen:dragging stroke:finger)
             (object (Drag)
	       ((move! x::real y::real dx::real dy::real)::void
	        (let ((p1x ::real (+ p1:x dx))
	              (p1y ::real (+ p1:y dy)))
		  (editor:transform:stretch!
		   p0:x p0:y p1:x p1:y
		   p0:x p0:y p1x  p1y)
	          (set! p1:x p1x)
		  (set! p1:y p1y)))
	       ((drop! x::real y::real dx::real dy::real)::void
	        (values))))

         (set! (screen:dragging finger)
             (object (Drag)
	       ((move! x::real y::real dx::real dy::real)::void
	        (let ((p0x ::real (+ p0:x dx))
		      (p0y ::real (+ p0:y dy)))
		  (editor:transform:stretch!
		   p0:x p0:y p1:x p1:y
		   p0x  p0y  p1:x p1:y)
	          (set! p0:x p0x)
		  (set! p0:y p0y)))
	       ((drop! x::real y::real dx::real dy::real)::void
	        (values)))))))
  ...)

teraz teoretycznie pozostaja nam dwie rzeczy:
- wkleic to
- zaimplementowac stretch!

a po tym bysmy sprobowali rysowac krawedzie dokumentu?


* 09.07.2023

plan jest taki, zeby:
1. zaczac od transformacji "samego przesuwania",
   Translation
2. klient terminalowy musi miec osobna implementacje
   transformacji (bez wsparcia dla obrotu i skalowania)
3. na poczatek wszystkie klienty beda obslugiwaly
   tylko te transformacje
4. ale pozniej dodamy jeszcze stretch do klientow
   nieterminalowych - Isogonal

* 07.07.2023

(define-interface Transform
  (apply! painter::Painter)::void
  (unapply! painter::Painter)::void

  (map x::real y::real)::(Values real real)
  (unmap x::real y::real)::(Values real real)

  (translate! dx::real dy::real)::void

  (stretch! x00::real y00::real x10::real y10::real
            x01::real y01::real x11::real y11::real)
  ::void
  )
  
;; i wowczas renderowanie edytora
;; wygladaloby tak

  (define (draw!)::void
    (parameterize ((the-document document)
		   (the-cursor cursor)
		   (the-selection-anchor selection-anchor))
      (let ((painter ::Painter (the-painter)))
        (transform:apply! painter)
        (document:draw! '())
	(transform:unapply! painter))))

;; no i fajnie, i teraz sobie sprobujmy wyobrazic
_'';; co trzeba zrobic zeby rozciagac widok.
;; przede wszystkim, od strony mechanicznej:

;; ... wewnatrz on-press! ...
(cond
  ;; jeszcze bysmy sprawdzili czy nie ma tutaj
  ;; od razu jakiegos stretcha dla biezacego
  ;; edytora
 ((any (lambda (layer::Layer)
         (and-let* (((Stroke source-pane: ,(this)) layer))
	     layer))
           screen:overlay)
  => (lambda (stroke::Stroke)
       (screen:overlay:remove! stroke)
       (unset! (screen:dragging stroke:finger))
       (set! (screen:dragging stroke:finger)
             
             ...)
       (set! (screen:dragging finger)
             ...)))

* 06.07.2023

jak zwykle zaczelibysmy sobie od analizy rozwiazania
ze starego prototypu.

Mamy tam interfejs Transform z metodami:
x, y, unx, uny, canvas, uncanvas, anchor,
towards.

Do tego wyglada na to, ze mamy dwie implementacje:
Grab oraz Shift, zas same obiekty mozns przekazywac
(za pomoca metod inwards i outwards) do Below,
Drag, DragAround, Point, Popup, Resize, Scroll,
Shift, Split oraz Stretch.

Obiekty Shift sa tworzone w: Below, Beside,
Panel i Popup, i sprawdzane w Resize.

Obiekty Grab sa tworzone w Editor, GRASP i
Resize.

Sprobujemy teraz zrozumiec role tych uzusow.
Jezeli idzie o Below, Beside, Panel i Popup,
mozna sobie wyobrazic, ze chodzi o to, co teraz
rozwiazujemy odejmowaniem.

Natomiast co do Grab, to tutaj oczywiscie
wchodzi w gre obracanie i skalowanie (i przesuwanie)
Edytora. Dlatego tez mamy tam haszmape

documentTransform : Document -> Grab

ktora zapamietuje, w jakiej pozycji w danym edytorze
byl ostatnio edytowany dokument

co do naszej sytuacji, to nie bedziemy robic Shiftow.
Natomiast nasxa transformacja winna sie nazywac
IsogonalTransform albo ConformalTransform

(define-type
  (Isogonal scale: real
            shift-left: real
	    shift-top: real
	    rotation: real))
	    
przy czym jest pare spraw, ktore bysmy chcieli ogarnac:

1. renderowanie klienta androidowego
2. renderowanie klienta desktopowego
3. renderowanie klienta terminalowego (tylko translacja)
4. mapowanie klikniec od edytora do dokumentu
5. scrollowanie - czyli zmiany przesuniecia
6. scrollowanie, zoomowanie i obracanie
7. do tego chcielibysmy tez zaimplementowac
   rolke myszki do scrollowania ekranu, ale takze
   do scrollowania scrolli
8. oraz sprawic, zeby wyjechanie kursorem poza
   ekran powodowalo odpowiednie przewiniecie ekranu
9. dodatkowo chcemy to, co sie znajduje poza granicami
   dokumentu renderowac na szaro


zaczelibysmy od tego, zeby podwojne klikniecie
na dokument powodowalo scrollowanie ekranu,
tzn. stworzenie obiektu Drag, ktore odpowiednio
by modyfikowalo wartosci przesuniecia w edytorze

(define-object (Editor)
  (define (second-press! finger::byte #;at x::real y::real)
    ::boolean
    (parameterize/update-sources ((the-document document)
				  (the-cursor cursor)
				  (the-selection-anchor
				   selection-anchor))
      (let-values (((selection-start selection-end)
		    (the-selection)))
    
        (and-let* ((path (cursor-at x y))
                   (`(,tip . ,subpath) path)
	           (parent ::Element (the-expression
		                      at: subpath))
	           (target ::Element (parent:part-at tip)))
          (cond
	    ((is target Space?)
             (screen:drag! finger
	                   (ScrollEditor (this))))

	    ((is target Tile?)
	     ;; tworzymy kopie elementu
	     ;; co zasadniczo powinno stworzyc operacje,
	     ;; ktora przy dodaniu elementu do dokumentu
	     ;; dodaje do historii
	     ;; (CopyElement at: source into: destination)
	     )
	     
(define-object (ScrollEditor editor::Editor)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    (editor:transform:translate! dx dy))
  (define (drop! x::real y::real vx::real vy::real)::void
   (values)))



   
* 05.07.2023

teraz tak: metody initialize nie ma. zamiast niej
jest globalna hszamapa, co wydaje sie lepszym
rozwiazaniem.

natomiast teraz bysmy sie zajeli scrollowaniem, przy czym
w kluencie terminalowym nie bedzie obslugi zoom ani rotate.

* 04.07.2023

paln na dzisiaj to doprowadzenie do edytowalnosci
tego pola tekstowego

co tam sie nam w nocy przysnilo:
zeby dodac do Layer metode "initialize"
wolana w momencie gdy juz stworzymy kursor
dla danej warstwy

no ale dobrze, kiedy juz to zrobimy, to co
wtedy bedzie?

to bysmy sie zajeli zrobieniem przelaczania
dokumentow

a kiedy to juz bedzie, to sie z kolei zajmiemy
scrollowaniem itp., przy czym tym razem bysmy
sprobowali zachowac pewne wiezy

a jak bedzie scrollowanie, zrobimy podzial
ekranu

a po nim zajmiemy sie poprawkami w edycji
i ewaluacja

i ewaluatorem wizualnym

i wizualizacja grafow


* 03.07.2023

dzis bysmy:
1. sprobowali doprowadzic do dzialania
   save-file-browser
2. jak sie uda, dodali okienko wyboru dokumentow

ad 1: musimy:
- zmniejszyc guzik
- dorobic tlo do pola tekstowego
- dobrze obsluzyc klawiature w popupie/polu tekstowym

  to bysmy zaczeli od tego, zeby dodac do paintera
  fill-background
  
* 02.07.2023

teraz bysmy zrobili text-input, co by wygladalo tak
mniej wiecej, ze oprocz Text, ktory mamy teraz, bysmy
zrobili jeszcze dziedziczaca po nim klase text-input,
ktora po prostu by uzywala innej czcionki


* 01.07.2023

teraz stoimy przed takim problemem, ze nie wiemy,
jakiej czcionki uzyc do tekstu

pomysl jest taki, ze:
- jako caption font uzyjemy tej czcionki, ktora
  mielismy w javowym prototypie
- i jako czcionki pola tekstowego rowniez
  uzyjemy odpiwiedniej czcionki, ktora nazwiemy
  text-input-font
- do paintera dojdzie draw-input-text! i input-text-extent

  ok, to tak: input-text uzywa stings_font, czyli
  NotoSerif-Regular
  guziki uzywaja menu_font, czyli Basic-Regular


* 30.06.2023

dzis niby ma byc notyfokacja hapoc, wiec jezeli
sie uda, to bym w niedziele dodal pejper do repo

poza tym trzeba wcommitowac te 8pix do repo

no a poza tym, to sie trzeba zajac tym polem tekstowym.

I teraz moze taka uwaga ogolna: pole tekstowe bedzie
mialo stala wysokosc, natomiast jego szerokosc bedzie
zmienna, i bedziemy ja ograniczac

ewentualnie mozemy zrobic tak, ze scroll przed rysowaniem
koloruje tlo? wowczas jednak nie daloby sie uzywac TextInputa
(czy moze TextFielda) spoza Scrolla.

Ewentualnie mozemy po prostu osadzic nieudekorowany tekst
w scrollbarze (nieudekorowany tj bez cudzyslowiow) i nazwac
to dniem.

* 29.06.2023

sprobujmy moze przypomniec sobie dlaczego chcemy, zeby
Pane bylo Indexable? (bo chyba byloby lepiej, gdyby
jednak nie bylo)

Zasadniczo idzie o to, ze jak mamy sobie te warstwy,
to chcemy na nich wywolac cursor-climb-up. I tylko tyle.

Ale moze powinnismy raczej zrobic

(define-interface Layer (Indexable Pane))

i sprawic, zeby PopUp bylo  Layer (co jest o tyle
latwe, ze juz nim de facto jest)

ale wtedy potrzebujemy innej nazwy na to co
teraz nazywa sie Layer. A moze nie?

Kod sie juz kompiluje i jest scommitowany.

Teraz bysmy chcieli:
- dodac obsluge pola tekstowego
- dodac obsluge nawigacji strzalkami
  (w szczegolnosci pole "scroll" powinno sie
  doscrollowywac tak, zeby zfocusowany element
  byl widoczny)


* 28.06.2023

no dobra, to plan jest taki:
1. dodajemy parametr "context" do key-typed
2. dodajemy Pane do Indexable
3. do 'overlay' dodajemy 'cursor', ktorym
   bedziemy parametryzowac (the-cursor)
4. dodajac nowego pane'a do overlaya,
   wywolujemy na nim "cursor-climb-front"

sprawdzamy, czy takie cos zadziala :D

Pane jeszcze nie jest 'indexable'.
Poki co, trzeba zrobic tak, zeby Overlay nie trzymalo
"Pane", tylko pare (Pane, cursor)

(define-type (Layer content: Pane cursor: Cursor))

wowczas bysmy robili tak, ze overlay:add!
by robil (cursor-climb-front content '())
jako pozycje poczatkowa kursora.

I wowczas te nieparzyste indeksy tak naprawde nie mialyby
znaczenia.

Ok, ale po drodze sie pojawil taki problem:
- co jezeli bedziemy mieli nielokalne wyjscie
  z parameterize/update-sources ?

Kawa definiuje np. dynamic-wind o tak:

(define (dynamic-wind before thunk after)
  (before)
  (try-finally
   (thunk)
   (after)))

zrobilismy fixa i to co teraz mamy byc moze dziala,
ale nie ma jak tego przetestowac, dlatego sobie sklonujemty druga
kopie repo i wytestujemy poprawke

no dobra, to chyba niczego nie psuje (albo testy okazaly sie
na owo zepsucie niewrazliwe - ale czy to aby mozliwe?)

to wracamy do naszego glownego tematu, czyli
sprawienia, zeby Pane bylo Indexable.
   

* 27.06.2023

dzis sie zajmiemy tym, zeby combinatorsy byly
zaczarowane

ok, to powinno dzialac - pomijajac kwestie
obslugi klawiatury

co do klawiatury, plan moglby byc taki, zeby:
- dodac kontekst do funkcji key-typed
- przeslaniac (the-cursor) przy obsludze
  overlay

To to by tak wygladalo, ze:
- z HorizontalSplit usuwamy focus
- dodajemy HorizontalSplit do Indexable
- czy ogolniej dodajemy Pane do Indexable?
- uzywamy "cursor-climb-front" do inicjalizacji kursora

* 26.06.2023

dzis dla idmiany bysmy sie skupili na zapisywaniu
plikow

widok by tak wygladal mniej wiecej:

(Below
 top:
 (Beside left: (text-field) right: (button))
 bottom:
 (file-list))

a konkretniej moze tak:
#+BEGIN_SRC

(define (save-file-browser directory::string
                           name-hint::string
			   editor::Editor)
  ::PopUp
  (let* ((window ::PopUp #!null)
         (text-field ::Scroll (text-field 0 name-hint))
         (button (Button label: "Save"
	                 action: (lambda _
			           (screen:clear-overlay!)
				   (save-document!
				     (java.io.File
				      directory
				      text-field:content)))))
	 (files (file-list directory
	                   (lambda (file::java.io.File)::void
			     (set! text-field:content
			       (text-input (file:toString))))
			   (lambda (dir::java.io.File)::void
                             (screen:remove-overlay! window)
                             (screen:overlay!
                              (save-file-browser directory
			                         text-field:content
                                                 editor)))))
	 (button-size ::Extent (button:extent))
	 (file-list-size ::Extent (files:extent))
	 (content (Below top: (Beside left: text-field right: button)
                         bottom: files)))
     (set! text-field:width (- file-list:width button:width))
     (set! window (popup content))
     window))
#+END_SRC

ok

czyli ogolniej: w tym tygodniu bysmy chcieli zrobic zapisywanie
plikow, co wymaga:
- uczynienia combinatorsow "Enchanted"
- zaimplementowania TextField
- ewentualnie drobnych refaktoryzacji po stronie file-list,
  tak zeby miec slowa kluczowe w argumentach i obsluge
  podwojnego klikniecia

natomiast juz nas troche swedzi, zeby zrobic jakas narracje
na SplashCon, w tym:

if we look at the top 20 languages on the TIOBE index,
we'll notice, that most of them share a common trait,
and the one which doesn't share this trate isn't considered
a 'real' (or 'professional') programming language

;; concrete data
;; pattern matching
;; (and possibly other textual notations)
;; abstract definitions

- emacs i lisp
- pliki tekstowe vs s-wyrazenia


plan developerski jest z grubsza taki:
jutro(wtorek): zrobic zeby kombinatory byly zaczarowane

pojutrze(sroda): zaimplementowac pole tekstowe

popojutrze(czwartek): zaimplementowac zapisywanie plikow

piatek: ewentualne refaktoryzacje, zapis podwojnym kliknieciem,
elastyczny mechanizm ladowania pliku init.scm tak zeby dzialal
rowniez z pliku .jar

no i przelaczanie dokumentow!

i tak w kolejnym tygodniu bysmy:
- zaczeli robic zgloszenie na splash
- przesuwanie widoku edytora
- zoomowanie widoku edytora
- i ewentualnie obracanie

a nastepnie: dzielenie ekranu

a nastepnie? ewaluacje wyrazen?

a nastepnie: pomiar predkosci ruchu palcem

a nastepnie: naprawic bledy w edycji

a nastepnue: zaczac edytowac GRASP w GRASP
oraz rozpoczac implementacje ewaluacji wizualnej


* 25.06.2023

plan jest taki, zeby:
- dodac sprawne ladowanie pliku do modulu (document)
- uzyc tej funkcji do ladowania "assets/init.scm"

i jezeli to bedziemy mieli, to sie zajmiemy scrollowaniem,
zoomowaniem i obracaniem dokumentu
(a pozniej dzieleniem ekranu i taka zmiana reprezntacji,
zeby "a::b" bylo interpretowane jako 3 tokeny podczas
ewaluacji)


* 24.06.2023

teraz chcielibysmy miec funkcje ktora laduje nam dokument
z pliku. Czyli cos w rodzaju:

#+BEGIN_SRC
(define (open-document file::java.io.File)
(call-with-input-file file ; ew. (file:getAbsolutePath)
    (let-values (((result spaces) (read-list)))
      (Document (if (empty? result)
	          (EmptyListProxy spaces)
		  result)
		file))))
#+END_SRC

* 23.06.2023

to na razie plan jest taki, zeby dodac nowy modul,
(document), w ktorym bedzie zdefiniowany typ Document,
a w kolejnym kroku bysmy sprobowali podmienic wszystkie
wystapienia document::pair na document::Document

mozemy zrobic tak:
- (parse) bedzie inkludowal (document)

czy moze na odwrot?

- draw-document! przenosimy z (primitive) do (document)

najwiecej document::pair jest w (history), ale moze
lepiej tak zostawic

* 22.06.2023

na razie nie ma pomyslu na to w jaki sposob pozycjonowac
okna - w starym prototypie mielismy zmienne globalne;
w nowym moglibysmy chciec miec parametry

pointer-left/screen, pointer-top/screen, pointer-index,
pointer-left/pane, pointer-top/pane
pointer-left/parent, pointer-top/parent

albo cos takiego.

ale na razie to olewamy, i jezeli kiedys sie pojawi
taka potrzeba w innym kontekscie, to sie nia zajmiemy

a tymczasem chcemy sie skupic na ladowaniu plikow

editor:load-file powinno dzialac tak, ze
powinna byc jakas instancja, ktora nam sledzi
wszystkie otwarte dokumenty, i to ja powinnismy
prosic o dokument - i to ona powinna byc
odpowiedzialna za ewentualne ladowanie
dokumentu, gdyby mialo sie to okazac
konieczne


Otwieranie wyglda tak:

Document document = Document.fromFile(file);
screen.layers.clear();
editor.previousDocument.put(document, editor.document);
editor.switchToDocument(document);

gdzie w klasie Document jest sobie statyczna lista
openedDocuments, natomiast Editor posiada dwie mapy:
previousDocument, ktora wskazuje na dokument, ktory
byl otwarty przed zadanym dokumentem, oraz documentTransform,
ktory przechowuje transformacje dokumentu w edytorze

a jak bysmy to chcieli miec w nowym edytorze?
#+BEGIN_SRC

... Editor ...


(define-type (Document content: ... source: File))

(define-parameter (open-documents)::(list-of Document)
  '())

(define (open-document source::File)::Document
  (or (find (is _:source eq? source) (open-documents))
    (let* ((document ...))
      (set! (open-documents) (cons document (open-documents)))
      document)))

(define-property (previously-edited document::Document)::Document
  (or (and-let* ((`(,_ ,next . ,_) (first-cell (is (car _) eq? document)
                                      (open-documents))))
         next)
      (and-let* ((`(,first . ,_) (open-documents))
                 ((isnt first eq? document)))
	 first)
      document))

(define (open-file file::File)::void
  (let ((opened ::Document (open-document file)))
    (set! (previously-edited opened) document)
    (set! document opened)))
#+END_SRC

* 21.06.2023

Okienko z plikami dziala na Androidzie, ale na desktopowych
klientach sa problemy. Prawdopodobnie jest to zwiazane
z implementacja (initial-directory) w domyslnym Keeperze,
i temu chcielibysmy sie przyjrzec najpierw

Jak to sie uda naprawicm to bysmy jeszcze sprobowali
dodac przegladanie folderow i otwieranie plikow, i bysmy sie
juz zaczeli sposobic do tego, zeby zapisywac pliki
(do tego bedzie potrzebne pole tekstowe)

no ale dobrze, najpierw testy co moe by nietak
- ale podejrzenie jest takie, ze problemem jest uzycie
  wzglednej sciezki

ok, podejrzenie potwierdzone

czyli co robimy dalej?

- klikniecie na katalog powinno nam otwierac nowe okienko
  (ewentualnie usuwac stare)
- klikniecie na plik powinno otwierac ow plik w edytorze
- okienka powinny sie otwierac wokol palca
- maksymalna wysokosc okienka nie powinna
  byc wieksxa od 2/3 wysokosci ekranu


to tak jak mamy funkcje
#+BEGIN_SRC
(define (file-list directory::File
                   file-action::(maps (File) to: void)
		   directory-action::(maps (File) to: void))
  ::PopUp
  ...)
#+END_SRC

to bysmy sobie zrobili
#+BEGIN_SRC
(define (open-file-browser directory::File editor::Editor)
  ::PopUp
  (letrec ((popup ::PopUp
    (file-list directory
      (lambda (file::File)::void
        (screen:clear-overlay!)
        (editor:load-file file))
      (lambda (directory::File)::void
        (screen:remove-overlay! popup)
        (screen:overlay! (open-file-browser directory editor))))))
     popup))
#+END_SRC

no i to jako tako dziala, ale nie ma mozliwosci wypozycjonowania

pytanie jak to bylo zrobione w poprzednim prototypie

* 20-19.06.2023

teoretycznie mamy juz te ikonki, choc w praktyce
sa jeszcze nieprzetestowane

to teraz bysmy wzieli te funkcje, ktore wczesniej napisalismy,
i umiescili w odpowiednim miejscu w kodzie (no i doszlifowali
tak zeby dzialalo)

tylko pytanie: gdzie to umiescic?

Wydaje sie, ze (button) jest do tego
najodpowiedniejszym modulem

* 18.06.2023

zaczniemy od tego, zeby pobrac rozmiary ikonek dla klienta
desktopowego, a pozniej to samo dla androidowegp

* 17.06.2023

musimy zaimplementowac wyswietlanie ikon w edytorach:
- tekstowym (latwizna)
- androidowym (bylo grane)
- desktopowym (z jsvg)

  w tym drugim przypadku mamy juz dograne budowanie
  i teoretycznie napisanie kodu powinno wystarczyc

  no to teraz: jak ma wygladac ten kod?

  do paintera dochodza 3 metody:
#+BEGIN_SRC
  (icon-extent)::Extent
  (draw-directory-icon!)
  (draw-file-icon!)
#+END_SRC

teraz trzeba zaimplementowac te metody i dodac je
do interfejsu Painter


* 16.06.2023

Keeper wydaje sie dzialac.

Teraz mamy do zrobienia zasadniczo dwie operacje, tj.
otwieranie i zapis pliku

zaczniemy od otwierania, bo do zapisu bedziemy jescze
potrzebowac pola tekstowego

no ale dobra.

i teraz sprawa tak wyglada, ze chcemy miec funkcjem
ktora pobiera plik (tzn obiekt typu java.io.File)
i zwraca nam Popup z list gridem

czyli cos takiego
#+BEGIN_SRC

(define-alias File java.io.File)
(define-alias Array java.util.Arrays)

(define-type (FileButton target: File
                         action: (maps (File) to: void))
  extending Magic
  with
  ((draw! context::Cursor)::void
   (let* ((painter ::Painter (the-painter))
          (icon ::Extent (painter:icon-extent))
	  (caption ::String (target:label)))
     (draw-icon!)
     (with-translation (icon:width 0)
       (draw-caption! caption))))

  ((as-expression)::cons
   (origin (this)))

  ((extent)::Extent
   (let* ((painter ::Painter (the-painter))
          (icon ::Extent (painter:icon-extent))
	  (label ::String (target:label))
	  (caption ::Extent (painter:caption-extent label)))
     (Extent width: (+ icon:width caption:width)
             height: (max icon:height caption:height))))

  ((key-pressed key::char)::boolean
   (cond ((eq? key #\newline)
	  (act)
	  #t)
	 (else
	  #f)))

  ((label)::String
   (target:getName))

  ((draw-icon!)::void
   (let ((painter ::Painter (the-painter)))
     (painter:draw-file-icon!)))

  ((press! finger::byte x::real y::real)::boolean
   #t)

  ((tap! finger::byte x::real y::real)::boolean
   (action target)
   #t)

  implementing ($bracket-apply$ java.lang.Comparable FileButton)
  with
  ((compareTo other::FileButton)::int
   (if (other:target:isDirectory)
      +1
      (target:compareTo other:target))))

(define-object (DirectoryButton)::Enchanted
  (define (typename)::String "DirectoryButton")
  (define (draw-icon!)::void
    (let ((painter ::Painter (the-painter)))
      (painter:draw-directory-icon!)))

  (define (compareTo other::FileButton)::int
    (if (not (other:target:isDirectory))
      -1
      (target:compareTo other:target)))

  (FileButton))


(define-object (ParentDirectoryButton)::Enchanted
  (define (typename)::String "ParentDirectoryButton")
  (define (label) "..")
  (define (compareTo other::FileButton)::int -1)
  (DirectoryButton))

(define (file-list directory::File
                   file-action::(maps (File) to: void)
		   directory-action::(maps (File) to: void))
  ::Enchanted
  (let* ((filename ::String[] (directory:list))
         (n ::int (length filenames))
         (button ::FileButton[] (FileButton[] length: (+ n 1))))
    (set! (button 0) (ParentDirectoryButton
                       target: (directory:getParentFile)
		       action: directory-action))
    (for i from 0 to n
      (let ((file (File directory (filename i))))
        (set! (button (+ i 1))
	     (if (file:isDirectory)
	       (DirectoryButton target: file
	                        action: directory-action)
               (FileButton target: file
                            action: file-action)))))
    (Array:sort button)
    (let* ((scroll ::Scroll
                   (Scroll content: (ColumnGrid button)))
           (popup (PopUp content: scroll))
	   (outer ::Extent (popup:extent))
	   (available ::Extent (screen:size)))
      (set! scroll:width (- scroll:width
                            (max 0 (- outer:width
			              available:width))))
      (set! scroll:height (- scroll:height
                             (max 0 (- outer:height
			               available:height))))
      popup)))
#+END_SRC


zakladajac, ze powyzszy kod jest sprawny, zrobilibtsmy tak,
ze przycisk Open dodaje nowy file-list do overlaya, taki
ze akcja "directory-action" rowniez dodaje do overlaya
odpowiedni file-list, natomiast file-action czysci overlaye
i dodaje nowy domument, ktory otwiera w edytorze


* 15.06.2023

czyli na razie wiemy juz, ze potrzebujemy
obiekt (the-keepeer), ktory w nieandroidowych
klientach tylko wywoluje okreslone funkcje,
a w androidowych - wywoluje po otrzymaniu okreslonych
uprawnien


* 14.06.2023

wstepnie wyglada na to, ze Scroll w terminalu dziala
(choc cos sie z jakichs wzgledow jeszcze zawiesza)

no to teraz tak: w klientach graficznych bysmy chcieli
ladowac svg, natomiast w kliencie tekstowym
po prostu uzylibysmy ikonek z unicode'a

#+BEGIN_SRC
 ..
 file.grasp
#+END_SRC

po stronie paintera bysmy zrobili
#+BEGIN_SRC
(draw-directory-icon!)::void
(directory-icon-size)::Extent
(draw-file-icon!)::void
(file-icon-size)::Extent
#+END_SRC

duzo chyba teraz bedzie rozkminy koncepcyjnej, bo
na androidzie przegladarka plikow musi miec uprawnienia,
ale u pozostalych klientow juz niekoniecznie

no dobra, to odgrzebmy moze dzialanie starej przegladarki


lomNg press powoduje wstawienie pop-upu OpenFileBrowser
albo SaveFileBrowser, ktore implementuja (nasz wlasny)
interfejs PermissiomGrantedHandler, ktory dziala tak,
ze w klasie GRASP mamy metodd

#+BEGIN_SRC
@override
public void onRequestPermissionsResult(
  int requestCode,
  String[] permissions,
  int[] grantResults
)
#+END_SRC

no dobra. ale teraz takie pytanie:
w jaki sposob zroznicowac obsluge plikow
w kliencie androidowym i pozostalych?

moze opiszmy sobie jak dziala OpenFileBrowser:
ma metode perform, ktora jest wywolywana
przy nacisnieciu przycisku Open w menu edytowa

kiedy do tego dojdzie, zostaje wywolane zapytanie
o dostep do plikow, a jako kontynuacja zostaje
ustawiony sam ten obiekt.

za wywolanie kontynuacji odpowiada system, i to
on wywola metode onPermissionGranted, ktora
tworzy nowe okienko

gdybysmy chcieli dodac te funkcje do paintera,
to bysmy mieli metody
#+BEGIN_SRC
(define-interface Keeper ()
  (with-read-permissions action::(maps (...) to: void))::void
  (with-write-permissions action::(maps (...) to: void))::void
)

(define-object (PermissiveKeeper)::Keeper
  (define (with-read-permissions action::(maps () to: void))::void
    (action))
  (define (with-write-permissions action::(maps () to: void))::void
    (action)))

(define-parameter (the-keeper)::Keeper (PermissiveKeeper))
#+END_SRC

* 13.06.2023

wyglada na to, ze implementacja with-clip jest niepoorawna,
a lezace u jej podstaw funkcjonalnosci niedostateczne
do dostarczenia poprawnej implementacji.

Dlatego dzis skupilibysmy sie na tym, zeby odpowiednio
rozbudowac paintera

Zamiast

#+BEGIN_SRC
(define-syntax-rule (with-clip (w h) . actions)
  (let ((painter (the-painter)))
    (let ((x0 (invoke painter 'current-clip-left))
	  (y0 (invoke painter 'current-clip-top))
	  (w0 (invoke painter 'current-clip-width))
	  (h0 (invoke painter 'current-clip-height))
	  (x! (invoke painter 'current-translation-left))
	  (y! (invoke painter 'current-translation-top))
	  (w! w)
	  (h! h))
      (invoke painter 'clip! x! y! w! h!)
      (begin . actions)
      (invoke painter 'clip! x0 y0 w0 h0))))
#+END_SRC

chcielibysmy raczej miec
#+BEGIN_SRC
(define-syntax-rule (with-clip (w h) . actions)
  (let ((painter ::Painter (the-painter)))
      (painter:store-state!)
      (painter:clip! w h)
      (begin . actions)
      (painter:restore-state!))
#+END_SRC

znow musimy porownac Androida, AWT i terminal.
W terminalu musimy wszytskie mechanizmy
sami zaimplementowac i tak.

w starym kliencie Androidowym mielismy
#+BEGIN_SRC
canvas.save();
canvas.clipRect(0, 0, _width, _height);
canvas.translate(-hscroll, -vscroll);
target.render(canvas);
canvas.restore();
#+END_SRC

byc moze w Androidzie mozna uzyc pary
#+BEGIN_SRC
clipRect

clipOutRect
#+END_SRC

natomiast w awt mozemy zrobic tak:

#+BEGIN_SRC
(let ((previous-clip ::Shape (graphics:getClip)))
  (graphics:clipRect ...)

  (graphics:setClip previous-clip))


(define-alias ClipState java.lang.Object)

(clip! width::real height::real)::Clip
(restore-clip! clip::Clip)::void

(define-syntax-rule (with-clip (w h) . actions)
  (let* ((painter ::Painter (the-painter))
         (previous ::Clip (painter:clip! w h)))
      (begin . actions)
      (painter:restore-clip! previous)))
#+END_SRC

i w kliencie awt to by bylo:

#+BEGIN_SRC
(define (clip! w h)::Clip
(let* ((previous-clip (graphics:getClip))
         (transform ::AffineTransform
 		      (graphics:getTransform))
         (x (transform:getTranslateX))
	 (y (transform:getTranslateY)))
    (graphics:setClip x y w h)))

(define (restote-clip! clip::Clip)::void
  (graphics:setClip (as Shape clip)))
#+END_SRC

a w kliencie androidowym
#+BEGIN_SRC
(define (clip! w h)::Clip
  (let ((clip ::RectF (RectF 0 0 w h)))
    (canvas:clipRect clip)
    clip))


(define (restote-clip! clip::Clip)::void
#+END_SRC

a moze po prodtu dodac:
#+BEGIN_SRC
(with-clip w::real h::real action::(maps () to: void))
#+END_SRC

no, to na tym w koncu stanelo. jak na razie dziala
na desktopie i androidzie, zas terminal musi jeszcze zostac
przetestowany

wydaje sie, ze nastepnym krokiem jest implementacja
przegladarki plikiw - i tutaj chyba najrozsadniej
jest zaczac od implementacji przegladarki plikow
z poprzedniego prototypu

i wyglada na to, ze:
- w kliencie androidowym chcemy dodac biblioteke android-svg
- a do klienta desktopowego bysmy sprobowali jsvg



* 12.06.2023

mamy juz wyswietlanie menu w kliencie terminalowym,
a teraz bysmy sie postarali, zeby miec to samo
na androidzie i na desktopie

zasadniczo mamy to, ale nie wyglada to tak, jak bysmy
tego chcieli: funkcja do rysowania grida powinna
rysowac biale tlo

czyli do paintera powinnismy dodac

#+BEGIN_SRC
(fill-grid-cell! width::real height::real)::void
#+END_SRC

Ok, a jak to juz bedziemy mieli, to co wtedy bedzie?

W dalszym kroku bedziemy chcieli zrobic widget Scrollable
oraz przegladarke plikow.

A kiedy to juz bedzie, zrobimy ladowanie plikow oraz
okienko "Switch to...", zamiemy sie scrollowaniem okna edytora

**** I od tego momentu mozemy juz probowac rozwijac GRASP w GRASP.

I kiedy to juz bedzie, zrobimy dzielenie ekranu
oraz wstepny zarys systemu do rozpoznawania gestow.

No ale dobra. Teraz zajmijmy sie Scrollem.
#+BEGIN_SRC
(define-type (Scroll width: real
                     height: real
		     left: real := 0
		     top: real := 0
		     content: Enchanted)
  implementing Drag
  with
  ((move! x::real y::real dx::real dy::real)::void
   (let ((inner ::Extent (content:extent)))
     (set! left (max 0 (min (- inner:width width) (- left dx))))
     (set! top (max 0 (min (- inner:height height) (- top dy))))))

  ((drop! x::real y::real vx::real vy::real)::void
   (values))

  implementing Enchanted
  with
  ((draw! context::Cursor)::void
   (with-clip (width height)
     (with-translation ((- left) (- top))
       (content:draw! (recons 0 context)))))

  ((tap! finger::byte  x::real y::real)::boolean
   (content:tap! finger (- x left) (- y real)))

  ((press! finger::byte x::real y::real)::boolean
   (screen:drag! finger (this)))

  ((second-press! finger::byte #;at x::real y::real)::boolean
    (content:press! finger (- x left) (- y real)))

  ((double-tap! finger::byte x::real y::real)::boolean
    (content:double-tap! finger (- x left) (- y real)))

  ((long-press! finger::byte x::real y::real)::boolean
    (content:long-press! finger (- x left) (- y real)))

  ((key-typed! key-code::long)::boolean
    (content:key-typed! key-code))

  ((extent)::Extent
   (Extent width: width
           height: height))

  ((cursor-under* x::real y::real path::Cursor)::Cursor*
   (content:cursor-under* (- x left) (- y top) (recons 0 path)))

  ((part-at index::Index)::Indexable* content)

  ((first-index)::Index 0)

  ((last-index)::Index 0)

  ((next-index index::Index)::Index 0)

  ((previous-index index::Index)::Index 0)

  ((index< a::Index b::Index)::boolean #f)

  ((as-expression)::cons
   (invoke-special Base 'to-list cons to-expression)))
#+END_SRC

* 11.06.2023

No dobra, to teraz chcemy dodac nowe widgety
#+BEGIN_SRC
(define-type (Link on-tap: (maps (Link byte real real) to: boolean) := always
                   on-double-tap: (maps (Link byte real real) to: boolean) := always
                   on-press: (maps (Link byte real real) to: boolean) := always
                   on-second-press: (maps (Link byte real real) to: boolean) := always
                   on-long-press: (maps (Link byte real real) to: boolean) := always
                   on-key: (maps (Link char) to: boolean) := always
                   content: Enchanted)
  implementing Enchanted
  with
#+END_SRC


* 10.06.2023

Na razie bedziemy dodawac do modulu (button):
- ColumnGrid
- Capture
- Caption

ale tez musimy dodac 3 metody do Painter
(na razie do TextPainter)
#+BEGIN_SRC
  (define 4dirs-code
    (let ((4dirs (mapping (4p::char)::int 0)))
      (set! (4dirs #\space) #b0000)
      (set! (4dirs #\) #b0001)
      (set! (4dirs #\) #b0010)
      (set! (4dirs #\) #b0011)
      (set! (4dirs #\) #b0100)
      (set! (4dirs #\) #b0101)
      (set! (4dirs #\) #b0110)
      (set! (4dirs #\) #b0111)
      (set! (4dirs #\) #b1000)
      (set! (4dirs #\) #b1001)
      (set! (4dirs #\) #b1010)
      (set! (4dirs #\) #b1011)
      (set! (4dirs #\) #b1100)
      (set! (4dirs #\) #b1101)
      (set! (4dirs #\) #b1110)
      (set! (4dirs #\) #b1111)
      4dirs))

  (define 4dirs ::char[]
    (char[] #\space
	 #\ #\ #\ #\ #\
	 #\ #\ #\ #\ #\
	 #\ #\ #\ #\ #\))

  (define (4dirs-put! c::char x::int y::int)::void
    (put! (4dirs (bitwise-ior
                  (4dirs-code (get y x))
                  (4dirs-code c))) y x))
#+END_SRC

* 09.06.2023

mamy z grubsza zarysowane metody draw! i extent,
ale do pelni szczescia bylyby nam jeszcze potrzebne:
#+BEGIN_SRC
  (define (part-at index::Index)::Indexable*
    (items index))

  (define (first-index)::Index 0)
  (define (last-index)::Index (- (length items 1)))

  (define (next-index index::Index)::Index
    (min (+ index 1) (last-index)))

  (define (previous-index index::Index)::Index
    (max 0 (- index 1)))

  (define (index< a::Index b::Index)::boolean
    (is a < b)) ;>>
#+END_SRC

przy czym te ostatnie raczej powinny byc robione
na jedno kopyto (analogicznie do tego jak zrobilismy
tego PopUpa)

#+BEGIN_SRC
(define (propagate finger::byte x::real y::real
                   action::(maps (Enchanted byte real real int) to: ?))
  (let* ((painter ::Painter (the-painter))
         (grid-border ::real (painter:grid-border))
	 (ceiling ::real grid-border)
	 (n ::real 0))
    (call/cc
      (lambda (return)
        (for item::Enchanted in items
          (let ((inner ::Extent (item:extent)))
	    (when (is ceiling < y < (+ celiing inner:height));>>
	      (return (action item finger
	                 (- x grid-border) (- y ceiling))))
	      (set! ceiling (+ inner:height grid-border))
	      (set! n (+ n 1))))
	#f))))

  (define (cursor-under* x::real y::real path::Cursor)::Cursor*
    (otherwise #!null
      (propagate 0 x y
        (lambda (item::Enchanted finger::byte x::real y::real
                 index::int)::boolean
          (item:cursor-under* x y (recons index path))))))

  (define (tap! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:tap! finger x y))))

  (define (press! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:press! finger x y))))

  (define (second-press! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:second-press! finger x y))))

  (define (double-tap! finger::byte x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:double-tap! finger x y))))

  (define (long-press! finger::byte x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:long-press! finger x y))))

  (define (key-typed! key-code::long)::boolean
    ;; na razie tego nie obslugujemy; docelowo warto by bylo
    ;; przemyslec obsluge klawiatury
    #f)
#+END_SRC

* 08-07.06.2023

mamy zintegrowany touch event processor
- no i super, i teraz musimy to przetestowac,
  i zajac sie implementacja ButtonList
  (czyli po stronie paintera to bedzie
  rysowanie i wymiarowanie gridow)

Tyle ze to nie bedzie ButtonList.
To bedzie raczej cos w rodzaju

#+BEGIN_SRC
(Link content: (Caption "Open...")
      action: ...)
#+END_SRC

czyli Link bedzie troche jak Button

Natomiast tabele bysmy budowali tak,
ze mamy
#+BEGIN_SRC
(Table
 (Column
  (Row content: (Link content: ...)
       span: 1)
#+END_SRC

Niewazne, nie skupiajmy sie na razie na tabeli.

W razie czego to sobie przemodelujemy
Natomiast teraz pytanie jest takie, jak sie
z tym uporac od strony paintera?

Na pewno musimy zaczac od tego, zeby zmienic nazwy
metod draw-horizontal-line na draw-horizontal-split itd.

ok, to juz zrobione

teraz bysmy dodali do paintera
#+BEGIN_SRC
draw-horizontal-grid!
draw-vertical-grid!
grid-border
#+END_SRC


Jak powinien wygladac kod renderujacy
ButtonList?
#+BEGIN_SRC
(define (column . items)
  (Column items))


(define-object (Column items::(sequence-of Enchanted))::Enchanted
  (define (extent)::Extent
    (let* ((painter ::Painter (the-painter))
           (grid-border ::real (painter:grid-border))
           (max-width ::real 0)
           (total-height ::real grid-border))
      (for item::Enchanted in items
        (let ((inner ::Extent (item:extent)))
          (set! max-width (max max-width inner:width))
	  (set! total-height
	        (+ total-height inner:height grid-border))))
      (Extent width: (+ max-width (* 2 grid-border))
              height: total-height)))

  (define (draw! context::Cursor)::void
    (let* ((painter ::Painter (the-painter))
           (grid-border ::real (painter:grid-border))
	   (total ::Extent (extent))
           (n ::int 0)
           (x0 ::real (painter:current-translation-left))
	   (y0 ::real (painter:current-translation-top)))
      (painter:translate! grid-border grid-border)
      (for item::Enchanted in items
        (let ((inner ::Extent (item:extent)))
          (item:draw! (recons n context))
	  (painter:translate! 0 inner:height)
	  (painter:draw-horizontal-grid! total:width)
	  (painter:translate! 0 grid-border)
	(set! n (+ n 1))))
      (painter:translate!
       (- (painter:current-translation-left) x0)
       (- (painter:current-translation-top) y0))))

#+END_SRC



* 06.06.2023

dzisiaj priorytetem jest implementacja funkcji
do rysowania pop-upow w kliencie desktopowym,
zeby przywrocic jego budowalnosc

a jesli to sie uda, to bysmy moze sprobowali
podzialac z tym touch-event-processorem, zeby
miec juz pop-upy we wszystkich klientach

ok budowalnosc mamy,
to teraz sprobujemy zintegrowac touch-event-processor

z desktopem sie to chyba udalo. teraz zas
bysmy zrobili to samo, tylko dla terminala


w tym celu:
- stworzymy sobie
#+BEGIN_SRC
  (define events ::BlockingQueue
    (ArrayBlockingQueue 32))
#+END_SRC

teraz mamy:
#+BEGIN_SRC
    (let* ((editing (future (edit io)))
	   (rendering (future (render io))))
      ;; we want the rendering thread to have a lower
      ...)
#+END_SRC

stworzylibysmy sobie nowy watek:

#+BEGIN_SRC
(let* ((events ...)
       (preprocessing (future (process io events)))
       (editing (future (edit ioevents)))
       (rendering (future (render io))))
  ...)
#+END_SRC

ale do tego potrzebny bylby rowniez timer.

a moze sie uda bex tego preprocessingu, tylko
wtedy trzeba rozwazyc kwestie ewentualnych
wyscigow

w kazdym razie jak ma w teeminalu dzialac nasz EventRunner?

#+BEGIN_SRC
(define-interface CancellableRunner (Postponed Cancellable))

(define-object (EventRunner queue::BlockingQueue)
  ::CancellableRunner

  (define postponed-action ::(maps () to: boolean) never)

  (define timer ::java.util.Timer (java.util.Timer))

  (define (cancel)::Cancellable
    (invoke-special TimerTask (this) 'cancel)
    (timer:purge)
    (this))

  (define (after time-ms::long action::procedure)
    ::Cancellable
    (timer:schedule (this) time-ms)
    (this))

  (define (run)::void
    (queue:put postponed-action))

  (TimerTask))
#+END_SRC

Ok, to jakis zamysl jest (i jutro sie tym bardziej zajmiemy),
a tymczasem mozna pomalu myslec o widgecie ButtonsList
i o tym, jak to obsluzyc od strony Paintera

#+BEGIN_SRC
(define (rewrite-events io::LanternaScreen queue::BlockingQueue)::void
  ;; although a thread rewriting stuff from one place
  ;; to another may not seem very useful, the point is
  ;; to expose a queue, so that things can be added to it
  ;; asynchronously, from a timer event
  (while #t
    (let ((event ::KeyStroke (io:readInput)))
      (queue:put event))))
#+END_SRC

* 05.06.2023

mamy juz zrobione "rusztowanie" do odpalinia
pop-upow (w kliencie terminalowym i desktopowym),
teraz bysmy sprobowali to odpalic (np. dodajac
do pop-upa jakiegos buttona) i przeniesc tez
na desktopa, a jak to bedzie gotowe, to bysmy
tez zaimplementowali widget ButtonList

jak do tej pory naprawilismy tez aktualizacje
ekranu po opoznionym zdarzeniu (tap!), i jeszcze by
wypadalo zrobic rysowanie tla w guzikach w kliencie
androidowym, oraz zdebugowac zachowanie popupow

co niniejszym rowniez sie udalo

no to tetaz tak:
- dodac rysowanie pop-upa do klienta desktopowego
- zintegrowac touch-event-processor z klientem terminalowym
- zintegrowac touch-event-processor z klientem desktopowym
- zaimplementowac ButtonList
- zrobic menu glowne
- zaimplementowac przegladarke plikow
- funkcjonalnosc odczytu i zapisu
- przelaczanie dokumentow
- scrollowanie edytora
- podzial ekranu


* 04.06.2023

dzis wykonamy drugie podejscie do rozbicia pane
na mniejsze moduly

przede wszystkim, Screen musi sie stac interfejsem

po drugie, chcemy stworzyc null-objecta implementujacego
Screen, NullScreen, bedacego domyslna wartoscia screen.

po trzecie, biezacy Screen powinien sie stac RealScreen
albo ActualScreen

No dobra, chyba to mamy.

To teraz: tak naprawde wcale nie chcemy dodawac tego
okienka z poziomu ekranu, tylko z poziomu edytora.

Mozemy zatem skasowac sobie tego NullScreena, ale chcemy
wyizolowac modul editor

i teraz problem jest taki, ze ActualScreen
ma swoj 'top' ktory jest Editor.

Zamiast tego:
- top powinno sie nazywac content
- content powinien byc ustawiany w init,
  w sensie cos w rodzaju
  (screen:set-content! (Editor document: ...))

no, to teraz powinnismy juz moc dosc gladko
wyodrebnic modul edytora

i w dalszym kroku mozemy zaimportowac (popup) w module
(editor) i dodac przy akcji (long-press!) nowy pop-up
z jakims buttonem do screena

teraz trzeba jeszcze wyjasnic dlaczego w PopUp
nie ma metody "to-list" (czy aby jest klas Struct
albo Base?)

* 03.06.2023

dzisiaj bysmy sprobowali dodac do tekstowego paintera
opcje rysowania plywajacych okien

to akurat chybs sie udalo :P

ale jest taki problem, ze modul (pane) ma zbyt wiele zaleznosci.

wiec chcielibysmy go rozbic na nastepujace:

- pane
- editor
- screen
- split
- stroke

* 01-02.06.2023

w najblizszym czasie chcemy zrobic takie rzeczy:
- plywajace okienka
- widget z lista guzikow
- ewentualnie mrugniecie guzika przed aktywowaniem akcji

najpierw sie zajmiemy plywajacym oknem

to by dzialalo jakos tak:
#+BEGIN_SRC
(define/kw (pop-up-action pop-up::PopUp
                          x::real y::real
                          inside: inner-action
			  ::(maps (Tile byte real real . list)
                             to: boolean) := never
                          outside: outer-action
                          ::(maps (PopUp byte real real . list)
                                  to: boolean) := never
			  on-the-edge: boundary-action
			  ::(maps (PopUp byte real real . list)
                                  to: boolean) := never
		          . args)
   (let* ((painter ::Painter (the-painter))
          (content ::Tile pop-up:content)
          (inner ::Extent (content:extent))
	  (horizontal ::real (painter:horizontal-popup-margin))
	  (vertical ::real (painter:vertical-popup-margin))
	  (inner-left ::real (+ left horizontal))
	  (inner-top :: (+ top horizontal))
	  (inner-right ::real (+ inner:width horizontal))
	  (inner-bottom ::real (+ inner:height vertical))
	  (right ::real (+ inner-right horizontal))
	  (botom ::real (+ inner-bottom vertical)))
     (cond ((and (is inner-left <= x < inner-right) ;>>
                 (is inner-top <= y < inner-bottom)) ;>>
	    (apply inner-action content finger
	           (- x inner-left) (- y inner-top) args))
	   ((or (is x < left) (is x > right)
	        (is y < top) (is y > bottom))
	    (apply outer-action pop-up finger x y args))
	   (else
	    (apply boundary-action pop-up finger x y args)))))


(define-type (PopUp left: real := 0 top: real := 0
                    content: Tile)

  implementing Tile
  with
  ((part-at index::Index)::Indexable*
   (match index
    ('edge (this))
    ('content content)))

  ((first-index)::Index 'edge)
  ((last-index)::Index 'content)

  ((next-index index::Index)::Index 'content)
  ((previous-index index::Index)::Index 'edge)

  ((index< a::Index b::Index)::boolean ;>
   (and (eq? a 'content) (eq? b 'edge)))

  ((cursor-under* x::real y::real path::Cursor)::Cursor*
   (call/cc
    (lambda (return)
     (pop-up-action (this) x y
      inside:
      (lambda (content::Tile finger::byte x::real y::real)::boolean
        (return
	 (otherwise #!null
	   (and path
	     (content:cursor-under*
	      x y (recons 'content path))))))
      outside:
      (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
        (return #!null))
      on-the-edge:
      (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
        (return
	  (otherwise #!null
	    (and path (recons 'edge path)))))))))

  implementing Drag
  with
  ((move! x::real y::real dx::real dy::real)::void
   (set! left (+ left dx))
   (set! top (+ top dy)))

  ((drop! x::real y::real vx::real vy::real)::void
   (values))

  implementing Pane
  with

  ((tap! finger::byte #;at x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:tap! finger x y))
     outside:
     (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
       (screen:overlay:remove! pop-up))
     on-the-edge:
     (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
       (let ((dragging screen:dragging))
         (set! (dragging finger) pop-up)))))

  ((second-press! finger::byte #;at x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:second-press! finger x y))))

  ((double-tap! finger::byte x::real y::real)::boolean
   (pop-up-action (this) x y
    inside:
    (lambda (content::Tile finger::byte x::real y::real)::boolean
      (content:double-tap! finger x y))))

  ((long-press! finger::byte x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:long-press! finger x y))))

  ((key-typed! key-code::long)::boolean
   (content:key-typed! key-code))

  implementing Enchanted
  with
  ((as-expression)::cons
   (to-list cons to-expression))
)

(define (to-expression object)
  (match object
    (magic::Enchanted
     (magic:as-expression))
    (struct::ListSerializable
     (struct:to-list cons to-expression))
    (cell::cons
     cell)
    (cell::pair
     (cons (to-expression (car pair))
           (to-expression (cdr pair))))
    (s::symbol
     (Atom (symbol->string s))
    (,@(null? object)
     (empty))
    (n::number
     (Atom (number->string n))
    (t::Text
     t)
    (s::string
     (text s))))

(painter:draw-popup!
  (+ inner:width (* 2 (painter:horizontal-popup-margin)))
  (+ inner:height (* 2 (painter:vertical-popup-margin))))
#+END_SRC

a ogolnie "kamienie milowe" bysmy okreslili jako:
- edycja GRASP w GRASP (i wypchniecie do sklepu)
- ewaluator wizualny
- kompozycjonalny system budowania rozszerzen
- ksiazka o GRASP
- ksiazka w GRASP o komputerach

* 31.05.2023

chyba ze wzgledu na klienta terminalowego
zaimplementujemy raczej ButtonList. Czyli
cos w rodzaju

#+BEGIN_SRC
(define-object (Editor)::Pane
  ...
  (define (long-press! finger::byte x::real y::real)::boolean
    (screen:overlay:add!
      (PopUp
        left: x top: y
	content:
        (ButtonList
	  (Button label: "New" action: ...)
	  (Button label: "Open..." action: ...)
	  (Button label: "Switch to..." action: ...)
	  (Button label: "Save as..." action: ...)
	  (Bitton label: "Close" action: ...)))))
  ...)
#+END_SRC

Wtedy mozemy na razie zupelnie zrezygnowac
z ustawiania rozmiaru

trzeba sie zastanowic jak do tego podejsc od strony
painterow

i moze tym sie zajmiemy pozniej.

najpierw jednak skupimy sie na przywroceniu funkcjonowania
rysowania gestow, bo to zepsulismy nasza refaktoryzacja

no dobra, to juz wyglada na naprawione

to co dalej?


teraz bysmy chcieli stworzyc pop-upa
#+BEGIN_SRC
 ..
 file.grasp
#+END_SRC

co sie stanie jezeli wyrzucimy zawartosc pop-upa ze starego
prototypu?

ogolnie nie ma takiej mozliwosci, bo kazdy pop-up
ma jakis target.


ok, to teraz painter bedzie musial otrzymac nowe metody:




* 30.05.2023

udalo sie zrobic tak zeby Overload bylo Pane
- i ten klient terminalowy teraz nawet dziala,
  choc sa problemy z androidowym, a desktopowy
  to nawrt nie byl jeszcze testowany

i pomijajac kwestie przywrocenia dzialania
- co chcemy robic dalej?

na pewno chcielibysmy miec menu, takie
jak w kliencie javowym

musimy zatem odkopac nieco starego kodu

To by teraz jakos tak wygladalo

#+BEGIN_SRC
(define-object (Editor)::Pane
  ...
  (define (long-press! finger::byte x::real y::real)::boolean
    (screen:overlay:add!
      (PopUp
        left: x top: y
	content:
        (Below
	  (Button label: "New" action: ...)
	  (Button label: "Open..." action: ...)
	  (Button label: "Switch to..." action: ...)
	  (Button label: "Save as..." action: ...)
	  (Bitton label: "Close" action: ...)))))
  ...)
#+END_SRC

no dobrze, w Javowym prototypie mielismy metode trySetSize,
i element Below mogl go sobie wywolac

I tutaj tez bysmy chcieli miec cos podobnego.

(define-interface PotentiallyResizable ()
  (try-set-width! width::real)::void
  (try-set-height! height::real)::void
  )

no dobra, ale teraz pojawia sie nam tutaj nowy aspekt,
mianowicie chcielibysmy, zeby wszystkie widgety byly
"Enchanted"

i wowczas bysmy:
1. zaimplementowali try-set-<size>! dla Button
2. zmienili czcionki na takie
   ktore wygladaja jak w starym kliencie javowym

tylko jeszcze pytanie, jak sprzac ze soba guziki
w taki sposob, zeby w kliencie terminalowym te guziki
wygladaly tak

#+BEGIN_SRC


 New          

 Open...      

 Switch to... 

 Save as...   

 Close        


#+END_SRC

Zamiast
#+BEGIN_SRC

 New          


 Open...      


 Switch to... 


 Save as...   


 Close        

#+END_SRC


* 29.05.2023

zmiany, od ktorych zaczynamy obsluge plywajacych
okien:
- usuwamy move! z interfejsu Pane
- tworzymy klase Screen, zawierajaca:
  - overlay
  - dragginng
  - top-pane
  - metode move!
  - elementy overlay rowniez powinny stac sie
    Pane, natomiast Drag powinno byc klasa
    abstrakcyjna implementujaca Pane

no dobra, klase Screen juz mamy (choc bez podniety),
natomisdt pozostaja nam jeszcze takie rzeczy, jak:
- usunac move! z Pane
- spraeic, zeby Drag bylo Pane


no ale chwila

dlaczego chcemy zeby Drag bylo Pane?

to chyba bez sensu?

chcemy za to, zeby Overlay bylo Pane.



* 26.05.2023

plany na najblizszy czas to:
- przeniesc nowe cymesy tak zeby manifestowaly
  sie w kliencie graficznym

to sie moze udac nawet dzis. ale co dalej?

jeszcze bysmy chcieli moze zintegrowac
touch-event-processor z klientami pecetowymi
- ale tak naprawde chyba najlepiej to zrobic
  jak bedziemy mieli obsluzony second-press itp.,
  no bo jak inaczej to przetestujemy?

w takim razie wydaje sie, ze byc moze kolejnym
istotnym do zaimplementowania ficzerem jest
wyswietlanoe menu oraz otwieranie i zapisywanie
plikow


ale mozemy to potraktowac jako okazje do
przemyslenia jak to powinno wygladac

na razie mamy

New
Open...
Switch to...
Save as...
Close

i takue cos powinno sie rzeczywiscie pojawiac
na pustym dokumencie

ale do tego jeszcze:
Paste
History view/Document view

na wyrazeniu zas bysmy chcieli miec:
Copy
Cut
Paste (replace)

* 24.05.2023

male podsumowanie: udalo sie dodac do klienta
androidowego quote, quasiquote i unquote.

jutro bysmy sie jeszcze zajeli unquote-splicingiem
oraz cudzyslowami do stringa, a takze odpowiednim
kolorowaniem kreski oddzielajacej glowe od ogona,
a takze przeniesieniem tych zmian do klienta AWT


* 23.05.2023

no dobra, to dzisiaj bysmy wreszcie sie zajeli tymi
klientami graficznymi

czyli mamy do dodania 16 nowych funkcji,
o implementacjach raczej trywialnych

przede wszystkim jednak chcemy zaprojektowac wyglad
tych znaczkow, i moze przy tej okazji przeprojektowac
nawiasy

do tego dochodzi jeszcze taka mysl, zeby funkcje rysujace
dla quote'a i quasiquote'a sprawdzaly, czy elementem
wewnetrznym jest unquote, i w takich przypadkach rysowaly
sie ciasniej, niz w pozostalych

* 22.05.2023

dzis bysmy sie zajeli poprawka zachowania kursora
na quote'ach:
- jezeli "expression" to lista, to wtedy sie
  pod nia podszywamy
- natomiast w przeciwnym razie implementujemy
  schemat indeksacji [ 0 ]

Do tego dochodza rzeczy, o ktorych nie myslelismy,
czyli obsluga w ramach naszego systemu edycji
- i to chyba bysmy sprobowali zrobic przed implementacja
w klientach graficznych

no ale moze najpierw uporzadkujemy kwestie
kursora po zaczarowaniu wyrazenia

wydaje sie tez, ze mamy pewne problemy z unquote-splicing

ok, chyba je rowniez sie udalo naprawic.

No to co dalej?

teraz bysmy sie chyba zajeli klientami graficznymi.

albo ewentualnie obsluga cytowan w parserze.

* 20.05.2023

na pewno trzeba poprawic zachowanie kursora podczas
zaczarowywania wyrazenia, oraz zaimplementowac
podswietlanie markerow (tak jak to jest z nawiasami)

* 19.05.2023

mamy juz mniej wiecej zdefiniowane rozszerzenia
dla quote'ow. teraz:

- przetestujmy je na kliencie terminalowym
- dodajmy stosowne funkcje do klientow graficznych
- zintegrujmy te rozszerzenia z parserem

no ale najpierw trzeba dopiescic samego klienta
terminalowego, czyli:

- wyswietlanie kursora
- resize


do tego jeszcze bysmy chcieli dodac funkcje edycji:
- wcisniecie ` na nawiasie


* 18.05.2023

otoz mamy to.
teraz dalsze akcje:
- napisac rozszerzenie dla quote

  Na razie robimy to recznie, a potem moze
  cos sobie wyabstrahujemy.

wydaje sie, ze trzeba troche wyprostowac
zaleznosci w modulach

ok, to sie udalo

to terax chcemy dla tych swoich cycatow zaimplementowac:
#+BEGIN_SRC
  (part-at index::Index)::Indexable*

  (first-index)::Index
  (last-index)::Index

  (next-index index::Index)::Index
  (previous-index index::Index)::Index

  (index< a::Index b::Index)::boolean

  (draw! context::Cursor)::void
  (cursor-under* x::real y::real path::Cursor)::Cursor*

  (extent)::Extent
#+END_SRC

* 17.05.2023

to dzis moze bysmy zaimplementowali metody do quote'ow
w kliencie tekstowym, ale jeszcze bez rozszerzania
interfejsu Painter (albo na razie tylko w komentarzach)

* 16.05.2023

z jednej strony mozemy sie zajac tym event-processorem,
z drugiej - warto sie skupic na tych quote'ach
(co wydaje sie o tyle problematyczne, ze od razu
bysmy tez chcieli zrobic zmiany dla klientow graficznych)

No ale dopsz. Przywolajmy sobie rysowanie sekwencji:

tak wyglada metoda draw! w klasie cons:

#+BEGIN_SRC
  (define (draw! context::Cursor)
    ::void
    (let* ((inner (sequence-extent (this)))
	   (painter (the-painter))
	   (paren-width (painter:paren-width)))
      (painter:draw-box! (+ inner:width (* 2 paren-width))
			 inner:height
			 context)
      (with-translation (paren-width 0)
	  (draw-sequence! (this) context: context))))
#+END_SRC

moglibysmy zrobic taki enum:

#+BEGIN_SRC
(define-enum ParenType
  (Regular Quote Quasiquote Unquote UnquoteSplicing))

( quote x )
[0  1  234]
#+END_SRC


a jeszcze z innej beczki: chcielibysmy, zeby
long-press robil nam inwalidacje ekranu na Androidzie

no ale dobra, bysmy dodali takie metody do paintera:

-draw-quote-box!
-draw-quasiquote-box!
-draw-unquote-box!
-draw-unquote-splicing-box!

-draw-quote-mark!
-quote-mark-width

-draw-unquote-marks!
-unquote-mark-width
-draw-quasiquote-marks!
-quasiquote-mark-width
-draw-unquote-splicing-marks!
-unquote-splicing-mark-width

-quote-paren-width
-quasiquote-paren-width
-unquote-paren-width
-unquote-splicing-paren-width


* 15.05.2023

no to co teraz robimy:
wtorek - commitujemy to co mamy,
sroda - dodajemy touch event processor do klientow pctowych?
czwartek - operator "quote" w malarzu i parserze?

kolejny tydzien bysmy poswieili na quasiquote'y

nastepnie bysmy troche zmienili reprezentacje atomow,
dodali mozliwosc scrollowania ekranu i wczytywania plikow,
i juz od tego momentu bysmy probowali uzywac edytora
do edytowania niego samego

* 14.05.2023

no dobra, to na czym stoimy:
- mamy w miare chyba sprawny mechanizm rozszerzen
  (choc jeszcze nie wszedzie nalezycie podpiety)
- mamy touch event processor czekajacy na podpiecie
  do klientow pecetowych

i to sa takie drobniejsze rzeczy, ktorymi mozemy zajmowac
sie w miedzyczasie

natomiast tym, co nas ekscytuje nieco bardziej,
jest mechanizm cytowania

do tego trzeba:
- dodac mechanizm do paintera
- dodac rozszerzenie
- zmodyfikowac parser


natomiast samo rozszerzenie powinno z grubsza tak dzialac:
- sprawdzamy, czy nasz 'target' to lista. jezeli tak,
to renderujemy te liste ze specjalnymi nawiasami, a jezeli
nie, to renderujemy specjalne markery wokol elementu


zaczniemy od quote'a

no i trzeba pamietac, ze oprocz klienta terminaloaego
wypadaloby dodac te funkcjonalnosc w klientach graficznych,
wiec bedzie trzeba dodac odpowiednie funkcje rysujace

#+BEGIN_SRC
(define-object (quote target)::Extension

 (define (draw! context)::void
  (cond
    ((gnu.lists.LList? target)
     (draw-sequence! ze specjalnymi nawiasami)
     ...)
    (else
     (draw! ale najpierw narysuj prostokacik)
     ...)))

 (define (extent)::Extent
  (cond
    ((gnu.lists.LList? target)
     ;; rozmiar targetu + rozmiar nawiasow
     ...)
    (else
     ;; rozmiar markera + rozmiar targetu
     ...)))

 ;; i jeszcze inne metody
   )
#+END_SRC


* 13.05.2023

na razie niewiele udalo sie ustalic
(choc pewnie rzecz ma zwiazek ze status
barem)

na razie poprawilismy renderowanie
zaokraglonych prostokatow

poniewaz jednak w klientach graficznych te
napisy wygladaja dosc brzydkawo, trzeba bedzie
troche pokomplikowac malarza (ale to nic)

rowniez rysowanie linii w kliencie androidowym
powoduje swego rodzaju brzydkosc, chociaz
to pewnie szybko poprawimy


* 12.05.2023

dzis moze zaczniemy od tego przesuniecia

* 11.05.2023

rzeczy do wyjasnienia:
- dlaczego button w androidzie powoduje crash?
  - ok to juz wyjasnione (i naprawione)
- dlaczego klikanie na button nie dziala
  w klientach terminalowych?
- skad jest to przesuniecie

co wiecej, chcemy touch-event-processor podpiac
do klienta terminalowego i desktopowego
(najlepiej na asusie, tylko trzeba tam najpierw
postawic system, a zeby to sie udalo - trzeba
go uruchomic)

a kiedy to sie uda, zajmiemy sie tym quasiqouote'owaniem

normalnie 'x to (quote x)

(quote (quote x))

czyli tak:

(quote x)

jezeli x jest param to renderujemy ja
w specjalnych nawiasach


* 10.05.2023

plan z grubsza taki:
- poprawne renderowanie guzika w klientach graficznych
  (wymaga poprawek w malarzu)
- podpiecie zdarzen do rozszerzen
- podpiecie touch-event-processora do klientow pecetowych


Do tego bysmy chcieli zrobic rozszerzenie
"quote", ktore po prostu renderuje grubsze
nawiasy, albo

#+BEGIN_SRC
       
'x =>  x

      
'x =>  x

          
'x =>  atom


    
 atom

    
 atom

    
 atom
  
#+END_SRC


czyli tak: jezeli mamy (quote (quote ...))

* 07.05.2023

na razie bysmy tak zrobili, zeby guziki
sie dobrze wyswietlaly w klientach

trzeba tez cos wykombinowac zeby klikniecie
na atomy powodowalo wysuwanie klawiatury
(a na przyklad wcisniecie guzika tego nie powodowalo)



* 01.05.2023

teraz jakos bardziej siedzi w glowie system
obslugi zdarzen (dla kazdego klienta bedzie
trzeba zrobic osobno)

ale oprocz niego chcemy:
- mechanizm rozszerzen
- kwazi-kwotacje
- otwieranie i zapisywanie plikow
- dzielenie ekranu
- scrollowanie
- pozbycie sie bugow

  moze sie to uda osiagnac w kolejnym ufo

* 27.04.2023

no to teraz plan jest taki:
- najpierw analizujemy dzialanie systemu zdarzen
  na androidzie i ew w starej aplikacji
- nastepnie przenosimy ten model do klientow kawowych

a i jeszcze w miedzyczasie naprawiamy moze
renderowanie guzika w klientach graficznych?

* 26.04.2023

wydaje sie ze tab juz dziala (tylko trzeba jeszcze
potestowac na kliencie terminalowym), teraz zas
bysmy jeszcze sprobowali popodpinac te event handlery
w normalnych klientach (tak jak w primitive-terminal-client).

no dobra, a teraz bedzie jeszcze kilka uwag dotyczacych
obslugi inputu

mamy wszak trzy klienty, i wszystkie dzialaja
nieco inaczej


* 25.04.2023

ostatnich pare dni krecilo sie glownie wokol ELS,
w tym mojej wczorajszej prezentacji (ktorej odbior
byl zdecydowanie pozytywny)

teraz commity beda juz tylko we srode i w czwartek,
a pozniej przynajmniej tydzien przerwy

do tego czasu vysmy sprobowali zaimplementowac
te guziki w normalnych klientach

jest tez pare warpliwosci zwiazanych z reprezentacja
- bo mamy tylko jedna funkcje 'cons', choc tak naprawde
 bysmy chcieli miec dwie takie funkcje - pierwsza
do uzywania w ramach dokumentu, oraz druga do uzywania
wewnatrz aplikacji.

Rzecz jest jeszcze do przemyslenia, ale na pewno
trzeba to jakos bedzie uporzadkowac, przede wszystkim
ze wzgledu na pisanie rozszerzen.

No dobra, ale teraz mamy przed soba dwa cele:
- przetestowac zaczarowywanie i odczarowywanie
i spiac je z interfejsem (i przetestowac czy
guzik bedzie dzialal)
- zaimplementowac quasi-quotacje i te pe.

No dobra. Teoretycznie operacja  jest zaimplementowana,
tylko trzeba ja podpiac do interfejsu...

* 22.04.2023

wczoraj palcem nie kiwnelismy, to moze dzis
kiwniemy? (w samolocie?)

* 21.04.2023

To moze dzisiaj:
- dodamy enchant! i disenchant! do naszych operacji
  historycznych
- dodamy


* 20.04.2023

No dobra, czyli teraz tak:
- rozrywamy enchant/disenchant! na dwie osobne funkcje
- linkujemy te funkcje z operacjami historycznymi


* 19.04.2023

no to mamy problem.

problem pomiedzy przechodzeniem miedzy swiatem struktur,
a swiatem wartosci i z powrotem.

dotychczasowe rozwiazanie polegalo na tym, ze
mielismy mape, ktora przechowywala wyrazenie,
na podstawie ktorego zostalo wygenerowane
rozszerzenie.

ograniczeniem tego rozwiazania jest to, ze zmiany
w rozszerzeniu nie zostana uwzglednione po konwersji
z powrotem do listy

problem objawia sie np. przy wyrazeniach lambda,
ktorych po ewaluacji nie mozemy zserializowac

ale wydaje sie, ze wiekszym problemem jest brak
klarownosci umyslu.

Chodzi o to, ze z jednej strony mamy wyewaluowane struktury,
z drugiej - drzewa rozbioru skladniowego, a z trzeciej
- te same drzewa, ale jako edytowalne byty

do tej pory naszym jedynym zrodlem drzew bylo parsowanie,
ale teraz bedziemy jeszcze dodatkowo mieli:
- wyniki ewaluacji
- serializacje rozszerzen

I teraz pomysl jest taki, zeby to autor rozszerzenia byl
odpowiedzialny za jego serializacje.

Czyli w przypadku Button rzeczywiscie moglibysmy
zachowywac i przywracac oryginalna liste.

No dobra. Cos tam sobie wyjasnilismy,
a teraz pora przeniesc rozwiazanie do normalnych klientow.
To bedzie wymagalo:
1. rozbicia enchant-expression! na dwie operacje
2. dodania EnchantExpression i DisenchantExpression
   do historii
3. podpiecia tej nowej funkcji do inputu
   (w assets/init.scm?)

* 18.04.2023

plan na dzis/jutro:
- przetestowac 'construct'
- zrobic podmianke w extension i button
- zintegrowac rozszerzenia z docelowymi klientami?

A jak to sie uda, to bedziemy pisac implementacje
dla quote-ow - najpierw jako rozszerzenia, pozniej
do parsera


* 17.04.2023

no to co?

plan na dzis taki, ze refaktoryzujemy
enchant-expression! tak zeby disenchant!
bylo osobna operacja; podpinamy je
do historii i wywalamy origin, zastepujac
je uzyciem metody to-list.

No, ale tutaj pomysl jest taki, ze
bysmy mieli:

#+BEGIN_SRC
(define-property (construct type-name::symbol)::(maps (list) to: Struct)
  (lambda (_) #!null))
#+END_SRC

i define-type by dodatkowo robilo

#+BEGIN_SRC
(set! (constructor 'type)
  (lambda (properties)
    (let ((item (type)))
      (let init ((properties (cdr initializer)))
        (otherwise item
          (and-let* ((`(,key ,value . ,rest) properties))``
	    (slot-set! item (keyword->symbol key) value)
	    (init rest)))))))
#+END_SRC

a zamiastveval btsmy mieli
#+BEGIN_SRC

(define (construct struct-spec::list)::Struct
  ((constructor (car struct-spec)) (cdr struct-spec)))
#+END_SRC


a tu w niedzyczasie sie rodzi plan prezentacji
1. zamiast jednego duzego dema - duzo malych dem (i opowiesc)
2. programowanie jako srodek rozumienia
3.


* 16.04.2023

No to teraz plan jest taki, ze
dodajemy nowe metody do define-type:
- (fields transform::procedure)::list
- (as-list transform::procedure)::list

w praktyce wyszlo troche inaczej,
ale to niewazne

moglibysmy tez cos wykombinowac, zeby
nie alokowac kazdorazowo listy, tylko
zeby w zamian przechowywac zcache'owana
liste w ktorej tylko aktualizujemy pola
(za pomoca set-car!), bo w ten sposob
zachowamy spacje pomiedzy elementami

no ok, to tym sie tez zajmiemy,
i co dalej?

dalej wywalamy "origin" z (extensions)
i uzywamy to-list jako disenchant, natomiast
list->struct, a moze raczej list->extension
zamiast evala w przypadku enchanta.

No wlasnie, bo teraz chodzi o to, ze z list->struct
bedziemy mieli do czynienia tylko w sytuacjach,
gdy "extension" bedzie implementowalo Struct.

Z pewnoscia takie sytuacje beda typowe, ale
waznym wyjatkiem od tej reguly bedzie quote
i przyjaciele.

Oznacza to, ze bedziemy potrzebowac jakiejs
globalnej tablicy, ktora bedzie nam mapowala
symbole na funkcje tworzace.

ALe ale w (extension) takie cos jest juz zdefiniowane!

#+BEGIN_SRC
(define-mapping (extension keyword)
  (begin
    (WARN "no extension for "keyword)
    #f))
#+END_SRC

i jest uzywane np. przez Button o tak:
#+BEGIN_SRC

(set! (extension 'Button)
      (object (Extension)
	((create-from source::cons)::Enchanted
	 (try-catch
	  (or (as Button (eval source)) #!null)
	  (ex java.lang.Throwable
	      (WARN "Unable to create Button from "source": "
		    (java.lang.String:valueOf ex))
	      #!null)))))
#+END_SRC

No ok, i teraz zamiast (eval source) bedziemy
robili (list->struct source)?

No dobra, to sie nawet wydaje miec sens.

Natomiast dla quote'ow i innych zdefiniujemy sobie
po prostu jakis inny mechanizm (licze ze sie to wyjasni
w tym tygodniu)

Czyli jaki ma byc kolejny krok?

Teraz caly czas naszym celem jest wywalenie "origin"
z (extension). Ale z pewnoscia jak to zrobimy, to
nam sie rozlezie to wyrazenie.

Dlatego bysmy sobie wprowadzili cache'owanie
i update, i opracowali wariant Buttona, ktory
juz z "origin" nie bedzie korzystal.

Nastepnie bysmy to zintegrowali z trzema "prawdziwymi"
klientami (co byc moze bedzie wymagalo zmiany tylko
w jednym miejscu - tylko koniecznie trzeba pamietac
o uwzglednieniu historii), i napisali rozszerzenia
dla quote'a, quasiquote'a itd (co juz bedzie wymagac
zmian we wszystkich klientach, a w kazdym razie w ich
malarzach)

Jezeli sie to uda zrobic w ciagu tego tygodnia, to bedzie
arcy-zacnie.

* 15.04.2023

No dobra, to teraz mamy nowy plan:
chcemy aktywowa mechanizm rozszerzen
dla guzika, tak jak w primitive-terminal-client.

powinnismy wszelako miec operacje
zaczarowywania i odczarowywania
na poziomie historii

No dobra, ale to tylko jeden aspekt.

w (extensions) mamy wlasciwosc origin,
uzywana przez enchant-expression.

chcielibysmy sie jej pozbyc, a w zamian
bysmy dodali metode to-s-expression
ktora by sie automatycznie generowala
dla struktur definiowanych przez
define-type.

Cos w stylu
#+BEGIN_SRC

(define-interface Structurizable ()
  (as-structure)::(either Atom List Text)
  (from-structure s::(either Atom List Text))::Structurizable)

(define (structure x)::(either Atom List Text)
  (match x
    (n::number
     (Atom (number->string n))
    (s::symbol
     (Atom (symbol->string s))
    (t::string
     (text t))
    (r::Structurizable
     (r:as-structure))
    (e::Element
     e)))


(as-structure conversion::(maps Object to: Object))::Object
#+END_SRC

* 14.04.2023

mamy jeszcze jakis blad z tym
komentarzem, ale na razie to sobie
odpuszczamy

no to co robimy?

dobrze by bylo sie zajac tymi
quasiquote'ami.

i tutaj plan jest taki:

- dodac wsparcie w parserze
- zintegrowac mechanizm rozszerzen

no dobra, co do parsera to
jezeli wczytamy ' ,@ , `, #' #,@ #, #`
to wywolujemy read rekurencyjnie,
po czym zwracamy odpowiednia liste
dwuelementowa

tyle ze zamiast listy powinnismy
raczej zwrocic rozszerzenie

i teraz: jak w ogole chcemy
te rozszerzenia definiowac?

#+BEGIN_SRC

(define-extension (quote item)
  ((draw! context::Cursor)::void
   (cond
     ((list? item)
      ;; zmien typ nawiasow,
      ;; wnetrze wyrenderuj normalnie
      )
     (else
      ;; wyrenderuj patyczek
      ;; przed atomem
      )))
  ((cursor-under* x y cursor)
   ...)
  ((first-index) #\')
  ((last-index) 0)
  ...)

#+END_SRC

* 13.04.2023

udalo sie zlokalizowac jeden blad
(gdy wykomentowujemy pierwszy element
listy), i teraz bysmy sie postarali
to naprawic

i moze jeszcze ten nasluch na serwerze
bysmy zrobili jako

./grasp-terminal debug-port: 12345

* 12.04.2023

Ale dzisiaj to juz na pewno zrobimy to
wykomentowywanie wyrazen, prawda?

no, to teraz tak:

do test-editor-opeations dodajemy
testy wykomentowywania wyrazen

udalo sie, ale mamy bledy, wiec
trzeba dla tych bledow napisac testy,
i nastepnie te testy naprawic.

na razie sprobujmy jednak uzupelnic
implementacje paintera dla klientow
graficznych


* 11.04.2023

Serwer gotowy i zintegrowany. Zidenyfikowalismy tez
miejsce w kodzie ktote nie tryka.

Z rzeczy do zrobienia na dzis mamy zatem:
- poprawic pejper na ELS
- dopracowac wykomentowywanie wyrazen srednikiem
- moze napisac testy?

Pod haslem 'niedaleka przyszlosc' wisi nad nami jeszcze
implementacja tgch niwych metod paintera w kliencie
graficznym, ale tym sie pewnie zajmiemy dopiero
jutro albo pojutrze.

Mamy natomiast - w zwiazku z przyszloscia nieco
odleglejsza - pewne zagwozdki odnosnie quasiquote'a.

Abstrahujac na razie od mechanizmu rozszerzen,
powinno to dzialac tak:
- jezeli renderujemy quasiquote'a po ktorym
  nastepuje wyrazeni w nawiasach, to zmieniamy nawiasy
  na podwojne
- od tej pory:
  - wszystkie wyrazenia w nawiasach renderujemy
    w podwojnych nawiasach
  - jezeli natrafimy na unquote i nawiasy,
    to renderujemy jako zwykle nawiasy,
    a zawartosc renderujemy normalnie
  - jezeli natrafimy na unquote-splicing
    i nawiasy, to renderujemy je jako zwykle
    nawiasy z wielokropkami, a zawartosc renderujemy
    normalnie
  - jezeli natrafimy na unquote bez nawiasow, to
    uzywamy 'malych haczykow na dole'
  - (analogicznie przy splicingu)

- jezeli renderujemy quasiquote'a po ktorym nastepuje
  cos innego, niz lista, to uzywamy do tego 'rozkow'

UWAGA, ZMIANA:

nie chcemy uzywac podowjnych nawiasow.

Zrobimy sobie aliasy dla `() ,() '() i ,@(), ale
tak poza tym nie bedziemy robic zadnych regul.

#+BEGIN_SRC

        0 1 2 3 4 5 6 7 8 9 A B C D E F
U+250x                 
U+251x 	               
U+252x 	               
U+253x 	               
U+254x 	               
U+255x 	               
U+256x 	               
U+257x 	               

               
'(...) =>  ... 
               
               
`(...) =>  ... 
               
            
,@() =>  ... 
             
            
,() =>  ... 
            
      
'x =>  x

       
`x => x


,@x => x
         

,x =>x
      

`(f ,(+ x y) ,@(- y z))

                     
 f  + x y   - y z  
                     

#+END_SRC


* 10.04.2023

Wyglada na to, ze laptop od Piotra zdechl (czy
w zasadzie zepsul mu sie wlacznik)

Mamy niedzialajacy kawalek kodu do komentowania,
ale nie mamy jak odpalac desktopowego klienta.

Stad pomysl na maly skok w bok: napiszemy sobie
serwer tcp, ktory bedzie implementowal interfejs
output-server-port

Czyli tak: wywolanie (tcp-outpt-server port::short)


no dobra, to mamy tak:
(current-output-port) ma typ gnu.kawa.io.BinaryOutPort
ktory rozszerza gnu.kawa.io.OutPort,
ktory rozszerza gnu.lists.PrintConsumer i implemenfuje Printable



* 09.04.2023

jezeli jestesmy na atomie albo na spacji,
to wcisniecie srednika powinno spowodowac
zakomentowanie wyrazenia

a jezeli jestesmy na komentarzu wyrazeniowym,
to powinnismy zamiast tego odkomentowac wyrazenie

* 08.04.2023

napisalismy test, ktory jednakowoz nie przechodzi.

problem chyba jest taki, ze procedura extract!
dla nie-komentarzy dodaje szerokosc wyrazenia
do spacji, natomiast procedura insert! dla
komentarzy juz tego nie robi

no dobra, mamy poprawke.

jutro bysmy sie zajeli
- integracja wykomentowywania z interfejsem
- implementacja trybu rysowania komentarzy
  w klientach graficznych

* 07.04.2023

no dobra. mamy hipoteze dotyczaca tego, jak powinna
dzialac nasza operacja. teraz zostaje nam jeszcze
przetestowanie tych operacji, dodanie ich do interfejsu,
i dodanie testu do operacji edycji

a do tego chcemy dodac nowe metody paintera
do grasp-desktop i grasp-android

a pozniej co?

- quote'y
- scrollowanie
- podzial ekranu
- ladowanie plikow

a pozniej co?

- ewaluacja
- rozszerzenia
- partykularne rozszerzenia
- sklep + wersja platna

* 06.04.2023

test wykazal, ze trzeba jeszcze troche dopiescic
insercje. i to bysmy zrobili, plus:
- dodali operacje historyczne
- zaimplementowali w kliencie desktopowym i androidowym

#+BEGIN_SRC

(define (f x y) z)

(the-expression at: '(5 3 1 1)) ===> y

(define (f x #;y) z)

(the-expression at: '(2 4 3 1 1)) ===> #;y


(define-type (CommentExpression at: Cursor following: int)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* ((`(,expression) (take! at: at from: document))
              (`(,tip . ,root) at)
	      (cursor (recons* following (- tip 1) root)))
     (insert! (ExpressionComment expression: expression)
              into: document at: cursor)
     cursor))
  ((inverse)::Edit
   (and-let* ((`(,tip . ,root) at))
     (UncommentExpression at: (recons* following (- tip 1) root)))))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* (((ExpressionComment expression: expression)
               (take! at: at from: document))
	      (`(,tip ,top . ,root) at))
     (insert! (cons expression '()) at: at into: document)
     (recons (+ top 1) root)))
  ((inverse)::Edit
   (and-let* ((`(,tip ,top . ,root) at))
     (CommentExpression at: (recons (+ top 1) root)
                        following: tip))))
#+END_SRC

* 05.04.2023

mamy niby napisany insert dla komentarzy,
ale trzeba jeszcze napisac testa.

* 04.04.2023

wyglada na to ze mamy awarie karty pamieci
i nasz projekt quote'ow wzial w leb

no to co teraz:
- insert!
- operacje historyczne
- integracja z interfejsem
- implementacje w edytorach graficznych

  ok to zacznijmy od analizy inserta

* 01.04.2023 (telefon)

Extract! juz jest zrobiony.
Teraz co jeszcze musimy zrobic:
- insert! dla komentarzy
- CommentExpression i UncommentExpression
- renderowanie wykomentowanych wyrazen
  - jako tekst
  - w terminalu (ciemniejszy kolor)


* 27.03.2023

pomysl jest taki, zeby zrefaktoeyzowac
funkcje "extract!" - tak zeby mogla zwracac
albo pare, albo separator, albo komentarz.

No, ale w tym celu musimy najpierw
przeanalizowac dotychczasowe dzialanie
tej funkcji, bo jest tak, ze rozne byly
zachowania w zaleznosci od tego,
ktory element zesmy ekstrahowali.

Rownolegle - poniewaz rysowanie gestow
zdaje sie pomagac w diagnozie - warto
poprawic klienta desktopowego

To moze przeanalizujmy architekture:

mamy screen-renderer, implementujacy
Paintera i bedacy JComponentem,
unterfejs InputListener agregujacy
rozne event handlery, oraz InputHandler,
rozszerzajacy JFrame i dostarczajacy
trywialnych implementacji.

Wreszcie jest window-screen, ktory rozszerza
InputHandler, dostarczajac nietrywialnych
implementacji handlerow tam gdzie trzeba.

I teraz plan jest taki, zeby window-screen
nie dziedziczyl po JFrame, tylko zebysmy
tworzyli JFrame, na ktorym bysmy
wywolywali setContentPane

No dobra. A co z tym naszym extractem?

* 27.03.2023 (komputer)

Master plan: window-screen powinien byc JComponentem,
run-in-AWT-window powinno tworzyc javax.swing.JFrame,
ktorego content-pane: to bedzie wlasnie window-screen.

Tylko kilka uwag:

- window-screen to nie jest dobra nazwa, i trzeba
wymyslic inna

- byc moze warto sie zastanowic nad scaleniem ze soba
tej klasy ze screen-rendererem

* 26.03.2023
#+BEGIN_SRC

(define/kw (fully-expanded? cursor::Cursor
             on: document := (the-document))::boolean
  (and-let* ((`(,tip . ,root) cursor)
             (target (cursor-ref document root)))
    (eq? target (part-at tip target))))

(define (cursor-trace document cursor)
  (match cursor
    ('() (cons document '()))
    (`(,tip . ,root)
     (and-let* ((trace (cursor-trace document tail))
                (`(,parent . ,elders) trace))
	(cons (part-at tip parent) trace)))))
#+END_SRC

no dobra. i teraz co?


* 25.03.2023

1. Wykomentowywanie wyrazen
dwie nowe operacje:
#+BEGIN_SRC
(define-type (CommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((preceding-cursor (cursor-retreat at document))
              (`(,item::Tile) (extract! at: at from: document)))
     (insert! (ExpressionComment expression: item)
              into: document at: preceding-cursor)
     preceding-cursor))
  ((inverse)::Edit
   (UncommentExpression at: ???)))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((
  ((inverse)::Edit
   (CommentExpression at: ???)))
#+END_SRC

Aczkolwiek problem jest taki, ze extract!
nie obsluguje komentarzy.

To pomysl jest teraz taki, zeby
- albo dodac obsluge komentarzy
  do 'extract!' (ktorej to funkcji
  jednak nie lubimw)
- albo po prostu po chamsku
  samemu wyciagnac z komentarza


A gdybysmy tak mieli napisac extract! drugi raz?

* 24.03.2023

zmiana rozmiaru dziala w miare OK.

to teraz skupilibysmy sie na takich
tematach:
- rysowanie kresek
- wykomentowywanie wyrazen
- poprawne dzialanie drag&drop na komentarzach?

Dobra, zacznijmy od tego rysowania kresek.
#+BEGIN_SRC

(define-object (Drawing stroke::Stroke)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    (stroke:add (Point x y)))

  (define (drop! x::real y::real vx::real vy::real)::void
    (the-overlay:removeIf (is _ Stroke?)))

  (the-overlay:add! stroke))
#+END_SRC

No, to rysowanie kresek juz jako tako dziala.
Wprawdzie jest jeszcze sporo do przemyslenia,
ale juz sie troche nie moge doczekac poniedzialkowego
commita.

No dobra, i co dalej?

Kolejna rzecz jaka mozemy robic, to:

- wykomentowywanie wyrazen
- poprawki w edycji komentarzy
- drag&drop na komentarzach


* 23.03.2023

Dzisiaj:
- naprawilibysmy buga zwiazanego ze zmiana rozmiaru
  pudelka w ktorym znajduje sie linia zakonczona
  komentarzem
- dodalibysmy mozliwosc rysowania kresek

Ale warto sie zastanowic czy nie lepiej
byloby ujednolicic reprezentacje spacji w taki
sposob, zeby nowa linia pojawiala sie explicite.

Do przemyslenia (choc tak po prawdzie to pewnie
raczej nie, bo wydaje sie, ze jestesmy dosc blisko
funkcjonujacego kodu)

Wyglada na to, ze bedzie trzeba troche popracowac :/

* 22.03.2023

Dzis bysmy sprobowali przemyslec co jest
do zrobienia w kontekscie poszczegolnych
klientow (terminalowego, desktopowego
i androidowego), a jaka kompetencje powinien
miec (pane), jezeli idzie o rysowanie gestow.

I takie pytanie: czy moglibysmy zaimplementowac
rysowanie gestu jako 'Drag'?
#+BEGIN_SRC

(define-object (DrawingGesture gesture::Gesture)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    ;; dodajemy Point do stroke'a
    ...)

  (define (drop! x::real y::real vx::real vy::real)::void
    ;; wywolujemy recognizer
    ...)

  (the-overlay:add! gesture))
#+END_SRC

* 21.03.2023

Przeanalizujmy obsluge gestow w grasp-android:

mamy globalny obiekt
#+BEGIN_SRC
(define the-stroke ::Stroke #!null)
(define the-gesture ::Gesture (Gesture))
#+END_SRC

oraz funkcje 'isShapeBeingDrawn'
#+BEGIN_SRC
(define (gesture-is-being-drawn?)::boolean
  (isnt the-stroke eq? #!null))
#+END_SRC

a do tego funkcje
#+BEGIN_SRC

(define (start-drawing-gesture!)::void
  (set! the-stroke (Stroke)))

(define (cancel-drawing-gesture!)::void
  (gesture:clear!)
  (set! the-stroke #!null))

#+END_SRC

no i dobrze. ale ciekawsze jest to, w jaki sposob
te funkcje sa wywolywane:

cancelDrawingShape jest wolany w:
-onDoubleTap
-onDown (gdy przycisnieto drugi palec
albo gdy onPress zwrocilo obiekt Drag)
-onMotion gdy wygenerowano DoublePress
-onUp jezeli udalo sie rozpoznac gest
-onSingleTap
-onLongPress

z kolei startDrawingShape jest uzywany
w onDown (jezeli nic innego sie nie wydarza)

wreszcie isShapeBeingDrawn jest:
- w onDown przy sprawdzaniu czy przycisnieto
  drugi palec i przy rozpoczynaniu rysowania
  ksztaltu
- w onMotion przy dodawaniu nowego odcinka
  do aktualnego stroke'a
- w onUp przed rozpoczeciem rysowania


natomiast finalizeStroke jest wywolywany przy
konczeniu rysowania

* 20.03.2023

Rysowanie gestow
ma dwojaki sens:
- czlowiek rysuje gesty
- program rysuje linie

No ale dobra
trzeba pomyslec
w jaki sposob chcemy
reprezentowac.

Teraz w (pane) mamy cos, co sie nazywa overlay,
i do czego mozemy wlozyc obiekty Drawable.

i teraz: chcielibysmy miec obiekt "Drawable",
ktory bylby dodawany do Overlay w momencie,
kiedy zaczynamy cos rysowac.

ale jak sie on bedzie nazywal?


* 19.03.2023

teraz to bysmy chcieli miec funkcje
#+BEGIN_SRC

(define 4pix-code
  (let ((4pix (mapping (4p::char)::int 0)))
(set! (4pix #\space) #b0000)
(set! (4pix #\) #b0001)
(set! (4pix #\) #b0010)
(set! (4pix #\) #b0011)
(set! (4pix #\) #b0100)
(set! (4pix #\) #b0101)
(set! (4pix #\) #b0110)
(set! (4pix #\) #b0111)
(set! (4pix #\) #b1000)
(set! (4pix #\) #b1001)
(set! (4pix #\) #b1010)
(set! (4pix #\) #b1011)
(set! (4pix #\) #b1100)
(set! (4pix #\) #b1101)
(set! (4pix #\) #b1110)
(set! (4pix #\) #b1111)
4pix))

(define 4pix ::char[]
  (char[]
  #\space
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  #\
  ))

(define (4pix-set! x4::int y4::int)::void
  (let* ((x ::int (quotient x4 2))
         (h ::int (remainder x4 2))
         (y ::int (quotient y4 2))
	 (v ::int (remainder y4 2))
	 (c ::char (get y x))
	 (existing-code ::int (4pix-code c))
	 (mask ::int (arithmetic-shift 1 (+ (* 2 v) h)))
	 (new-code ::int (bitwise-ior existing-code mask))
	 (c* ::char (4pix new-code)))
    (put! c* y x)))


x^2 + y^2 = r^2

y^2 = r^2 - x^2

y = sqrt(r^2 - x^2)


(x0 - radius + i)


(define (draw-circle-4pix! x0::real y0::real radius::real)::void
  (let ((diameter ::int (ceiling (* 2 radius)))
        (r^2 (* radius radius)))
    (for i from 0 to diameter
      (let* ((dx ::real (- i radius))
             (dy :: real (sqrt (- r^2 (* x x))))
	     (x ::int (as int (round (+ x dx))))
	     (+y ::int (as int (round (+ y dy))))
	     (-y ::int (as int (round (- y dy)))))
        (4pix-set! x +y)
        (4pix-set! x -y)))))

#+END_SRC


* 18.03.2023

#+BEGIN_SRC

x1-x0   y1-y0
----- = -----
  m       n

y0 = ax0 + b
y1 = ax1 + b


(define (draw-line! x0::real y0::real x1::real y1::real)::void
  (let* ((x1-x0 ::real (- x1 x0))
         (y1-y0 ::real (- y1 y0))
	 (angle ::real (atan y1-y0 x1-x0)))
    (cond
      ((is -pi/4 <= angle <= pi/4) ;>>
       (let ((slope ::real (tan angle))
             (x0 ::int (round x0)))
         (for i from 0 to (as int (ceiling x1-x0))
	   (let ((x (+ x0 i))
	         (y (+ y0 (* slope i))))
             (put! #\ (as int (round y)) x)))))
      ((is pi/4 <= angle <= (* 3 pi/4)) ;>>
       (let ((slope ::real (/ (cos angle) (sin angle)))
             (y0 ::int (round y0)))
         (for j from 0 to (as int (ceiling y1-y0))
	   (let ((x (+ x0 (* slope i)))
	         (y (+ y0 i)))
	   (put! #\ y (as int (round x))))))
      (else
       (draw-line! x1 y1 x0 y0)))))





  
  
   
  
  

 

 
   

  
#+END_SRC

* 17.03.2023 (telefon)

W ramach odpinki moze sprobujemy dodac do systemu
funkcjonalnosc rysowania gestow.

Ogolnie to musi wygladac tak, ze
jak zaczynamy rysowac gest, to dodajemy
'stroke' do overlaya, natomiast sam 'stroke'
to nic innego jak lista punktow.

Na pozor wydaje sie to latwe, ale pamietajmy
takze o tym, ze chcemy tez rysowac linie
w terminalu - i dlatego chcielibysmy dodac
mozliwosc rysowania linii do interfejsu Painter.

(mozna sie tez zastanowic nad uzyciem
w GRASP renderowania w stylu Figlet)

Oczywiscie rysowanie linii trzeba zaimplementowac
dwojako: w kliencie tekstowym i terminalowym.

W przypadku klienta terminalowego bedziemy
uzywac koloru, natomiast w przypadku klienta
tekstowego bysmy uzyli tego:

#+BEGIN_SRC

    
    
    
  


 
#+END_SRC

czyli dodajemy do paintera funkcje

(draw-line! x1::real y1::real x2::real y2::real)::void

i implementacje dla androida i awt (wolajace
pod spodem odpowiednie funkcje) oraz dla klienta
tekstowego

* 14.03.2023

Popsute klikniecia udalo sie naprawic, i powinny wyjsc
w jutrzejszej serii commitow.

Natomiast teraz chcemy sie zajac nastepujacymi rzeczami:
- dodawanie, usuwanie i edycja komentarzy blokowych
(poprzez wpisanie #| albo |# w kontekscie atomu - wowczas
powinnismy podzielic atom, np. ab#|cd powinno nam zrobic
dwa atomy ab cd, a miedzy nimi pusty komentarz blokowy)

tak naprawde to wcisniecie | powinno dzialac w taki sposob,
ze jezeli jestesmy na przedostatnim elemencie listy, to
sprawiamy, ze ta lista bedzie "dotted?". Jezeli natomiast
jestesmy na symbolu i po lewej albo prawej stronie
od kursora znajduje sie znak #, to go usuwamy
i wstawiamy komentarz blokowy (i przy okazji byc moze
rowniez rozbijamy atomy)

Wydaje sie, ze dodatkowo bedziemy chcieli zrobic
nowy rodzaj operacji edycji, ktory sobie nazwiemy
"EditSequence", o taki mniej wiecej

#+BEGIN_SRC scheme
(define-type (EditSequence operations:  (list-of Edit))
  ((apply! document)::Cursor
   (let ((result ::Cursor #!null))
     (for operation in operations
       (set! result (operation:apply! document)))
     result))
  ((inverse)::Edit
   (define (transform sequence inverted)
     (match sequence
       (`(,head::Edit . ,tail)
        (transform tail (cons (head:inverse) inverted)))
       ('()
        inverted)))
   (transform operations '())))
#+END_SRC

* 12.03.2023

Wyglada na to, ze biezaca implementacja komentarzy
blokowych popsula zupelnie detekcje klikniec.

* 09.03.2023

Do zrobienia mamy:
- usuwanie komentarzy
- chyba poprawki w inwersji dodawania komentarzy?
- renderowanie komentarzy blokowych
- edycja komentarzy blokowych
- dodawanie i usuwanie komentarzy blokowych

No dobrze, uznajmy komentarze liniowe za skonczone
(choc niewatpliwie trzeba sie jeszcze bedzie uporac
z bugami i roznymi corner case'ami, ktore jedak
na razie nie sa naszym priorytetem)

To teraz robimy komentarze blokowe.
Renderowanie musi tak przebiegac,
ze rysujemy prostokat, a wewnatrz
renderujemy tekst


* 08.03.2023

Wczoraj napisalismy funkcje do dodawania komentarzy
do spacji, oraz test dla niej.

Dzis bysmy sprobowali zintegrowac te funkcje z edytorem,
tak zeby wcisniecie srednika powodowalo dodanie komentarza
- aczkolwiek do tego bedzie jeszcze konieczne dodanie
operacji odwrotnej, tj. usuniecie komentarza

* 07.03.2023

Dzis bysmy sie zajeli edycja liniowych komentarzy.

W kolejce czeka jeszcze kilka pomniejszych rzeczy,
takich jak:
- naprawa polozen kursora na spacjach
- renderowanie lewej belki przy liniowych komentarzach
- renderowanie cudzyslowow przy stringach
- obsluga drag&dropa przy rysowaniu stringow i komentarzy

Ogolnie plan jest taki, ze najpierw skonczymy edycje
liniowych komentarzy, pozniej zrobimy pudelkowe
komentarze, a na koncu wyrazeniowe komentarze.

Kiedy to bedzie zrobione, zajmiemy sie quote'ami itd.
(oraz moze syntaxami itd.?),

a dalej bysmy zrobili to ladowanie i zapisywanie
i scrollowanie i dzielenie ekranu (ach jakie to bedzie
piekne)

i wowczas dalsze rzeczy bedziemy juz robic w samym
GRASPie! (jupi!)

No ale dobra. Teraz robimy edycje komentarzy.
Powinno to dzialac tak mniej wiecej:
1. jezeli jestesmy na spacji i wcisniemy ;,
to dodajemy do tej spacji nowy liniowy komentarz
(i odpowiednio przesuwamy kursor)
2. jezeli od tego miejsca nacisniemy na (pustym)
komentarzu backspace, to usuwamy komentarz
3. jezeli nacisniemy "delete" na poczatku komentarza,
to usuwamy caly komentarz
4. jezeli wciskamy na zwykly klawisz, to po prostu
   dopisujemy odpowiedni znak do komentarza
5. jezeli mielibysmy dopisac znak nowej linii,
   to dzielimy komentarz

To ostatnie bedzie najpewniej wymagalo zaimplementowania
interfejsu Textual w LineComment

Trzeba bedzie dodac nowe operacje:
#+BEGIN_SRC
(InsertComment content: TextualComment at: Cursor)
#+END_SRC

oraz
#+BEGIN_SRC
(RemoveComment content: TextualComment at: Cursor)
#+END_SRC

a takze
#+BEGIN_SRC
(CommentExpression at: Cursor)
#+END_SRC

oraz

#+BEGIN_SRC
(UncommentExpression at: Cursor)
#+END_SRC


* 06.03.2023

Dzisiaj musimy tak zmodyfikowac cursor-under* w Space,
zeby dawal poprawne indeksy podczas iterowania
(zeby klikanie na komentarze umieszczalo kursor
w odpowiednim miejscu)

Ponadto mozna by cos pokombinowac, zeby kursor
znajdujacy sie normalnie na spacji byl na takiej
samej wysokosci, co liniowy komentarz, jezeli
za nim znajduje sie liniowy komentarz.

No dobrze. To "Space::cursor-under*" powinien
sie zachowywac analogicznie do "advance!".

Wyglada na to, ze w pierwszym wierszu
komentarza wszystko dziala jak nalezy
- ale ze w drugim wierszu juz nie udaje
sie zlapac.

To sie chyba udalo jakos naprawic.

** Problem z generic-dispatch i subclassigniem

Przy okazji - problem, ktory pojawia sie, gdy mamy
"generic dispatch" oraz "subclassing" - i jest to
problem zasadniczo nierozwiazywalny:
#+BEGIN_SRC

(define-class <a> ())

(define-class <b> (<a>))

(define b (make <b>))

(define-class <c> (<a>))

(define c (make <c>))

(define-method (m (x <a>) (y <a>)) 'aa)
(define-method (m (x <b>) (y <a>)) 'ba)
(define-method (m (x <a>) (y <c>)) 'ac)

(m b c)
#+END_SRC

* 05.03.2023

W najblizszym czasie - w zwiazku z implementacja
komentarzy liniowych - bedziemy mieli do zrobienia
takie oto prace:
1. zeby klikanie na ekranie powodowalo umieszczenie
kursora w odpowiednim miejscu
2. zeby pisanie powodowalo dodawanie tekstu do komentarza
3. zeby komentarze mozna bylo przeciagac i upuszczac
4. zeby upuszczenie pudelka nad komentarzem powodowalo
   jego serializacje? (ale wtedy chyba to samo chcielibysmy
   dla stringow, c'nie?)


* 03.03.2023

Chyba z rysowaniem komentarzy udalo sie juz jakos dojsc
do ladu.

Ale teraz z kolei mamy inny problem:

kiedy kursor jest we wlasciwej czesci dokumentu, to nie dochodzi
do rysowania go.

* 02.03.2023

Wyglada na to, ze mamy problem z przypisywaniem indeksow
podczas rysowania spacji.

No to w takim razie przeanalizujmy sobie

Mamy 3 interesujace metody w Space:
1. draw!
2. advance!
3. cursor-under*

No i dobra, i teraz rozwazmy sobie te metode
draw!.

Ona robi tak, ze definiuje sobie wewnetrzna petle,
ktora "zjada" fragmenty spacji i sledzi wartosc "total".

I teraz tak: czym jest ow parametr "total"?

Pierwotna interpretacja byla taka, ze jest to
informacja o tym, ile spacji udalo sie juz przeskoczyc.

Mamy jednak przed soba kilka trundych kwestii:
- nie wiemy, czy poprzednia interpretacja w ogole byla dobra
- nie wiemy, jaka powinna byc nowa interpretacja

No, wezmy sobie

(Space fragments: (list 2 LC 2 LC))

Dziala to tak, ze najpierw total wynosi 0. Nastepnie:
- wywolujemy (advance-with-cursor! width) i dodajemy
width do total
- nastepnie mamy LC. Ono powinno byc na indeksie 3
kolejna 2


** a to takie tam bazgrolki:
#+BEGIN_SRC








  
 
 
 


                       
 define  map f l       
                       
                       
  match l              
                       
                 
                 
                 
                  
    head  tail    
         ^         


   
   
   


  

#+END_SRC

* 01.03.2023

Wczoraj nie udalo sie osiagnac zbyt wiele - ale mimo
wszystko cos sie udalo!

Dzis zajelibysmy sie pisaniem staromodnych testow
dla "space-fragment-index", "delete-space-fragment!",
"Space:last-index", oraz zaimplementowalibysmy
w LineComment interfejs Textual
(ogolnie chcielibysmy zeby BlockComment takze
obslugiwal ten interfejs - ale ExpressionComment
juz niekoniecznie)

No ale dobra: rzecz ma sie tak, ze:
- wystapienie LineComment powodje pojawienie
  sie nowej linii (czyli tak jak pojawienie sie
  dwoch liczb po sobie)
- ale wystapienie BlockComment czy ExpressionComment
  juz niekoniecznie

Ale teraz jak to ogarnac?

Mamy takie operacje:
- rysowanie
- mierzenie
- klikanie

Poniewaz na razie rzecz wyglada nieco kiepskawo
jezeli idzie o diagnostyke, to zaimplementujemy
renderowanie komentarzy w kliencie desktopowym.

* 28.02.2023

Wczoraj z grubsza sie udalo zaimplementowac renderowanie
w kliencie tekstowym i terminalowym, ale nie mamy jeszcze
obslugi klikania, i strzalki w lewo i prawo tez jeszcze
nie calkiem dzialaja.

Dlatego dzis moze sprobowalibysmy sie zajac tymi dwiema
kwestiami.

* 27.02.2023

Do rozdzielenia juz doszlo, i wyglada na to,
ze niczego to nie psuje.

Teraz mamy dwa najistotniejsze watki:
1. zaimplementowac min-box-height na Androidzie
2. sprobowac dodac slowo kluczowe 'default
do domyslnych interfejsow, i usunac metode
"advance!" z implementacji Tile.

A w dalszej kolejnosci sprobowalibysmy pojsc
taka droga:
1. zaimplementowac komentarze liniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
2. zaimplementowac komentarze blokowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
3. zaimplementowac komentarze wyrazeniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
4. rozwazyc uzycie mechanizmu rozszerzen
  do wyswietlania quote, quasiquote, unquote, unquote-splicing
5. wprowadzic obsluge quote, quasiquote, unquote,
  unquote-splicing do parsera

No dobra, czyli teraz: komentarze liniowe dla klienta
terminalowego (i textowego)

To zaczynamy od tekstowego.
Bedzie trzeba dodac testy jednostkowe,
natomiast w przypadku terminalowego - jeszcze
ustawic kolory odpowiednio.

No dobra. Implementacja komentarzy musi sie skladac
z nastepujacych metod:
1. draw!
2. extent
3. cursor-under

* 24.02.2023

Teraz pomysl jest taki, ze poniewaz zakladamy,
ze linie skladajace sie tylko z komentarzy liniowych
moglibysmy ze soba scalac, moglibysmy rozdzielic
parametr "min-line-height" na "min-box-height"
i "min-line-height"

Gdzie jest uzywany min-line-height?

- W (extent '())
- w (empty-space-extent)
- przy inicjalizacji "traversal" jako max-line-height
  w traverse
- przy inicjalizacji obiektu Traversal w Space:extent
- w funkcji resize! do zmiany rozmiaru pudelka
- w metodzie new-line! obiektu Traversal
- w metodzie atom-extent w CharPainterze


* 23.02.2023

bysmy moze zaczeli od zaimplementowania
draw-line-comment! i draw-box-comment!
w painterze (tzn. w TextPainterze,
TerminalPainterze, screen-rendererze,
a w pozniejszym czasie rowniez
w androidowym View).

Dla TextPainter bysmy tylko robili

dla TerminalPainter bysmy tez dodali
troche koloru.

#+BEGIN_SRC
 jeden srednik
 dwa sredniki
 trzy sredniki
 cztery sredniki
 piec srednikow
#+END_SRC

Wreszcie dla screen-renderera - i docelowo
dla Androida tez - bysmy wybrali jakas
zwariowana czczionke

Jezeli idzie o komentarze pudelkowe,
to bysmy je tak rysowali:

#+BEGIN_SRC


   


Lispiarze maja ogolnie taka konwencje, ze
;;; Heading
;;;; subheading
;;;;; subsubheading

#+END_SRC


No dobra, ale pozostaje nam jeszcze kwestia
tego, ze chcielibysmy, zeby komentarze liniowe
byly jedna linia pod druga, tzn. zeby nie bylo
miedzy nimi takiego duzego odstepu, jak w przypadku
atomow

* 22.02.2023

Wydaje sie, ze przynajmniej pozornie:
- dodanie rysowania do komentarzy bedzie
raczej proste
- dodanie "cursor-under*" wymaga nieco myslenia
- dodanie 'advance!' tez powinno byc raczej latwe

No to zastanowmy sie nad tym "cursor-under*"

Mamy sobie kopie obiektu traverse.
Funkcja "cursor-under" odejmuje t:left i t:top
od otrzymanych wartosci left i top.

Ale z jakichs wzgledow implementacja cursor-under*
w Space przywraca rame odniesienia dla danego
obiektu Traverse.

Ogolnie rzecz biorac to ma sens o tyle, ze
spacje nie sa "foremne" i moga rozciagac sie
na wiele linii.

No ale dobra. W przypadku spacji transformujemy
wspolrzedne z powrotem do ukladu wspolrzednych
obiektu (the-traverse).

To teraz zamysl jest taki:
1. implementujemy metody draw!, cursor-under* oraz advance!
   dla wszystkich trzech odmian komentarzy
2. integrujemy to sobie w obiekcie space
3. wszystko hula i sie cieszymy

No dobrze, ale mamy tak:

|---------------+--------------------+------------------------+--------------------------|
| metoda        | LineComment        | BlockComment           | ExpressionComment        |
|---------------+--------------------+------------------------+--------------------------|
| draw!         | rysujemy           | rysujemy               | najpierw rysujemy        |
|               | jakis znacznik     | pudelko wewnatrz       | spacje (mozemy sobie     |
|               | i renderujemy      | ktorego renderujemy    | zalozyc ze sa zerowe)    |
|               | tekst (ale trzeba  | tekst (trzeba pomyslec | a po nich wyrazenie      |
|               | pomyslec o kolorze | o kolorze i kroju      | - ale trzeba w jakis     |
|               | i kroju czcionki)  | czcionki)              | sposob zmienic tryb      |
|---------------+--------------------+------------------------+--------------------------|
| cursor-under* |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|
| advance!      | normalnie          | normalnie              | najpierw spaces:advance! |
|               |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|


Trzeba przemyslec jakie zmiany by nalezalo wprowadzic do paintera.

Moglibysmy po prostu dodac:

enter-comment-drawing-mode!
exit-comment-drawing-mode!

A co z cytowaniem?
#+BEGIN_SRC

increase-quotation-level!
decrease-quotation-level!

increase-quasiquotation-level!
decrease-quasiquotation-level!

No i jeszcze co ze zwyklymi komentarzami?

draw-line-comment!
draw-block-comment!

line-comment-extent
block-comment-extent


                       
 define  map f l       
                       
                       
  match l              
                       
                 
                 
                 
                  
    head  tail    
         ^         


                       
 define  map f l       
                       
                       
  match l              
                       
                 
                 
                 
                  
    head  tail    
         ^         

#+END_SRC



* 21.02.2023

Dzis bysmy sie zajeli tym, zeby komentarze byly uwzgledniane
przy renderowaniu, rozmiaru wyliczaniu i myszki klikaniu.

I to wyglada tak, ze mamy sobie funkcje "traverse",
ktora wywoluje naprzemiennie zadana akcje oraz
metode advance! na obiekcie traversal.


W przypadku rysowania mamy item:draw!,
dla mapowania kursora mamy item:cursor-under*
natomiast przy wyliczaniu 'extent' nie mamy
zadnej akcji, ale mamy okreslona funkcje
zwracajaca.

I teraz: tutaj nic nie bedziemy zmieniac.

Musimy tylko zaktualizowac metody wewnatrz
Space:
- draw!
- cursor-under*
- advance!

* 20.02.2023

No dobra, wydaje sie, ze edycje z klawiatury mamy
jakos tam zaimplementowana.

Moze finalnie bedzie trzeba wprowadzic jakas
dywersyfikacje dla delete-forward! i delete-backward!
(zeby kursor lepiej sie zachowywal)

No, ale teraz zajelibysmy sie juz innymi sprawami:
- po pierwsze, renderowaniem komentarzy (i to az w trzech
smakach) oraz nawigowaniem po komentarzach, edycja
komentarzy, ... (czyli mowiac krotko - edycja komentarzy)

- po drugie, obsluga kawowych rozszerzen skladniowych,
tak zebysmy mogli parsowac zrodla GRASP,
a przy okazji zajelibysmy sie obsluga rozszerzen
jako takich, tak zeby moc wyswietlac quote'y,
unquote'y i quasiquote'y, a takze - skoro to juz jest
w jakiejs formie - to moze nasz guzik?

- po trzecie, bysmy wreszcie zrobili to otwieranie
i zapisywanie plikow, scrollowanie widokow oraz
podzial ekranu

- a po czwarte - przywrocilibysmy podsystem gestow

Pozostaje jeszcze kwestia naszego pejperu,
do ktorego chcielibysmy dopisac informacje o tym,
jak ma byc zaprojektowany system gestow,
oraz screenow z rysowania gestow.

No ale tak:
do interfejsu Painter dolozymy metody
-quasiquote!
-unquote!
-quote!
albo cos w tym rodzaju

Chodziloby o to, ze:
- teksty i nawiasy ktore nie sa owiniete w quote'a
  ani unquote-a rysujemy normalnie
- teksty i nawiasy owiniete w jednego quote'a rysujemy
  pogrubione
- teksty i nawiasy owiniete w jednego unquote'a
  rysujemy kursywa

Czy cos. Jakos to sprobujemy pomyslec.

Na razie jednak te komentarze.

Problem jest taki, ze:
- LineComment i BlockComment wymagaja (text)
- ExpressionComment wymaga (space)
- (text) wymaga (space)

Wydaje sie zatem ze moze rzeczywiscie
bedzie trzeba utworzyc jakis interfejs
ktory bedzie w (space), natomiast same
implementacje umiescimy gdzie indziej
(moze w (text) i (primitive))

Natomiast metody, jakich bedziemy potrzebowac,
to:
- print


OK, na razie udalo sie wyodrebnic modul z komentarzami.

I co chcemy dalej?

No, dalej to z pewnoscia chcemy wyswietlac
te komentarze, uwzgledniac je przy wyliczaniu
rozmiarow i przy klikaniu kursorem

Co wiecej: w kliencie terminalowym chcielibysmy
wyswietlac komentarze w ciemniejszym kolorze,
zas w klientach graficznych uzyc do tego celu
jakiejs smiesznej czcionki.

I moze tym bysmy jutro sie zajeli, a pozniej
dodali do operacji edycji mozliwosc odkomentowywania
i zakomentowywania wyrazen oraz dodawania blokow
komentarzy i zakomentowywania linii


* 18.02.2023

*bold*
/italic/
#+BEGIN_SRC

                                                    
 define  map f l                                    
                                                    
                                                    
    march l                                         
                                                    
                                       
           h   t      f h   map f l     
                                     
                                            
                                              
                                              


                                   
 define  map f l                   
                                   
                                   
  match l                          
                                   
                             
                             
          |                  
                           
    head    f head         
    ____   _______ ____    
                           
    tail    map f tail     
                           









    /    
#+END_SRC

Pomalu sobie pomysliwamy
zeby quote i quasiquote implementowac
jako rozszerzenia (tyle ze musialyby byc
dostepne i wstawiane podczas parsowania)

* 17.02.2023

Wiele bledow udalo sie wczoraj naprawic, ale na pewno
sa tez takie, ktorych nie udalo sie znalezc ani obsluzyc.

Co nam teraz pozostaje:
- zrobmy tego delete-forward!
- poprawmy parser tak, zeby zamiast '() wstawial
  (empty) - tam gdzie powinien

To sa jednak rzeczy do scommitowania w kolejnym tygodniu
(choc zrealizowac je mozemy juz dzis)

Natomiast w weekend bysmy sie zajeli uzupelnieniem
ELSowego pejpera o referencje i kody CCS (na pewno
trzeba tez dodac medc.mark.dev i ewentualnie Bochser
oraz ten drugi GRASP)

OK, czyli moze na poczatku przyszlego tygodnia by sie
udalo miec delete-character! i tematyke edycji z grubsza
zamknieta (modulo ewentualne bugi)

Natomiast w dalszej kolejnosci mamy:
- obsluge komentarzy
- obsluge specjalnej skladni
- otwieranie i zamykanie plikow
- scrollowanie ekranu
- dzielenie ekranu

Zakladamy, ze to minimum do ELS (choc oczywiscie
mozemy sie pomylic), a jesli tak, to moze sie jeszcze
uda:

- mechanizm rozszerzen (we wszystkich klientach)
- rozszerzenie Button
- obsluga gestow (glownie a Androidzie, ale wszedzie
  indziej czemu nie?)

Natomiast celowalibysmy w to, zeby te funkcjonalnosci
byly juz implementowane w samym GRASPie.

* 16.02.2023

Ostatni przypadek testowy wykazal problem z robieniem "undo!"
merge'a, wiec to nim bysmy sie dzis zajeli.

Poza tym sprobowalibysmy przetestowac operacje na tekscie,
a jezeli czas pozwoli, to rowniez bysmy sprobowali
zrobic delete-backward!

OK, z tym merge'owaniem to sprawa wydaje sie nieco grubsza,
bo wyglada na to, ze operacja inverse nie dziala prawidlowo

Byc moze jednak bedzie to okazja do tego, zeby usunac
pole "document" z wiekszosci operacji edycji.

Ale bedzie trzeba albo dodac dodatkowe pole do

#+BEGIN_SRC
(SplitElement with: Space
              at: Cursor := (the-cursor)
	      in: pair := (the-document))
#+END_SRC

badz

#+BEGIN_SRC
(MergeElements removing: Space
               at: Cursor := (the-cursor)
               in: pair := (the-document))
#+END_SRC

albo moze tak:

#+BEGIN_SRC
(SplitElement with: Space at: Cursor)
(MergeElements removing: Space after: Cursor)
#+END_SRC

tak zeby

#+BEGIN_SRC
(inverse (MergeElements removing: Space after: Cursor))
= (SplitElement at: Cursor with: space)
#+END_SRC

* 15.02.2023

Mamy zrobione wstawianie znakow w atomy
i to jako tako dziala.

Ale duzo rzeczy jeszcze nie dziala, wiec
plan jest taki, ze:

- chcemy popisac troche testow dla funkcjonalnosci,
ktora mamy, i dla tej, ktorej jeszcze nie mamy

- zrobic scalanie historii kasowania znaku
  (analogicznie do scalania historii dodawania
  znaku)

- oraz naturalnie zaimplementowac
  delete-forward!

Commity moga byc robione dopiero dzis i jutro,
a nastepny w niedziele, dlatego byloby super
zamknac do jutra kwestie zwiazane z edycja.

* 13.02.2023

Wczoraj udalo sie zrealizowac (1). Dzisiaj
bysmy sie sprobowali zajac (2).

Ale trzeba ustalic nieco szczegolow, bo
zasadniczo chcemy, zeby kursor zachowywal
sie poprawnie, tzn. zeby operacja "redo!"
po wykonaniu "undo!" dzialala tak jak wczesniej.

Ale czy rzeczywiscie musimy sie tym martwic?
Operacje zapamietuja sobie przeciez polozenie
kursora, na ktorym operuja.

No dobra, spojrzmy zatem na [[analiza-edycji]] (28.01.2023)

* 12.02.2023

Na razie napisalismy wiekszosc pejpera - zostaly
nam jeszcze tylko referencje i kategoryzacje.

Natomiast teraz chcemy:
1. wyjasnic dlaczego jak dodajemy [] do "toplevelu",
to kursor jest zle pozycjonowany

2. zaimplementowac delete-backward! z obsluga historii

3. zaimplementowac delete-forward!?


* 09.02.2023

Wczoraj udalo sie poprawic blad w historii. Natomias
wczorajsze cele zasadniczo pozostaja w mocy, ale
do tego dochodzi jeszcze poprawienie edycji stringow.

* 08.02.2023

Dzisiaj na pewno chcemy przebadac i naprawic system
"undo!", i jakby sie udalo, to takze zaimplementowac
delete-backward! i zastanowic sie, co zrobic z
delete-forward!.

Mozna tez juz pomalu myslec o zgloszeniu na ELS.

* 07.02.2023

Teraz rzeczy do zrobienia:
- optymalizacja historii: chcemy scalac ze soba operacje
InsertCharacter o ile naleza do tej samej klasy
(czyli dodawanie spacji albo dodawanie nie-spacji)
no i oczywiscie spelnione sa warunki ciaglosci kursora.

To jedna rzecz.

Druga rzecz, to chcemy przetestowac czy operacje
dzielenia i scalania atomu dobrze dzialaja.

Trzecia rzecz wreszcie, to chcemy zaimplementowac
operacje kasowania.

* 06.02.2023

Mamy mala zagwozdke dotyczaca tego, w jaki sposob reprezentowac
usuwanie znaku w sytuacji, gdy robimy delete-forward! - ale
to na szczescie jeszcze nie jest palaca kwestia.

No dobra, dzis zajelibysmy sie tym:
- jezeli jestesmy na granicy atomu (lewej albo prawej)
  i wstawiamy bialy znak, to InsertCharacter powinien
  dotyczyc nie tego atomu, tylko graniczacej spacji
- Space powinno implementowac Textual
- jezeli wstawiamy bialy znak do srodka atomu, to powinnismy
  wygenerowac operacje Split, natomiast jezeli kasujemy
  spacje z wnetrza atomu, to powinnismy wygenerowac operacje
  Join

I taki oto jest plan na dzis.

No i OK. I teraz mamy takie cus:

#+BEGIN_SRC
(define-interface Textual ()
  (insert-char! c::char index::int)::void
  (delete-char! index::int)::char
  (char-ref index::int)::char
  (truncate! length::int)::void
  (subpart start::int)::Textual
  (text-length)::int
  )
#+END_SRC

Natomiast po stronie spacji to mamy metody:
- insert-space!
- insert-break!
- delete-space!

oraz funkcje
- insert-space!
- insert-break!
- insert-whitespace!
- delete-space!
- join-spaces!
- split-space!

Dobrze by bylo, gdybysmy przynajmniej pojeciowo
sprobowali sobie zmapowac, czy tez wypowiedziec
relacje, pomiedzy join-spaces! oraz split-space!,
a metodami subpart oraz truncate! interfejsu
Textual.

Otoz: subpart i truncate! sa uzywane w funkcji
insert! w przypadku dzielenia atomu.

Czyli teoretycznie funkcje "split-space!" moglibysmy
zaimplementowac analogicznie.

Ale jednak pomysl mamy duzo lepszy - usunmy
funkcje subpart i truncate, i zamiast nich
stworzmy metode split!

OK, to mamy:
- metode split! zamiast truncate! i subpart w Textual
- Space jako instancje Textual


* 04.02.2023

Wczoraj udalo sie wprowadzic InsertCharacter i RemoveCharacter
- tzn dodawanie znakow do obiektow Textual - ale koszt tego
przedsiewziecia byl taki, ze teraz mamy zepsuta obsluge spacji.

Wydaje sie tez, ze chcielibysmy:
- uzywac nowej metody (cursor) do wyliczania polozenia
kursora
- usunac reczne manipulacje kursorem z kodu
- moze bysmy zrobili tak, ze po prostu funkcja apply!
bedzie zwracala kursor, i usunelibysmy metode
(cursor)?


* 03.02.2023

wczorajszy plan o refaktoryzacji "Extract" pozostaje w mocy.
Ale do tego dochodzi jeszcze kilka pomyslow:

- na razie wydaje sie, ze probujemy zrobic takie cos:
  edycja: wcisniecie klawisza -> dispatching -> dodanie operacji
  -> wykonanie operacji -> dispatching -> wlasciwa edycja
  cofanie: wybor operacji -> dispatching -> wlasciwa edycja

  gdzie "wykonanie operacji" to albo "insert!" albo "extract!",
  natomiast historyczne operacje to Insert albo Remove.

  Mozna rozwazyc, czy nie lepiej po prostu miec operacje
  InsertExpression i RemoveExpression, albo moze zostawmy
  juz to i zamiast tego dodajmy InsertCharacters oraz
  RemoveCharacters, a takze SplitElements i MergeElements

Ale moze na razie to olejmy? Niech sobie bedzie ten
podwojny dispatching.

Byc moze tez bysmy chcieli sprawic, zeby Space bylo Textual
(ale akceptowalo tylko #\space i #\newline)?

Na razie olewamy.

No OK, wyglada na to, ze problemem jest to, ze odwrotnosc
"Insert" w przypadku znakow nie dziala najlepiej.

Dlatego moze dodamy operacje InsertCharacter i RemoveCharacter

OK, one zostaly dodane.

Teraz jednak wydaje sie, ze bylby sens, zeby Space
byl Textual.

* 02.02.2023

kilka planow na dzis:
- zrefaktoryzowac extract! w taki sposob, zeby biezacy
  "extract!" stal sie "extract-from-cell!" albo cos takiego,
  natomiast "glowny" extract! zeby dispatchowal:
  1. jezeli rodzicem wyrazenia jest pair?, to wywolujemy
     extract-expression-from-cell!
  2. jezeli docelowym wyrazeniem jest atom, to wywolujemy
     extract-character-from-atom!
  3. jezeli docelowym wyrazeniem jest text, to wywolujemy
     extract-character-from-text!
 (4. jezeli idzie o rozszerzenia, to na razie nie wiemy
     co robic, ale kiedys na pewno wymyslimy)

Trzeba tez bedzie cos pomyslec o refaktoryzacji, bo wydaje sie,
ze niektore rzeczy sa niepotrzebnie rozbite na (document-operations).
(editor-operations) oraz (history) - a wiekszosc operacji w tych
modulach dotyczy edycji dokumentu!

No, ale w praktyce wyszlo tak, ze dodalismy interfejs Textual,
i implementacje w Atom oraz Text.

Jeszcze bysmy chcieli wywalic te funkcje:

#+BEGIN_SRC
(atom-length a::Atom)
(insert-char! c::char a::Atom index::int)
(delete-char! a::Atom index::int)
(truncate-atom! a::Atom length::int)
(atom-subpart a::Atom start::int)
#+END_SRC

i zastapic je uzyciem metod interfejsu.

* 01.02.2023

Dzis bysmy sie zajeli tym, zeby "undo!" i "redo!" przy dodawaniu
spacji i pojedynczego znaku dzialalo poprawnie

Zaczniemy od pojedynczego znaku.

Nie ma problemu z dodawaniem znaku, poniewaz ten przypadek
obsluzylismy w funkcji "insert!".

Jednak funkcja "extract!" zostala przemianowana z funkcji
"take-cell!", ktora zawierala w sobie zalozenie, ze dotyczy
wyodrebniania elementow z komorek.

Teraz bedziemy chcieli odejsc od tego zalozenia.

Tzn. moze w okreslonych warunkach biezaca funkcja bedzie
sie nazywac "extract-from-cell!"

Powinnismy natomiast okreslic warunki wyodrebniania.

(extract! at: cursor from: document)

zasadniczo dziala w taki sposob, ze wyrazenie
znajdujace sie pod kursorem zostaje wyodrebnione.

I teraz tak: jezeli kursor jest "pelny", to

#+BEGIN_SRC
(eq? (the-expression at: cursor)
     (the-expression at: (cdr cursor)))
#+END_SRC

Czyli zasadniczo sprawdzamy, kto jest rodzicem naszego elementu:
- jezeli jest to para (a nasz element to nie spacja)
  to wywolamy "extract-tile-from-cell!"
- jezeli jest to atom, to usuwamy znak i zwracamy go
- jezeli jest to spacja, to zwrocimy albo nowa linie, albo
  znak spacji - chyba ze spacja jest pusta, wtedy
  albo scalamy elementy (jesli mozemy), albo nic
  nie robimy

No dobra, czyli przychodzi nam do glowy kolejna para operacji:

(SplitElement at: Cursor with: Space)
(MergeElements at: Cursor removing: Space)

ktore jednak mozna uznac za

(Remove element: Space from: Cursor)
(Insert element: Space at: Cursor)

* 31.01.2023

Musimy dokonac analizy intelektualnej problemu kursora
i historii.

Wydaje sie bowiem, ze mamy dwa rodzaje operacji:
drag&drop, ktory nie powinien wplywac na polozenie
kursora (a moze moze?) oraz edycje z klawiatury,
ktora ewidentnie wplywa na polozenie kursora

Byc moze latwiej bedzie zalozyc, ze drag&drop
rowniez wplywa na polozenia kursora (bo zasadniczo
to sie wydaje nie miec znaczenia), i ze zawsze
umieszczamy kursor za dodanym elementem
albo przed usunietym elementem.

-----

#+BEGIN_SRC

[Insert element: (f) at: (1 2 1 1)]
[Insert element: ('i') at: (1 3 1 1)]

===>
[Insert element: (fi) at: (1 2 1 1)]
[Insert element: ('n') at: (2 3 1 1)]

===>
[Insert element: (fin) at: (1 2 1 1)]
[Insert element: ('e') at: (3 3 1 1)]

===>
[Insert element: (fine) at: (1 2 1 1)]

#+END_SRC


Warunek jest taki:
- jezeli ostatnia operacja to wstawienie atomu A
dlugosci L na pozycji (_ n . x), a kolejna operacja
to wstawienie znaku C na pozycji
(L (+ n 1) . x), to zmieniamy operacje w historii
tak, ze jest to dopisanie symbolu AC na pozycji (_ n . x).


* 30.01.2023

OK, to teraz:
- albo piszemy testy jednostkowe
- albo probujemy implementowac poszczegolne
  funkcjonalnosci (pamietajac o zaimplementowaniu
  undo! i redo! oraz o polozeniach kursora)

Wydaje sie tez, ze trzeba przemyslec sprawe
zachowania kursora w kontekscie operacji
historycznych oraz drag&dropa.

Co do drag&dropa to mamy pewna koncepcje.


* 28.01.2023

<<analiza-edycji>>

Plan na teraz jest taki:
1. wypisujemy sobie wszystkie operacje dopuszczalne
  z klawiatury (na razie bez rozszerzen, ktore wszelako
  dodamy pozniej)
2. dla kazdej takiej operacji piszemy "test jednostkowy",
uwzgledniajacy rowniez operacje "undo!" i "redo!"
3. poczatkowo napiszemy po prostu duzo testow jednostkowych,
ale wiekszosc z nich pozostanie zakomentowana
4. bedziemy powoli dodawac funkcjonalnosci, odkomentowujac
poszczegolne testy - ale przy tym bedziemy uwazac, zeby
kod pozostal w miare ladny i elegancki, wiec nie bedziemy
sie spieszyc

A kiedy to sie uda zrealizowac, to wowczas zajmiemy sie
trawersowaniem i nawigowaniem po komentarzach oraz obsluga
pelnej skladni Kawy uzytej w implementacji GRASP, zeby dalej
moc edytowac GRASPa z poziomu niego samego.

Poniewaz zas zbliza sie luty, bedzie trzeba sie zajac
napisaniem zgloszenia na ELS.

No dobra, to teraz lista (albo tabela?)

Zacznijmy od tego:

A. insert-char!

  1. jezeli element pod kursorem to tekst, to po prostu
     wstawiamy znak do tego tekstu i zwiekszamy wierzcholek
     kursora o 1

 (2. analogicznie, jezeli element pod kursorem to rozszerzenie,
     to przekazujemy znak do rozszerzenia (i to juz ewentualnie
     rozszerzenie zajmuje sie kursorem))

  3. jezeli wstawiany znak to #\[, to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to
     tworzymy nowe pudelko
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym pudelkiem
   (c. docelowo: jezeli mamy wybrana selekcje, to owijamy selekcje
     w pudelko)

  4. jezeli wstawiamy znak #\", to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to
     tworzymy nowy Text
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym Textem

  5. jezeli wstawiamy spacje albo nowa linie, to:
    a. jezeli jestesmy na spacji, to odpowiednio powiekszamy spacje
    b. jezeli jestesmy na atomie, to dzielimy atom i dodajemy spacje

  6. jezeli wstawiamy atomowa litere w spacje, to tworzymy nowy atom

  7. jezeli wstawiamy atomowa litere w atom, to po prostu dopisujemy
     te litere do atomu (scalajac odpowiednio operacje Insert)


B. delete-backward!

  1. jezeli jestesmy na lewej krawedzi spacji za nawiasem
     zamykajacym, to kasujemy cale wyrazenie zamykane przez
     ten nawias
  2. jezeli jestesmy na lewej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawwiasy
  3. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta, kasujemy
        wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
     (od prawej strony)
  4. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na lewej krawedzi spacji za atomem, to
     usuwamy ostatni znak z tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja poprzedzajaca
     ten atom
  6. jezeli jestesmy wewnatrz spacji, to kasujemy poprzedzajaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak przed
     kursorem. Jezeli przed kursorem nie ma zadnego znaku,
     to usuwamy spacje przed atomem, chyba ze ta spacja jest
     zerowa - wowczas scalamy biezacy atom ze wczesniejszym
     atomem
  8. jezeli jestesmy na lewej krawedzi atomu i przed atomem
     jest nawias zamykajacy (oraz pusta spacja), to kasujemy cale
     wyrazenie
  9. jezeli jestesmy na lewej krawedzi atomu albo niepustej spacji
     za nawiasem otwierajacym, to nic robimy

C. delete-forward!

  1. jezeli jestesmy na prawiej krawedzi spacji przed nawiasem
     otwierajacym, to kasujemy cale wyrazenie otwierane przez
     ten nawias
  2. jezeli jestesmy na prawej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawiasy
  3. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta,
        kasujemy to wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
       (od lewej strony)
  4. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na prawej krawedzi spacji przed atomem,
     to usuwamy pierwszy znak tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja znajdujaca
     sie za tym atomem
  6. jezeli jestesmy wewnatrz spacji, to kasujemy nastepujaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak za kursorem.
     Jezeli za kursorem nie ma zadnego znaku, to usuwamy spacje
     za atomem, chyba ze ta spacja jest zerowa - wowczas scalamy
     biezacy atom z nastepujacym atomem

  8. jezeli jestesmy na prawej krawedzi atomu i za atomem
     jest nawias otwierajacy (oraz pusta spacja), to kasujemy
     cale wyrazenie
  9. jezeli jestesmy na prawej krawedzi atomu albo niepustej
     spacji przed nawiasem zamykajacym, to nic nie robimy


* 26.01.2023

Odkrylismy, ze klawisze w kliencie terminalowym nie sa
obslugiwane poprawnie, i mozemy sie sprobowac zajac
ich naprawa.

OK, to juz zrobione.

I co daley?

Trzeba w jakis sposob usystematyzowac edycje. Ogolnie
mamy dwie kwestie:
- modyfikacja dokumentu
- modyfikacja polozenia kursora

Do tego dochodzi nam jeszcze kwestia "odwracalnosci operacji",
w tym - w szczegolnosci - odwracalnosc operacji kasowania
(oraz scalanie operacji edycji na poziomie znaku w historii)

Dobrze by bylo rowniez rozprawic sie z kwestia reprezentacji
selekcji, bo aktualnie wydaje sie, ze (the-selection-anchor)
nie dziala zbyt dobrze.

Wreszcie byloby doskonale, gdybysmy mieli pelna obsluge selekcji.
Ale wydaje sie, ze to nie na teraz.

Ogolnie musimy tez pamietac, ze oprocz edycji z klawiatury
oraz wsparcia dla komentarzy, chcielibysmy tez w jakis sposob
reprezenotwac quote'y i unquote'y.

Natomiast w kwestii najpredszych zmian, warto byloby dodac
kolorowanie wybranego nawiasu, i warto by bylo tez obsluzyc
podswietlanie nawiasu na ktorym znajduje sie kursor.

* 25.01.2023

Wczoraj sie udalo zrobic dopisywanie znakow do atomow.
Dzisiaj natomiast zajelibysmy sie spacjami i nowymi liniami.

Chodzi zasadniczo o to, ze:
- znak spacji lub nowej linii na poczatku albo na koncu atomu
  powinien zostac dodany do przylegajacej spacji
- znak spacji lub nowej linii wewnatrz atomu powinien spowodowac
  przelamanie tego atomu
- znak spacji albo nowej linii wewnatrz spacji powinien
  pozostac w tej spacji
- znak spacji albo nowej linii wewnatrz Textu powinien
  po prostu zostac do niej odpowiednio dodany

Takie rzeczy chcielibysmy zaimplementowac, ale tez przy okazji
pojawia sie perspektywa refaktoryzacji - chodzi o to, czy
nie daloby sie zrobic tak, zeby to box, albo spacja, albo tekst
decydowaly o tym, w jaki sposob sie zachowac - bo ostatecznie
rozszerzenia powinny rowniez byc w stanie obslugiwac inputy
na swoj sposob.

---

po dzisiejszym dniu nasuwa sie kilka uwag:
1. dziwne zachowanie kursora
2. (the-selection-anchor) to upierdliwy mechanizm,
bo trzeba sie nim zajmowac przy kazdej aktualizacji kursora
3. chcielibysmy miec symetrie pomiedzy dodawaniem i usuwaniem
4. mamy kilka dziwnych bledow


* 24.01.2023

Ponizej jest sobie costam jakos tam napisane.

Natomiast tym, na czym zalezy nam przede wszystkim,
sa testy jednostkowe w test-editor-operations.scm.

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone - zmienic nazwe na "extract-from-box!"?

2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu pierwszego
     czyli:
     - merge-boxes!
     - merge-atoms!

4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
     - merge-texts!
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

1. insert! [lista do spacji]
   - wyodrebnic "insert-into-box!"
2. insert! [spacja do atomu]
   - rozbijamy atom na dwa -
3. insert! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. insert! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. insert! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem



* 23.01.2023

Musimy dodac obsluge wstawiania spacji w spacje
do procedury insert!, jak rowniez obsluge pozostalych
sytuacji, takich jak:

- wstawienie znaku w Atom
- wstawienie znaku w Text
- wstawienie spacji/nowej linii w Atom
- wstawienie spacji/nowej linii w Text

Z pewnoscia chcemy tez napisac testy jednostkowe


* 22.01.2023

Mini-plan jest taki, zeby przeniesc funkcje
delete-forward!, delete-backward!, insert-character!
oraz delete! do primitive-terminal-client!
i dodac im przedrostek np. old!, tak zebysmy
mieli do nich dostep, ale zebysmy mogli zaczac
pisac nasze funkcje od poczatku.

Rzecz w tym, ze chcielibysmy, zeby te nowe funkcje
byly juz zaposredniczone w historii.

No ale. Plan na jutro rano jest taki, zeby:
- scommitowac zminy nazw z take-cell! na extract!
oraz ze splice! na insert!
- scommitowac przeniesienie funkcji z editor-operations
do primitive-terminal-client oraz nadanie przedrostka /old/
- zaczac pisac implementacje dla insert-character!
(i zmodyfikowac domyslna funkcje keymap tak, zeby
wywolywala insert-character!)


* 21.01.2023

No, to teraz mozemy radosnie
dodawac nowy ficzer edycji do GRASPa.

Najogolniej rzecz biorac, chcemy, zeby
wcisniecie klawisza powodowalo domyslnie
wywolanie

#+BEGIN_SRC

(insert-character! (unicode-input)
             into: (the-document)
               at: (the-cursor))
#+END_SRC

	       
gdzie:
- jezeli input to lewy nawias i jestesmy na spacji,
tworzymy nowe pudelko
- jezeli input to prawy nawias i jestesmy na lewym nawiasie,
atomie albo spacji, to idziemy do nastepnego zamykajacego nawiasu

dosc obszerna analize do przetrawienia mamy napisana
6 stycznia.

najblizsze commit w poniedzialek; programowanie
na telefonie jest duzo dostepniejsze, ale
na laptopie komfort pisania jest nieporownywalnie
lepszy.

OK, to z takich bardziej podstawowych rzeczy:
- chcemy zmienic nazwy z take-cell! na extract!
i ze splice! na insert!
(nie do konca juz pamietamy, dlaczego chcemy,
ale mimo wszystko nadal chcemy?)

W kazdym razie nazwy zostaly juz zmienione.

No i co dalej?

Moze bysmy usuneli:
- primitive-terminal-client
- funkcje "delete-forward!", "delete-backward!"
  oraz "insert-character!" z (editor-operations),
  zeby je moc zaimplementowac od nowa?

Nooo, tyle ze tam juz jakas funkcjonalnosc jest.

Mozemy zatem albo przeprowadzic analize tego,
co juz mamy, albo - w oparciu o wczesniejsza analize
- zaprojektowac to, co powinnismy miec.

Co dziwne, wydaje sie, ze niektore rzeczy
dzialaja.

* 19.01.2023

pozostale dwa punkty ze wtorkowej listy odhaczone

* 18.01.2023

pierwsy punkt z wczorajszej listy odhaczony.
teraz nam pozostaje dodac extend-selection
(usuwajac tego przykrego enuma)

* 17.01.2023

zadania na dzis/jutro:
- przetestowac desktop-client na asusie
  (i ew. ponaprawiac)
- uzupelnic mapy klawiatury
- dodac (shift left) oraz (shift right) jako ekspansje selekcji

* 14.01.2023

zbudowalismy juz zalazki map klawiatur dla
trzech klientow

teraz bysmy chcieli usunac stare zdarzenia
z modulu pane, i zastapic je nowymi

- bedzie to wymagalo translacji kodu
  zdarzenia do odpowiedniej postaci
  (w tym ustawienia parametru (unicode-input)
  tam gdzie to stosowne)

  w przypadku kazdego klienta bedzie to trzeba
  robic inaczej, i dlatego nalezy ustalic jakas
  kolejnosc:
  - najpierw klient terminalowy
  - po nim klient androidowy
  - a na koncu klient desktopowy
    (ktotego i tak nie mamy na razie jak
    przetestowac)

natomiast plany dlugofalowe:
+ skonczyc ta refaktoryzacje
+ zaimplementowac edycje
+ obsluga komentarzy (renderowanie i nawigacja)
+ obsluga uzytych rozszerzen Kawy/rezygnacja z nieuzytych rozszerzen
+ ladowanie i zapisywanie plikow; podzial ekranu
+ zgloszenie na ELS
+ mechanizm rozszerzen
+ poszczegolne rozszerzenia + sukcesywny rozwoj API do rysowania
+ evisulator
+ edytor grafow
+ obsluga selekcji (kopiowanie, wklejanie, usuwanie, historia)
+ naprawianie bledow (w tym zwiazanych z drag&dropem)
+ prezentacja na ELS
+ pierwsze wydanie, 2 aplikacje w sklepie
+ zgloszenie na StrangeLoop
+ siec spolecznosciowa

+ SICP - GRASP edition
+ The Little Schemer - GRASP edition
  (i podobnie: The Seasoned Schemer, The Reasoned Schemer)
+ The Dream Machine - GRASP edition
+ The Way Things Work - GRASP edition

+ The Art of Metaprogramming in Scheme

ok, tosmy sobie odplyneli

teraz do roboty: zmieniamy sposob obslugi
klawiszy w kliencie terminalowym - ale trzeba
jeszcze pomyslec co z obsluga myszy/wskaznikow

ok, klient terminalowy juz obskoczony.
teraz jeszcze tylko zostaje androidowy i desktopowy.

na razie sie zajmiemy androidowym

ok, wyglada na to ze to tez sie udalo.


* 13.01.2023

Mamy sobie 3 klienty. I teraz dla tych
3 klientow bedziemy chcieli zbudowac
moduly (android-key-map) (desktop-key-map)
oraz (teminal-key-map).

* 12.01.2023

No dobra, to teraz - zeby byla jasnosc - zaczynamy
od uwspolnionego systemu obslugi zdarzen, w ktorym
bedzie tylko zdarzenie 'key-typed', a funkcje beda
definiowane w pliku init.scm.

Na razie nie robmy hierarchicznej obslugi, bo to
moze byc overengineering.

Dopiero jak to bedzie gotowe, zajmiemy sie 'wstawianiem
znakow', ze szczegolnym uwzglednieniem aspektu historii
/cofania.

* 11.01.2023

trzeba obmyslic strategie implementacji
nowego podsystemu wprowadzania

W androidzie mamy:
getKeyCode(), getScanCode(), getMetaState()


w androidzie chcemy zmienic podsystem zdarzen
tak zeby na razie po prostu wypluwal zdarzenie
do logow

#+BEGIN_SRC

(active-pointers) ::(list-of int)

(pointer-position index::int) ::Position

(unicode-input)::char
#+END_SRC

w KeyboardEvent z awt mamy metode getKeyChar,
ktora zwraca kod albo CHAR_UNDEFINED.

#+BEGIN_SRC
(define-mapping (key-handler key-code)::(maps () to: void)
  (lambda ()::void
    (and-let* ((c (unicode-input)))
      (insert-character! c))))
#+END_SRC

Jeszcze trzeba rozwazyc opcje dodawania trybow,
tak zeby mozna bylo przeslaniac sobie tablice znakow
w roznych kontekstach.

#+BEGIN_SRC

(define-type (KeyMap bindings: (maps (key::int) to: () to: void)
                     parent: KeyMap))
#+END_SRC

* 10.01.2023

Wczorajszybi dzisiejszy dzien to glownie
walka z ewaluacja w kliencie androidowym
(i to trzeba odnotowac)


Jutro j pojutrze beda comity:
- ocpowiedziec na issue
- commitnw grasp-android

- zarchiwizowac grasp-android
- scomitowac zmiany tutaj

Na razie plan jest taki, ze chcemy
ujednolicic konfiguracje po stronie
androida, terminala i awt, szukajac
najwiekzzsgo wxpolnego mianownika

nastepnie bysmy te konfiguracje
przeniesli do init.scm

nastepnie bysmy juz zaczeli walke
z podpinaniem funkcji do edycji
dokumentu

fajnie by bylo to zrobic do konca
stycznia - i jeszcze obsluge
komentarzy w rendererze, oraz
otwieranie i zapisywanie plikow
oraz podzial ekranu

na pewno tez troche pracy bedzie
trzeba poswiecic zeby dopiescic
klienta awt

na dalszy ogien idzie mechanizm
rozszerzen oraz ewaluacja wyrazen
roraz juz partykularne rozszerzenia
(Img src: ...), wizualny ewaluator,
edytor grafow, chmura punktow

natomiast priorytetem powinno
byc doproeadzenie do sytuacji
w ktorej GRASP rozwijamy w GRASP,
a nie w Emacsie

----------------------------------

ok, to co teraz robimy?

trzeba bedzie rozehrac zdarzemia
z awt na kawalki

moze warto zrobic tabelke

|---------+------------+-------------+-----------|
| system  | press      | release     | type      |
|---------+------------+-------------+-----------|
| AWT     | keyPressed | keyReleasee | keyTyped  |
|---------+------------+-------------+-----------|
| Lantrna |            |             | readInput |
|---------+------------+-------------+-----------|
| Android | onKeyDown  | onKeyUp     |           |
|---------+------------+-------------+-----------|

Ok, i teraz co?

Teraz musimy odwzorowac klawisze i sekwencje
w ich nazwy. Na przyklad
#+BEGIN_SRC
(on-key '(ctrl alt shit x) cut-selection!)
#+END_SRC

czy cos

i teraz bysmy sobie zrobili takie cos,
ze tlumaczylibysmy sekwencje na wartosc
typu long, i systemy zdarzen w poszczegolnych
klientach robilyby to samo - i mielibysmy
tablice haszujaca, ktora mapuje nam
klawisze na odpowiednie procedury

Poniewaz jednak nie chcemy tracic
dotychczasowej funkcjonalnosci,
moze wypiszmy sobie jakie do tej porg
mielismy wiazania w poszczegolnych
klienach:

** klient terminalowy:

#+BEGIN_SRC

  (set! (on-key-press KeyType:ArrowLeft)
	(lambda ()
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowRight)
	(lambda ()
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowUp)
	move-cursor-up!)

  (set! (on-key-press KeyType:ArrowDown)
	move-cursor-down!)

  (set! (on-key-type #\x) exit)

#+END_SRC
  
** klient desktopowy

#+BEGIN_SRC

  (set! (on-key-press KeyEvent:VK_LEFT)
	(lambda _
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_RIGHT)
	(lambda _
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_UP)
	move-cursor-up!)

  (set! (on-key-press KeyEvent:VK_DOWN)
	move-cursor-down!)

  (set! (on-key-press KeyEvent:VK_Z)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:undo!)))))

  (set! (on-key-press KeyEvent:VK_Y)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:redo!)))))

#+END_SRC

** klient androidowy:

#+BEGIN_SRC
    (set! (on-key-press KeyEvent:KEYCODE_DPAD_LEFT)
      (lambda _
	(move-cursor-left!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_RIGHT)
      (lambda _
	(move-cursor-right!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_UP)
      move-cursor-up!)

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_DOWN)
      move-cursor-down!)
#+END_SRC

* 09.01.2023

wyglada na to, ze mamy takie problemy
implementacyjne:
- w wersji skompilowanej, init.scm musi
  ladowac moduly, z ktorych korzysta
- ale trzy klienty beda musialy definiowac
  on-key na swoj sposob
- ale czy rzeczywiscie?

Definicja on-key bedzie taka sama, tylko
sposob wywolania bedzie rozny.

Teraz trzeba:

- usunac key-pressed! i key-released! z (panel),
  moze tez zmienic nazwe na (pane)

- zrobic jakos tak, zeby wywolywac odpowiednia
  funkcje dla kazdego klienta

* 08.01.2023

plan jak na razie wyglada zacnie.

jego realizacje zaczelibysmy od tego, ze kazdy
klient wykonywalby plik init.scm - na poczatku
to moze byc po prostu wypisanie loga albo cos.

co wiecej, zmiany w kliencie desktopowym
i terminalowym mozemy robic na laptopie

* 07.01.2023

Usunelismy funkcje "insert!", ale jest pewien
problem z testowaniem - na telefonie mozemy
jedynie przetestowac dzialanie aplikacji
na telefon.

Poza tym jest jeszcze kwestia taka, ze chcielibysmy
zbudowac przenosny interfejs wwjscia/wyjscia
pomiedzy klientami - cos w rodzaju

#+BEGIN_SRC
(on-key '(ctrl z) undo!)

(on-key '(ctrl y) redo!)

i wowczas bysmy sobie zdefiniowali:
#+END_SRC

#+BEGIN_SRC
(on-key 'space insert-space!)

(on-key 'backspace delete-backward!)

(on-key 'delete delete-forward!)

(on-key 'enter insert-newline!)

(on-key 'left move-cursor-left!)

(on-key '(shift left) expand-selection-left!)

(on-key 'right move-cursor-right!)

(on-key '(shift right) expand-selection-right!)
#+END_SRC
Mielibysmy tez takie funkcje:

#+BEGIN_SRC
(active-pointers) ::int

(pointer-position index::int) ::Position

(unicode-input)::char
#+END_SRC


Bedziemy chcieli miec plik init.scm, zawierajacy
powyzsze definicje.

Od strony implementacyjniej bysmy chcieli miec:
- bezposrednia tablice
- tablice shift dla klawiszy sterujaych
- tablice ctrl
- tablice alt
- tablice ctrl+alt
- tablice ctrl+shift
- tablice alt+shift
- tablice ctrl+alt+shift

Albo nawet nie. Moze byc jedna tablica.

* 06.01.2023

Idealnie byloby, gdybysmy nie dodawali
zadnych nowych operacji, tylko poprzestali
na Move, Remove oraz Insert.

Dzielenie atomu odbywaloby sie na zasadzie
wstawienia spacji w atom, laczenie - na zasadzie
usuniecia spacji itd.

Trzeba to bedzie sobie rozpisac.
Move -> take-cell!, splice!
Remove -> take-cell!
Insert -> splice!

Trzeba bedzie pozmieniac nazwy:
1. insert! z modulu (history) na cos (to trywialna
   funkcja uzyta w jednym miejscu w (panel))
2. ze splice! na insert!
3. z take-cell! na extract!

I teraz: funkcje (nowe) insert! i extract!
bedziemy musieli zmienic tak, zeby dzialaly
w roznych konfiguracjach

(docelowo do extract! bedziemy chcieli
jeszcze dodac argument numeryczny, tak
zeby moc uzywac tej funkcji do obslugi
selekcji, zas splice! rowniez bedzie
trzeba do tego celu przysposobic)

No dobra, ale teraz chyba bedzie trzeba
rozwazyc

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone: wydobywamy element
     z wnetrza pudelka
2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden3. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu
     pierwszego
4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

i teraz insert! analogicznie:

1. splice! [lista do spacji]
   - juz obsluzone (wklejamy liste pomiedzy element
     poprzedzajacy spacjena kolejny element)
2. splice! [spacja do atomu]
   - rozbijamy atom na dwa
3. splice! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. splice! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. splice! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem

1. extract-tile! at: Cursor from: document
   splice-list! list at: Cursor into: document
2. merge-atoms! at: Cursor in: document
   split-atom! at: Cursor in: document
3. merge-boxes! at: Cursor in: document
   split-box! at: Cursor in: document
4. merge-texts! at: Cursor in document
   split-text! at: Cursor in: document
5. remove-characters! at: Cursor from: document
   insert-charactets! at: Cursor into: document

* 02.01.2023

Dwie pierwsze zmiany w nowym roku:
- archiwizacja grasp-android
- odpowiedziec na "issue" w nowym repo

Natomiast to, czym teraz bysmy sie chcieli
zajac, to edycja dokumentow z klawiatury,
czyli:

- jak piszemy [, to tworzymy nowe puste pudelko
- jak piszemy ]. to wychodzimy z pudelka

W kazdym razie to sie dzieje w kontekscie
pudelek - bo w przypadku Textu dla niesterujacych
znakow zawsze owe znaki dopisujemy (pewnym wyjatkiem
moze byc \, ale to jeszcze trzeba przemyslec)

- jak piszemy ", to tworzymy nowy Text

jak wciskamy znak drukowalny, to:
- jezeli jestesmy na spacji, to tworzymy
  nowy atom
- jezeli jestesmy na atomie, to dopisujemy
  znak

Wyjatki:
- wcisniecie spacji, gdy jestesmy na spacji,
  dodaje spacje pozioma
- wcisniecie entera dodaje spacje pionowa
- wcisniecie spacji albo entera na atomie
  powoduje rozbicie atomu (chyha ze jestesmy
  na ostatniej pozycji - wtedy edytujemy
  nastepujaca spacje)

Trzeba bedzie zaczac od napisanis testow
dla takiego czegos, oraz dodac odpowiednie
operacjendo historii edycji

Rowniez chcielibysmy obsluzyc dzialanie
klawisza backspace.

Jezeli idzie o historie, to mozemy zamodelowac:
- rozszczepienie atomu jako wstawienie spacji
- scalenie atomu jako usuniecie spacji

Dzieki temu nie musimy dodawac nowych operacji
do historii.

Mamy zatem do dodania nastepujace operacje:
