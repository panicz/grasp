* 07.01.2024

No, to teraz probujemy zrozumiec, jak dziala mark-cursor!. Zasadniczo jest tak,
ze sobie rysujemy po kolei elementy wraz ze sledzeniem kontekstu, i jezeli akurat
kontekst jest tozsamy z kursorem, to wywolujemy mark-cursor!.

Do niedawna, jedynym, co "mark-cursor!" robilo, bylo narysowanie prostokata
i zapamietanie pozycji. Tymczasem jednak wywolujemy editor:mark-cursor!
przekazujac (+ traversal:parent-left +left) oraz (+ traversal:parent-top +top).

I owa metoda wydaje sie jako tako dzialac dla atomow oraz stringow, natomiast
dla spacji (z nowymi liniami) juz niekoniecznie.

OK, i dla spacji sie udalo to poprawic. To teraz bysmy sie zajeli nawiasami.

A moze jutro?

* 06.01.2024

Udalo sie jako tako zaimplementowac wyliczanie kolejnej pozycji
na dole (a w kazdym razie tak sie wydaje) - choc nalezaloby to jeszcze
zrobic dla klienta terminalowego.

Mamy jednak jeszcze kilka problemow:
- na spacjach, nawiasach i komentarzach rzecz nie dziala prawidlowo
- momentami kursor znika, i wtedy z tym adjust-view! dzieja sie
dziwne rzeczy

No dobra, to teraz trzeba zobaczyc co sie dzieje jak robimy mark-cursor!
na spacji.

Ogólnie kłopot jest taki, że sam do końca nie rozumiem, 
jak to wszystko działa :/

Być może warto by było się skupić właśnie na zrozumieniu tego?

No dobra, ale rozumiec to se mozna nawet na kiblu na telefonie :P

* 03.01.2023

#+BEGIN_SRC scheme
      (define-syntax-rule (test-that-operation operation
					       #;transforms
					       initial-view
					       #;into
					       final-view)
	(assert (equal? (snapshot) initial-view))
	operation
	(assert (equal? (snapshot) final-view))
	(undo!)
	(assert (equal? (snapshot) initial-view))
	(redo!)
	(assert (equal? (snapshot) final-view)))

      (define-syntax test-edit-sequence
	(syntax-rules ()
	  ((_ initial-view operation final-view . rest)
	   (begin
	     (test-that-operation operation #;transforms initial-view
				  #;into final-view)
	     (test-edit-sequence final-view . rest)))
	  ((_ final-view)
	   (assert (equal? (snapshot) final-view)))))

    (test-edit-sequence "
" (insert-character! #\[ #;#\]) "
╭  ╮
│  │
╰ |╯
" (for-each insert-character! '(#\d #\e #\f #\n #\e)) "
╭       ╮
│ defne │
╰      ^╯
" (times 2 delete-backward!) "
╭     ╮
│ def │
╰    ^╯
" )

#+END_SRC

Wiemy juz, ze to nie zadziala, bo bywaja w kodzie miejsca,
w ktorych opieramy sie na undo. Zatem lepiej byloby zrobic

#+BEGIN_SRC scheme
  (define-syntax-rule (with-undo-redo operation)
    (let ((initial (snapshot)))
      operation
      (let ((final (snapshot)))
	(undo!)
	(let ((reverted (snapshot)))
	  (unless (equal? initial reverted)
	    (fail "Unexpected output after undoing "'operation
		  "\nexpected:\n"
		  initial
		  "\ngot:\n"
		  reverted)))
	(redo!)
	(let ((redone (snapshot)))
	  (unless (equal? final redone)
	    (fail "Unexpected output after redoing "'operation
		  "\nexpected:\n"
		  final
		  "\ngot:\n"
		  redone)))
	final)))
#+END_SRC

* 02.01.2023

Wydaje sie, ze na telefonie nawet nie da sie przeprowadzic
sensownych eksperymentow, ale moze uda sie chociaz dokonac
jakiejs auto-analizy.

Po prostu wyglada na to, ze opieranie sie na pojeciu
wysokosci poprzedniej i biezacej linii to kiepski pomysl.

Zamiast niego chcemy raczej miec 'odleglosc do poprzedniej
/nastepnej linii'. I teraz: w przypadku cofania sie do gory
to raczej nie powinno nam az tak mocno przeszkadzac, bo
ze wzgledu na sama mechanike dzialania musimy tylko uwazac,
zeby odleglosc, o ktora cofamy, nie byla zbyt duza
(moze nawet wystarczy przyjac 1?). Natomiast jezeli idzie
o odleglosc do nastepnej linii, to winna ona byc zdefiniowana
jako roznica pomiedzy biezaca pozycja, a pozycja otrzymana
w wyniku dodania 'wysokosci biezacej linii' do pierwszego
'nie-terminujacego' rodzica

No dobra. To wydaje sie miec sens. Byc moze nawet bedzie
dzialac dla stringow bez zadnych dodatkowych zmian?

Natomiast wydaje sie tez, ze fajnie by bylo rowniez
opracowac zestaw testow do wyrazania pionowego ruchu
kursora, a ponadto uproscic test-editor-operations.

Zamiast

#+BEGIN_SRC scheme
  
  (insert-character! #\[)

  (e.g.
   (snapshot) ===> "
  ╭  ╮
  │  │
  ╰ |╯
  ")

  (undo!)

  (e.g.
   (snapshot) ===> "
  ")

  (redo!)

  (e.g.
   (snapshot) ===> "
  ╭  ╮
  │  │
  ╰ |╯
  ")


#+END_SRC

chcielibysmy miec

#+BEGIN_SRC scheme
      (test-edit-sequence "
    "
			  (insert-character! #\[)

      (surely-the-operation

	   transforms "
	"
	   into "
	  ╭  ╮
	  │  │
	  ╰ |╯
	  "))

  (define-syntax-rule (test-edit-sequence initial-view
					  operation
					  final-view
					  . rest)
    (assert ...)
    operation
    (assert ...)
    (undo!)
    (assert ...)
    (redo!)
    (assert ...)
    (test-edit-sequence final-view . rest))


#+END_SRC

* 01.01.2024

Najsamprzód należałoby wyjaśnić, dlaczego - w sytuacji, gdy klikniemy
myszka na swiezym edytorze, to wyglada na to, ze callback on-end-line 
nie jest wywolywany, a co za tym idzie, current-line-height nie jest
ustawiana. Natomiast gdy najedziemy w to samo miejsce z pozycji spacji,
wydaje sie, ze owa wysokosc jest ustawiana prawidlowo (moze byc jednak
tak, ze wcale nie jest prawidlowo ustawiana, tylko posiada poprzednio
zapamietana wartosc)

Po drugie, gdy jestesmy na spacjach albo nawiasach, to wyglada na to,
ze cursor-column jest ustawiane nieprawidlowo.

Po trzecie, kiedy jestesmy na ostatniej linii wyrazenia, to rzeczywiscie
prawidlowo wyznaczamy wysokosc linii -- ale zamiast tego powinnismy wyznaczyc
pozycje kolejnego wyrazenia.

No bo tak: wydaje sie, ze nasz interfejs WithCursor jest o tyle dobrze
zaprojektowany, ze wymiary (current-line-height, previous-line-height)
sa inwariantne wzgledem przesuniecia polozenia, wiec stanowia najmniejszy
problem podczas uzywania (oczywiscie wymiary sa wyrazone we wspolrzednych
dokumentu)

Natomiast tak naprawde tym, co nas interesuje, nie sa wysokosci linii,
tylko przesuniecia do poprzedniej/nastepnej linii. I tutaj rzecz wyglada
w taki sposob, ze w momencie, kiedy wywolujemy on-end-line, mamy wszelkie
informacje do tego, zeby okreslic, gdzie znajduje sie kolejny punkt.

Tylko ze w takim razie nazwa "current-line-height" nie oddaje adekwatnie
tego, co powinna wyrazac - a powinna wyrazac "odleglosc do nastepnej linii",
czyli "distance to next line", i nazwalibysmy ja to-next-line.

Natomiast te druga wielkosc bysmy nazwali "to-previous-line" - i chociaz
wydaje sie, ze ona zachowuje sie z grubsza poprawnie, jest mozliwe, ze to
nie do konca prawda.

* 19.12.2023

dzis bysmy sie zajeli tym ukladem wspolrzednych - moze tez
by sie udalo wyrzucic metody current-translation-* z Paintera


* 17.12.2023

post-draw-actions zrobione, uklad wspolrzednych do
zrobienia - a po nim trzeba przemyslec co sie ma dziac
z tym traversem

* 16.12.2023

bysmy zaczeli od tego, ze bysmy dodali do edytora
'post-draw-actions' i poprawili uklad wspolrzednych,
w ktorym zachowujemy pozycje kursora

* 14.12.2023

mamy taki problem, ze biezaca metoda nie zawsze dziala

w szczegolnosci, nie dziala gdy chcemy zjechac ponizej
biezacego stringa, ale takze w innych okolicznosciach

innym problemem jest to, ze set-cursor-column! jest
wywolywane przed przerysowaniem ekranu, a nie po
(co daloby sie rozwiazac, wprowadzajac kolejke
funkcji ktore mialyby byc wywolane po rysowaniu)

jednnak nasze dzialania zaczelibysmy od wyrysowywania
na ekranie punktu oznaczonego kursora, i kiedy to bedziemy
mieli, bedziemy kontynuowac prace nad naprawa ruchu
pionowego

* 13.12.2023

dzis/jutro bysmy zaimplementowali traverse w metodach draw-string!
w kliencie androidowym i desktopowym, i uzyli tego do zaimplementowania
nowej nawigacji

i trzeba jeszcze przemyslec kwestie reprezentowania wspolrzednych
w taki czy inny sposob (tzn najpewniej bysmy chcieli je wyrazac
we wspolrzednych dokumentu)

* 12.12.2023

bysmy przeniesli (cursor-column) do WithCursor / CursorMarker
(i dodali set-cursor-column!)

oraz ser-current-line-height!, current-line-height,
set-previous-line-height!, previous-line-height

to teraz bysmy zrobili, zeby zamiast (cursor-column)
uzywac (editor:cursor-column), a po tym, zeby traverse
ustawialo wartosci previous-line-height oraz current-line-height

i dalej: w painterze grasp-desktop i grasp-android mamy metode
draw-text!, a w text painterze - metode draw-string. I chcielibysmy,
zeby te metody wprowadzaly swoj traversal.

* 11.12.2023

nalezaloby wzbogacic interfejs WithCursor o funkcje
mark-cursor! oraz cursor-position.

dobra, to juz zrobione

I co dalej?

Chcielibysmy, zeby rysowanie stringow i komentarzy
wprowadzalo swojego Traverse'a, i chcielibysmy, zeby
wszystkie dane potrzebne do pionowej nawigacji kursora
byly gromadzone w CursorMarker (czyli de facto w edytorze)

I teraz tak:

#+BEGIN_SRC scheme
  (define (move-cursor-up!)
    (let* ((editor ::Editor (the-editor))
	   (current ::Position (editor:cursor-position)))
      (set! (the-cursor)
	    (cursor-under (cursor-column)
			  (- current:top
			     (editor:previous-line-height))))))

  (define (move-cursor-down!)
    (let* ((editor ::Editor (the-editor))
	   (current ::Position (editor:cursor-position)))
      (set! (the-cursor)
	    (cursor-under (cursor-column)
			  (+ current:top
			     (editor:current-line-height))))))
#+END_SRC


Tego cursor-column tez bysmy chcieli zintegrowac z CursorMakerem.

* 10.12.2023

Mamy juz intetfejs Editor (choc na razie bez metody mark-cursor!).

Wiec teraz bysmy dodali mark-cursor! do Editor, i przemianowali
mark-cursor! z paintera na draw-cursor!, i przeniesli
cursor-position i cursor-height do editor.

no niestety wydaje sie, ze tutaj jest problem, bo obsluga kursora
zalezy od klienta, a to jedynie painter jest "client-specific"

a poza tym chcemy zrobic
- zmiane rozmiaru listy pustej
- kopiowanie wyrazen podwojnym tapnieciem
- usuwanie wyrazen szybkim ruchem palca
- drag&drop na komentarzach i tekscie
  
* 08.12.2023

Na razie plan jest taki, zeby:
- stworzyc interfejs Editor jako podtyp Embeddable
- przemianowac dotychczasowy Editor na DocumentEditor
- dodac metode 'mark-cursor!' do interfejsu Editor

Musimy sobie mniej wiecej wyobrazic co sie wtenczas powinno dziac.

A konkretnie: podczas renderowania wywolujemy
(the-editor):mark-cursor!, ktory z kolei powinien
wywolac painter:draw-cursor!.

Metody "mark-cursor!" oraz "cursor-position" powinny
zostac przeniesione do edytora. 

* 07.12.2023

No to teraz musimy sobie wyobrazic jak bysmy chcieli, zeby to bylo
wszystko zrobione.

Otóż byśmy chcieli, żeby wywoływać ((the-editor):mark-cursor!),

* 06.12.2023

No dobra, to mamy kilka zagwozdek.

Jezeli idzie o poruszanie kursorem w gore i w dol,
to sprawy maja sie tak, ze:
- jak robimy traverse, to licza sie tylko listy i atomy

Wydaje sie, ze w tej dziedzinie nasza nowa metoda mialaby
nawet szanse zadzialac

* 05.12.2023

Przeanalizujmy sobie "mark-cursor!".

Na pewno jest uzywany w (editor types spaces).

Poza tym w:

text-painter:
- draw-horizontal-bar!
- draw-vertical-bar!
- draw-custom-box!
- draw-quote-markers!
- draw-quasiquote-markers!
- draw-unquote-markers!
- draw-unquote-splicing-markers!
- draw-string!

grasp-android:
- operning-parenthesis-color
- closing-parenthesis-color
- draw-text!

grasp-desktop:
- opening-parenthesis-color
- closing-parenthesis-color
- draw-text!


#+BEGIN_SRC
  0  5 10 15 20 25
 0X  X
 5    
10
15X  X
20      X
25      X

  0  5 10 15 20 25
 0X  X
 5
10      X
15      X



#+END_SRC

* 05.12.2023 (telefon)

+Plan jest taki, zeby pozostac przy aktualnym rozwiazaniu
w kwestii pionowego ruchu kursora, ale z jednym malym twistem:
- chcemy zapamietac polozenie linii poprzedzajacej kursor,
  oraz polozenie linii nastepujacej po kursorze

Aktualnie mamy w painterze:

  (mark-cursor! +left::real +top::real)::void
  (cursor-position)::Position
  (cursor-height)::real

  pierwsza rzecz jest taka, ze one nie powinny byc
  w painterze, tylko w Editorze [oczywiscie rysowanie
  kursora moze byc]

  To bysmy robili tak, ze bysmy wywolywali "mark-cursor!"
  na elemencie (the-editor) - ktory by musial implementowac
  odpowiedni interfejs


* 04.12.2023

dzis bysmy sie zajeli tymi klawiszami w gore i w dol.
wyobrazam sobie, ze to powinno dzialac tak:
1. najpierw wywolujemy 'index-above' albo 'index-below'
   na docelowym elemencie. Jezeli indeks sie zmieni,
   to konczymy. Jezeli nie, to
2. wywolujemy odpowiednia funkcje na rodzicu danego
   elementu

...

n. i tak dalej, az trafimy na indeks, ktory sie zmieni, albo
   dojdziemy do korzenia kursora


#+BEGIN_SRC scheme
  (define (cursor-above #!optional
			(cursor::Cursor (the-cursor))
			(document (the-document)))
    (and-let* ((`(,tip . ,root)  cursor)
	       (parent ::Element (cursor-ref document root))
	       (target ::Element (parent:part-at tip))
	       (above (target:index-above tip)))
      (cond ((isnt above equal? tip)
	     (recons above root))
	    ((eq? parent target)
	     (and-let* ((`(,leaf . ,stem) root))
	       (cursor-above stem document)))
	    (else
	     (cursor-above root document)))))

  (define (cursor-below #!optional
			(cursor::Cursor (the-cursor))
			(document (the-document)))
    (and-let* ((`(,tip . ,root)  cursor)
	       (parent ::Element (cursor-ref document root))
	       (target ::Element (parent:part-at tip))
	       (below (target:index-below tip)))
      (cond ((isnt below equal? tip)
	     (recons below root))
	    ((eq? parent target)
	     (and-let* ((`(,leaf . ,stem) root))
	       (cursor-below stem document)))
	    (else
	     (cursor-below root document)))))
  
#+END_SRC


* 03.12.2023

no to teraz mamy plan taki, zeby zrobic pionowy ruch kursora - ale zeby zrobic go dobrze

i jak zwykle w takich okolicznosciach dobrze jest zaczac od tego, zeby zapytac,
w jaki sposob jest to aktualnie zrobione

#+BEGIN_SRC scheme
(define (move-cursor-up!)
  (let* ((target (the-expression))
	 (initial-position ::Position (painter:cursor-position))
	 (cursor-height (painter:cursor-height))
	 (initial-cursor (the-cursor)))
    (let probe ((attempt 1))
      (let* ((shift (* attempt cursor-height))
	     (cursor (cursor-under (cursor-column)
				  (- initial-position:top
				     shift))))
	(cond ((isnt cursor equal? initial-cursor)
	       (set! (the-cursor) cursor)
	       (set! (the-selection-anchor) cursor))
	      ((is 0 < shift < initial-position:top)
	       (probe (+ attempt 1))))))))

(define (move-cursor-down!)
  (let* ((target (the-expression))
	 (initial-position ::Position (painter:cursor-position))
	 (cursor-height (painter:cursor-height))
	 (document-extent ::Extent (sequence-extent))
	 (initial-cursor (the-cursor)))
    (let probe ((attempt 1))
      (let* ((shift (* attempt cursor-height))
	     (cursor (cursor-under (cursor-column)
				  (+ initial-position:top
				     shift))))
	(cond ((isnt cursor equal? initial-cursor)
	       (set! (the-cursor) cursor)
	       (set! (the-selection-anchor) cursor))
	      ((is 0 < shift < (+ initial-position:top shift)
		   < document-extent:height)
	       (probe (+ attempt 1)))
	      )))))
#+END_SRC

* 02.12.2023 (telefon)

1. zmieniamy Map2D na BiMap2D
2. tworzymynnowe Map2D z metoda outside-in
3. tworzymy UnMap2d z metoda inside-out

i teraz chcemy, zeby Embeddable bylo Map2D

* 02.12.2023

jak juz przywrocimy ten gest ewaluacji (zeby dzialal tak jak dzialal wczesniej), to bysmy sie zajeli
moze ruchem strzalek w gore i w dol?

To brzmi OK.

A po tym bysmy sie zajeli z powrotem edycja, tak zeby:
- dzialal drag&drop na komentarzach i stringach
- nie bylo bledow przy edycji z klawiatury
- dalo sie wprowadzac znaki #\[, #\] itd.

Ale poki co jednak rzeczywiscie - ruch strzalek.

I tutaj mamy tak:

- ruch strzalek wewnatrz tekstu/komentarza blokowego
- ruch strzalek wewnatrz listy (spacji, atomow)

* 01.12.2023

Czesc problemow z Resize udalo sie rozwiazac (i usunac screen-position
w zamian wprowadzajac document-position),

Ale nadal jest problem jezeli probujemy zmienic rozmiar z innego miejsca, niz
lewy gorny edytor, to cos jeszcze nie dziala, i chyba to bysmy chcieli dzis
naprawic

Tosmy naprawili.

To teraz pozostaje nam gest ewaluacji chiba.


* 30.11.2023

- naprawic Resize
- naprawic Drag
- naprawic gest ewaluacji

idealnie byloby zrobic te 3 rzeczy do konca tygodnia

#+BEGIN_SRC scheme
(define (document-position-of-element-pointed-by cursor document 
                                                 #!key (context::Cursor (recons 1 '())))
  ::(Values real real)
  (escape-with return
    (define (action item ::Element traversal ::Traversal)
      (let ((c (recons traversal:index context)))
        (cond ((equal? c cursor)
               (return (+ traversal:left traversal:parent-left)
                       (+ traversal:top traversal:parent-top)))
	      ((is c suffix? cursor)
               (document-position-of-element-pointed-by cursor document c)))))
    
    (define (fallback t::Traversal)
      (values (+ t:left t:parent-left) (+ t:top t:parent-top)))

  (traverse document doing: action returning: fallback)))
#+END_SRC


* 29.11.2023

mapowanie zrobilismy, ale chyba cos przy okazji zepsulismy w tescie
widocznosci.

i chyba chcemy tez miec mozliwosc badania gestu ewaluacji

to jezeli idzie o te pierwsza kweste, musimy mapowac wszystkie
4 rogi edytora do wspolrzednych dokumentu (i to najlepiej to robic
w funkcji rysujacej panel)

to wydaje sie dzialac znakomicie!

Co nam zatem pozostaje?

- chcielibysmy sie pozbyc zaleznosci od "screen-position" w module "pane"
- byc moze jednak zdecydujemy sie usunac tego transform-stacka


#+BEGIN_SRC scheme
(define (document-position document cursor #!key (context::Cursor (recons 1 '())))::(Values real real)
  (escape-with return
    (define (action item ::Element traversal ::Traversal)
      ...)
    
    (define (fallback t::Traversal)
      (values (+ t:left t:parent-left) (+ t:top t:parent-top)))

  (traverse document doing: action returning: fallback)))
#+END_SRC

* 25.11.2023

chcemy:
- dodac translacje do splitow
- zrobic tak, zeby aktualizowac translacje przy zmianie rozmiaru splitu
- propagowac transformacje w metodach "propagate", "key-typed" oraz "draw!"
  obiektow "embeddable"

OK, wydaje sie, ze to juz mamy. I co dalej?

Chyba bysmy sprobowali uzyc tego nowego mechanizmu do mapowania wspolrzednych
dokumentu na wspolrzedne ekranu

* 24.11.2023

teraz plan jest taki, zeby sie pozby tablicy
'screen-positiin' i ja zastapic 'document-position',
co byc moze bedzie sie wiazalo ze zmianami w Traversalu

chcemy tez znalezc warunki dla 'early-returna'
z funkcji rysujacej (i ew pozostalych, ale to
pozniej)

(jednak wydaje sie, ze zrobienie tego jest
na razie zbyt trudne, zeby sie tym zajmowac)

No dobra, to zobaczmy, co nam daja API Javy
i Androida do mierzenia sie z takimi rzeczami
czyli android.graphics.Matrix
oraz java.awt.geom.AffineTransform

i otoz ta pierwsza ma metode nap, ale nie ma unmap,
zas ta druga nie ma zadnej

No dobra. To bysmy dodali:
- the-transform-stack
- with-post-transform do metod splitu:
  - propagate
  - draw!
  - key-typed

I to zapewne zrobimy przez weekend.
Ale na razie pomyslmy co chcemy zrobic dalej

mamy 3 cele: 
- wystapienie na bobconf (a moze i lambda-days)
- uzywanie GRASPa do edycji jego samego
- wydanie GRASPa

te dwa ostatnie cele wiele ze soba laczy.
ten pierwszy za to jest ciekawy

mozna je ze soba laczyc

jezeli idzie o doprowadzenie do uzytecznosci, to mamy:
- uzupelnienie funkcji edytujacych
- naprawa bugow w edycji i historii
- ewentualne optymalizacje
- poprawa czcionki, rozmiaru, nawiasow
- pionowy ruch kursorem
- wyszukiwanie i zamiana
- filtr zapisu i odczytu (do zmian w indentacji)
- nawigacja kursorem po rozszerzeniach

jezeli zas idzie o bobkonf, to wiadomka: chcemy sobie
zdefiniowac algorytm A* w sposob mozliwie maksymalnie
wizualny, a nastepnie chcemy zeby nasz wizualny ewaluator
pozwolil nam sobie zwizualizowac jego prace jako animacje

#+BEGIN_SRC scheme
(define (RankedPath path::Path ranking: real estimate: real)
  (Beside
    left: path right: (Below top: (Bordered element: ranking)
			  bottom: (Clouded element: estimate)))

#+END_SRC

* 23.11.2023

no to dzis bysmy zaczeli od dodania 'insert-at!' do
Embeddable i przywrocenia funkcjonowania drag&dropa

co wydaje sie dosc proste

a nastepnie bysmy sie zajeli tym screen-position
(przy czym najpierw chyba poprawa buga, a pozniej
zamiana na document-position)

ale do tego jeszcze dochodzi to, ze 
gest evaluate-expression-by-wedge wciaz zaklada, ze
Embeddable posiada metode outside-in

wiec musimy wymyslic:
- jak naprawic bledy spowodowane "wycinajaca" optymalizacja
- jak naprawic gest ewaluacji
- jak przemigrowac ze screen-position do document-position

Do tego jeszcze zrobilismy zmiane z wyciaganiem elementu
- i tutaj tez dobrze by bylo miec jakis sposob
  na przeksztalcanie wspolrzednych dokumentu w ekranowe

Wycinajaca optymalizacja wydaje sie (w Androidzie)
przynajmniej w czesci naprawiona

* 22.11.2023

Ok, czyli planem na dzis jest sprawienie, zeby
Embeddable nie bylo Map2D.

Ale zeby tego dokonac, najpierw trzeba sie dowiedziec
dlaczego Embeddable jest Map2D.

Otoz mamy zasadniczo dwie instancje Embeddable: Splity
oraz Editory.

W przypadku Splitow mapowanie outside-in jest zaimplementowane
w taki sposob, ze w zaleznosci od wspolrzednych wejsciowych
wybieramy odpowiednia transformacje - i wlasnie ze wzgledu na ow
nieliniowy wybor nie mozemy odwrocic tej operacji

A raczej powinnismy robic tak, ze dodajemy odpowiednia operacje
na dno stosu transformacji (w zaleznosci od wspolrzednych)


No dobra: zasadniczo wywalilismy Map2D z Embedded i swiat sie
nie zawalil. Trzeba bylo tylko w metodzie DragAround:drop!
wywalic odniesienie do screen:top:outside-in i zastapic
je funkcja values. To nie jest do konca tak jak powinno byc
- jakos trzeba bedzie moc zmapowac wspolrzedne dokumentu
  na wspolrzedne edytora, i wlasnie teraz chcemy to wymyslic

Dodatkowo musimy miec gdzies z tylu glowy, ze chcemy sie pozbyc
screen-position, i albo zastapic ja document-position, albo nawet
po prostu metoda traverse

Musimy zatem wyobrazic sobie, co sie powinno dziac, kiedy
robimy DragAround albo Resize.

No to tak:

1. naciskamy na ekran
2. ekran tlumaczy wspolrzedne ekranu na wspolrzedne edytora
   (rekurencyjnie wglab, az docieramy do dokumentu)
3. wywolana zostaje metoda, ktora wyodrebnia element
   z dokumentu i zwraca obiekt Drag
4. przy kazdym ruchu palca jest wywolywana metoda move!
5. po podniesieniu palca zostaje wywolana metoda drop

I to wlasnie tutaj pojawia sie problem.

Zarowno Editor jak i Split powinny miec jakas metode,
ktora wywolujemy, np.

(insert-at! x::real y::real expression)::boolean

* 21.11.2023

no i jeszcze zgloszenie na BOBKonf!

no ale zeby to wszystko moglo zadzialac, oto co musimy zrobic:
- prawidlowa optymalizacja wyswietlania
  (z uwzglednieniem przeskakiwania elementow w dokumencie
  oraz wyskakiwania)
- uzycie wspolrzednych dokumentu i poprawa bugow edycji dotykowej
- pulling-the-rug splicing
- ograniczenia na zoomowanie i scrollowanie

zacznuemy dzis od tego, zeby przemianowac map i unmap
na outside-in oraz inside-out

ok to sie chyba udalo

to teraz bysmy sie zajeli tym, zeby zamiast screen-position
miec document-position, przy czym screen-position jest uzywany
w dwoch modulach:
- (editor types primitive), gdzie jest ustawiany (i od niedawna
  uzywany do optymalizacji)
- (editor input pane), gdzie jest uzywany przy Resize i przy
  Drag&Drop

i teraz tak: nie bedzie niczym zlym, jezeli sprobujemy teraz uporac
sie z bugiem, bo nawet jesli pozniej zmienimy architekture, wydaje sie,
ze mozemy osiagnac cel w postaci rozumienia tego, co sie tutaj
dzieje

no to plan jest mniej wiecej taki, ze bysmy chcieli miec
parametr (the-transform), ktory pozwalalby nam przechodzic od
wspolrzednych edytora do wspolrzednych dokumentu i z powrotem

moglibysmy stworzyc sobie takie cos:

#+BEGIN_SRC scheme
  (define-object (TransformStack)::Map2D
    (define transforms ::($bracket-apply$ List Map2D)
      (($bracket-apply$ ArrayList Map2D)))

    (define (outside-in x::real y::real)::(Values real real)
      (for transform::Map2D in transforms
	(let-values (((x* y*) (transform:outside-in x y)))
	  (set! x x*)
	  (set! y y*)))
      (values x y))

    (define (inside-out x::real y::real)::(Values real real)
      (for transform::Map2D in-reverse transforms
	(let-values (((x* y*) (transform:inside-out x y)))
	  (set! x x*)
	  (set! y y*)))
      (values x y))

    (define (addLast transform::Map2D)::void
      (transforms:addLast transform))

    (define (addFirst transform::Map2D)::void
      (transforms:addFirst transform))

    (define (removeLast transform::Map2D)::Map2D
      (transforms:removeLast))

    (define (removeFirst transform::Map2D)::Map2D
      (transforms:removeFirst))
    )

  (define the-transform-stack ::TransformStack (TransformStack))

  (define-syntax-rule (with-post-transform t . actions)
    (transform-stack:addLast t)
    (try-finally
     (begin . actions)
     (transform-stack:removeLast)))

  (define-syntax-rule (with-pre-transform t . actions)
    (transform-stack:addFirst t)
    (try-finally
     (begin . actions)
     (transform-stack:removeFirst)))
#+END_SRC

No dobra, ale teraz jak bysmy tego uzywali?

I jak to sie ma do tego, co mamy teraz?

Po pierwsze, Embeddable jest zdefiniowane jako Map2D - co
w pewnym sensie jest dosc klopotliwe, bo Split - ktory jest
Embeddable, ma metode inside-out, ktora nie ma swojej
implementacji.

Ponysl zatem jest taki, zeby Embeddable nie bylo Map2D.


* 20.11.2023

no dobra, to mamy pare bugow w naszym mechanizmie optymalizujacym

natomiast kluczowe kwestie to:
- zaczac uzywac GRASP do edycji jego samego
- wydac wersje 1.0.0 edytora do sklepu Play

  
* 17.11.2023 (komputer)

mamy takie oto problemy:
1. draw-sequence! zapamietuje "screen-position" (a nie "document-position")
2. to mogloby zadzialac od reki, gdybysmy mieli dostepne wartosci "the-pane-left"
oraz "the-pane-top"
3. ale modul (editor types primitive) nic nie wie o parametrach
the-pane-width i the-pane-height, ktore sa zdefiniowane w (editor input pane)
dla ktorego (editor types primitve) jest zaleznoscia

Byc moze moglibysmy przeniesc definicje (the-pane-width) i (the-pane-height)
do (editor types primitive)

* 17.11.2023

#+BEGIN_SRC scheme
  (define (overlap? Amin Amax Bmin Bmax)
    (assert (is Amin <= Amax))
    (assert (is Bmin <= Bmax))
    (and (is Amin <= Bmax) (is Amax >= Bmin)))

  ;; 0    1    2    3
  ;; Amin Amax Bmin Bmax
  (e.g. (not (overlap? 0 1 2 3)))

  ;; Amin Bmin Amax Bmax
  (e.g. (overlap? 0 2 1 3))

  ;; Amin Bmin Bmax Amax
  (e.g. (overlap? 0 3 1 2))

  ;; Bmin Bmax Amin Amax
  (e.g. (not (overlap? 2 3 0 1)))

  ;; Bmin Amin Bmax Amax
  (e.g. (overlap? 1 3 0 2))

  ;; Bmin Amin Amax Bmax
  (e.g. (overlap? 1 2 0 3))

  (define (rectangles-overlap? Axmin ::real Aymin ::real
			       Axmax ::real Aymax ::real

			       Bxmin ::real Bymin ::real
			       Bxmax ::real Bymax ::real)
    ::boolean
    (and (overlap? Axmin Axmax Bxmin Bxmax)
	 (overlap? Aymin Aymax Bymin Bymax)
    ))
#+END_SRC


* 16.11.2023

no to jak?

zalozmy, ze podczas renderowania mamy dostep do
wspolrzednych wyrazenia wewnatrz dokumentu.

za pomoca transformacji edytora mozemy je
sobie przetransformowac do wspolrzednych edytora

i to zasadniczo nam wystarczy do tego, zeby
okreslic, czy dany obiekt jest widoczny

co wiecej mozemy zrobic tak, ze nie bedziemy
transformowac wspolrzednych dokumentu, tylko
sobie przetransformujemy wspolrzedne edytora
do wspolrzednych dokumentu

#+BEGIN_SRC scheme
  (define (overlap? Axmin ::real Aymin ::real
		    Axmax ::real Aymax ::real

		    Bxmin ::real Bymin ::real
		    Bxmax ::real Bymax ::real)
    ::boolean

   
    )

#+END_SRC

* 15.11.2023

powstal nowy pomysl na optymalizacje:
zrobic makro traverse/inline, ktore by mialo taka sama
definicje, jak traverse, i tego makra uzyc do zdefiniowania
funkcji aktualnie definiowanych za pomoca traverse.

Dodatkowo mozna sprobowac zrobic cos, zeby lambdy byly
inline'owane w ciele twgo makra

bo jak to zrobimy, i jak zoptymalizujemy wyswietlanie,
to bysmy sie zajeli Usability, czyli tym, zeby:
- ograniczyc scrollowanie i usunac rotacje
- zrobic poprawna nawigacje kursorem
- naprawic edycje dotykowa


no dobra, nie wydaje sie, zeby inline'owanie makra duzo
zmienilo (aczkolwiek warto podejrzec wynikowe asemblery)

mozemy jeszcze sprobowac hardware'owa akceleracje

* 14.11.2023

teraz plan jest skromny, taki, zeby nie rysowac niewidocznych
elementow, tzn:
- jezeli dany element nie jest widoczny, to go przeskakujemy
- jezeli dany element jest na takuej wysokosci, ze juz wiecej
  nie bedzie widoczny, to go w ogole przeskakujemy

no ale dobra, teraz mamy taki problem, zeby ustalic,
czy dany prostokat znajduje sie na ekranie, co wiaze sie
z takim problemem, zeby w ogole ustalic, jakie ow prostokat
ma wspolrzedne

i teraz: mamy 3 sposoby okreslania wspolrzednych:
- na ekranie
- w dokumencie
- w edytorze

aktualnie zapisujemy sobie wspolrzedne ekranowe, ale
chyba najlepiej byloby zapisywac wspolrzedne dokumentu
i je przeksztalcac do wspolrzednych edytora i ekranu

na razie to jest tak zapisywane (w draw-sequence!):

#+BEGIN_SRC scheme
  (let ((position ::Position (screen-position item)))
    (set! position:left
	  (painter:current-translation-left))
    (set! position:top
	  (painter:current-translation-top)))
#+END_SRC


oki, no to zalozmy ze wymyslimy sposob jak wyliczac wspolrzedne
dokumentu (zapewne poprzez rekurencyjne odwolywanie sie
do traversali)

to postawi przed nami dwa pytania:
1. co z dotychczasowym kodem?
2. jak tego uzyc do implementacji nowej funkcjonalnosci?

No to tak: screen-position jest uzywane w
(editor input pane) przez Resize oraz w okolicach DragAround,
czyli w sumie to zasadniczo tam, gdzie teraz mamy bugi

Tymczasem mamy taka idee, zeby zamiast tego miec
document-position. Do tego dochodzi jeszcze taka kwestia,
ze fajnie by bylo, zeby tych pozycji nie trzymac
w haszu, tylko bezposrednio w obiektach (podobnie
jak extentow), no ale oczywiscie nie wszystko na raz

no dobra, czyli wiemy na razie, ze:
- chcemy sie przelaczyc ze screen-position na document-position
- musimy mapowac wspolzedne ekranowe dotyku w dokument

i w takim razie renderowanie musi wygladac tak, ze:
- bierzemy sobie wspolrzedne dokumentu (wyliczamy je z traverse'a
  podczas renderowania)
- musimy uwzglednic dwie rzeczy: wspolrzedne biezacego
  edytora (wzgledem splitu) oraz aktualna transformacje
- na tej podstawie okreslamy, czy prostokat biezacego
  elementu znajduje sie w swietle ekranu

* 13.11.2023

wydaje sie, ze zmiany z properties na membery nie przyniosly
duzej poprawy wydajnosci - choc zapewne nalezaloby to zmierzyc
profilerem. (ale w sumie wydaje sie ze jest nieco szybciej)

byc moze tez jakies inne propertiesy psuja nam
charakterystyki wydajnosciowe, i moze np. extent powinnismy
rowniez cache'owac w memberach

inny pomysl na optymalizacje jest wszak taki, zeby:
1. edytor pamietal pierwsze wyrazenie, ktore jest widoczne, i to
   od niego rozpoczynal rysowanie
2. albo nawet prosciej: jezeli dany fragment dokumentu nie jest
   widoczny, to po prostu robmy return z funkcji rysujacej

zacznijmy od tego drugiego. moglubysmy tez robic tak, zeby
inwalidacja cache'u dotyczyla tylko elementow widocznych
na ekranie

no to mamy tak:

(0,0),         (szerokosc, 0)

(0, wysokosc), (szerokosc, wysokosc)

i teraz tak:
- dokonujemy transformacji wspolrzednych podczas rysowania
 (wspolrzedna bazowa i z dodanym extentem)
- jezeli wszystkie punkty sa:
  - po lewej od 0
  - po prawej od szerokosc
  - powyzej 0
  - ponizej wysokosc

    to robimy return z draw-sequence

no dobra, to mozna zrobic, ale najpierw bysmy sie pozbyli
the-painter

pierwej jednak trzeba owo makro with gdzies umiescic

no dobra, to nie ma the-painter

i to chyba wcale duzo nie pomoglo

(co mogloby pomoc to port do chez scheme)

natomiast moze byc tak, ze nierysowanie niewidocznych
rzeczy pomoze?


* 10.11.2023

#+BEGIN_SRC scheme
  (define-syntax with
    (lambda (stx)
      (syntax-case stx ()
	((with ((variable value) ...) . actions)
	 (with-syntax (((previous-value ...)
			(generate-temporaties #'(variable ...))))
		      #'(let ((previous-value variable) ...)
			  (set! variable value)
			  ...
			  (try-finally
			   (begin . actions)
			   (begin
			     (set! variable previous-value)
			     ...))))))))
#+END_SRC

takie cos bysmy chcieli miec

i zamiast parametru "the-painter" bysmy chcieli miec
po prostu zmienna globalna "painter", zeby uniknac narzutu
i ewentualnie nieco uproscic kod

a tymczasem mamy sobie slynne A*:


#+BEGIN_SRC scheme
(define (optimial-path #;on weighted-graph #;from initial-state 
			    #;until success?
				    #;guided-by remaining-cost-estimate)
  (define (probably-shorter? `(,estimate-a . ,_)
			     `(,estimate-b . ,_))
    (is estimate-a < estimate-b))

  (define (walk paths visited-nodes)
    (and-let* ((`((,_ ,cost-so-far ,path) . ,paths) paths)
	       (`(,current-node . ,_) path))
      (define (estimate-total-cost `(,node ,weight))
	(let* ((total-cost (+ cost-so-far weight))
	       (estimate (+ total-cost
			    (remaining-cost-estimate node))))
	  `(,estimate ,total-cost ,node)))

      (define (update-paths paths `(,estimate
				    ,alternative-cost
				    ,node))
	(let ((new-path `(,estimate
			  ,alternative-cost
			  (,node . ,path))))

	  (match (find (lambda (`(,_ ,_ (,end . ,_)))
			 (equal? end node))
		       paths)
	    (`(,previous-estimate ,established-cost ,_)
	     (if (is established-cost <= alternative-cost)
		 paths
		 (let ((paths (only (lambda (`(,_ ,_ (,end . ,_)))
				      (isnt end equal? node))
				    paths)))
		   (merge `(,new-path) paths probably-shorter?))))
	    (_
	     (merge `(,new-path) paths probably-shorter?)))))

      (if (success? current-node)
	  (values (reverse path) cost-so-far)
	  (let* ((neighbors (weighted-graph current-node))
		 (new-neighbors (only (lambda (`(,node ,weight))
					(isnt node member visited-nodes))
				      neighbors))
		 (judged-neighbors (map estimate-total-cost new-neighbors))
		 (paths (fold-left update-paths paths judged-neighbors)))
	    (walk paths (union `(,current-node)
			       visited-nodes))))))

  (walk `((+inf.0 0 (,initial-state))) '()))
#+END_SRC

Najgoretsze wyrazenie w algorytmie to (po zwinieciu):

#+BEGIN_SRC scheme
  (walk (fold-left update-paths paths
		    (map estimate-total-cost
			 (only (lambda (`(,node ,weight))
				 (isnt node member visited-nodes))
			       (weighted-graph current-node))))
      (union `(,current-node) visited-nodes))
#+END_SRC

chodzi o to, ze:
- mamy sobie liste sciezek
- zawsze rozpoczynamy od pierwszej sciezki na liscie (bo ona jest
  naszym zdaniem najkorzystniejsza)
- 

* 09.11.2023

dalsze poprawki w edycji

teraz bysmy moze zrobili tak, ze jak jestesmy w trybie
'evaluating', i mamy do czynienia z Extension, to zwracamy
jego 'as-expression'

to z grubsza chodzi o to, zeby Extension bylo Shadowed, i zeby
"value" robilo to, co robi as-expression

ok

a teraz pomysl jest taki, zeby sie pozbyc tych propertisow w spacjach

A to by wygladalo tak mniej wiecej:

#+BEGIN_SRC scheme

  (define-syntax-rule (define-accessor (name object::type)::result)
    (define-early-constant name
      (let ((getter (lambda (object::type)
		      ::result
		      (slot-ref object 'name))))
	(set! (setter getter)
	      (lambda (object::type value::result)
		::void
		(slot-set! object 'name value)))
	getter)))

  (define-accessor (dotted? cell::cons)::boolean)
  (define-accessor (pre-head-space cell::cons)::Space)
  (define-accessor (post-head-space cell::cons)::Space)
  (define-accessor (pre-tail-space cell::cons)::Space)
  (define-accessor (post-tail-space cell::cons)::Space)

  (define-object (cons car cdr)::MatchableTile
    ...
    (define pre-head-space ::Space (Space fragments: (cons 0 '())))

    (define dotted? ::boolean
      (not (or (empty? cdr)
	       (pair? cdr))))

    (define post-head-space ::Space
      (if (and (not dotted?)
	       (empty? cdr))
	  (Space fragments: (cons 0 '()))
	  (Space fragments: (cons 1 '()))))

    (define pre-tail-space ::Space
      (Space fragments: (cons 1 '())))

    (define post-tail-space ::Space
      (Space fragments: (cons 0 '())))

    ...
    (pair car cdr))

#+END_SRC

* 08.11.2023

jestesmy w *jakims punkcie* naprawiania zmiany rozmiaru
pudelek - ale wyglada na to, ze bedziemy musieli to sobie
jakos rozrysowac

no bo chodzi o to, ze mamy:

- wspolrzedne ekranu
- wspolrzedne edytora
- wspolrzedne dokumentu

i latwo sie w tym zapultac

a druga sprawa to wyszukiwanie

no bo pomysl jest taki, ze jak ciskamy (ctrl f)
to sie nam powinien biezacy edytor dzielic w pionie
na 2, i focus powinien isc do tego dolnego

tam rowniez powinien byc tworzony tymczasowy dokument.

i kiedy bedziemy wpisywac tekst, to w gornym widoku
powinno sie odbywac wyszukiwanie pasujacych elementow
(a jak nie znajdziemy, to powinnismy robic zoom-out
na caly dokument, a w kazdym razie do dopuszczalnej
skali)

no ale na razie zajmijmy sie czyms bardziej przyziemnym,
tzn. tym, zeby software'owa klawiatura na Androidzie
zmieniala rozmiar ekranu

#+BEGIN_SRC java
  void setKeyboardVisibilityListener(OnKeyboardVisibilityListener
				     onKeyboardVisibilityListener) {
      View parentView = ((ViewGroup) findViewById(android.R.id
						  .content))
	  .getChildAt(0);
      parentView.getViewTreeObserver()
	  .addOnGlobalLayoutListener(new
				     ViewTreeObserver
				     .OnGlobalLayoutListener() {

		  private boolean alreadyOpen;
		  private final int defaultKeyboardHeightDP = 100;
		  private final int EstimatedKeyboardDP =
		      defaultKeyboardHeightDP
		      + (Build.VERSION.SDK_INT
			 >= Build.VERSION_CODES.LOLLIPOP
			 ? 48 : 0);
		  private final Rect rect = new Rect();

		  @Override
		  public void onGlobalLayout() {
		      int estimatedKeyboardHeight = (int)
			  TypedValue.applyDimension(TypedValue
						    .COMPLEX_UNIT_DIP,
						    EstimatedKeyboardDP,
						    parentView
						    .getResources()
						    .getDisplayMetrics());
		      parentView.getWindowVisibleDisplayFrame(rect);
		      int heightDiff = parentView.getRootView()
			  .getHeight() - (rect.bottom - rect.top);
		      boolean isShown =
			  heightDiff >= estimatedKeyboardHeight;

		      if (isShown == alreadyOpen) {
			  Log.i("Keyboard state",
				"Ignoring global layout change...");
			  return;
		      }
		      alreadyOpen = isShown;
		      onKeyboardVisibilityListener
			  .onVisibilityChanged(isShown);
		  }
	      });
  }


#+END_SRC

* 07.11.2023

wydaje sie, ze jestesmy w takim punkcie, z ktorego trudno
sie ruszyc.

ogolnie chcielibysmy naprawic bledy zwiazane z drag&dropem
i moze w konkretniejszy sposob uzupelnic dotykowa edycje,
a takze unormowac kwestie zoomowania i scrollowania
(i najlepiej zeby scrollowanie odbywalo sie na zasadach
Super Mario)

poniewaz jednak teraz korzystamy ze 'screen-position',
to nam sie wszystko krzaczy

wiec pomysl jest taki, zeby:
- zmienic screen-positiion na document-position
- wszystkie odniesienia do screen-position zaposredniczyc
  przez transformacje

albo drugi pomysl:
- zamienic screen-position na editor-position

wydaje sie, ze opcja 2 jest ontyle lepsza, ze potrzeba
mniej transformacji

tyke ze screen-position powinno byc parametrem

* 06.11.2023

no dobra, to teraz robimy ograniczenia na zoomowanie i scrollowanie

i przy okazji dobrze by bylo naprawic:
- resize
- drag&drop

to tak:
- jezeli idzie o zoom, to musimy sobie wyswietlac aktualna wartosc
- jezeli idzie o scrolla, to

getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_STATE_VISIBLE|WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);

ok, trzeba chyba bedzie delikatnie przebudowac architekture

chodzi o to, ze transformacje musza w jakis sposob miec dostep
do rozmiaru dokumentu

zatem bedziemy chcieli stworzyc nowe transformacje, bo bysmy
chcieli zmienic dzialanie funkcji "stretch" tak, zeby nie zmieniala
przesuniecia dokumentu (tzn zeby lewy gorny piksel pozostawal
bez zmian)

ogolnie tez nie chcemy teraz za bardzo szalec. tzn idealnie byloby
wprowadzic minimalna ilosc zmian do tego, zeby:
- moc przeprowadzac w GRASP normalna edycje (w szczegolnosci
  chodzi o edycje samego GRASPa)
- rozwijac Androidowego GRASPa w nim samym
- zaimplementowac "komiksowy" algorytm A*

no ok, ale co jest potrzebne do rozwijania androidowej wersji
w niej samej?

No mniejsza z tym wszystkim na razie.

Moze poprawimy pozycje paleczki podczas rysowania komentarzy?

Pomysly:
- podwojne klikniecie w lewy nawias: minimalizacja wyrazenia
- w prawy nawias - maksymalizacja wyrazenia



* 05.11.2023

no to plan na najblizszy czas jest taki:
1. wprowadzic ograniczenia na najwiekszego i najmniejszego
   zooma oraz na pozycje scrolla (i ewentualnie usunac
   mozliwosc obracania)
2. zrobic tak, zeby obiekty, ktore nie sa widoczne na ekranie
   - nie mialy inwalidowanego extent cache'u
   - nie byly w ogole rysowane
3. rysowac ramki wokol dokumentu

dobrze byloby tez:
 - wprowadzic kolorowanie wyewaluowanych wyrazen
- zaimplementowac gest steppera
- rysowanie guzikow


No dobra, ale co ma nam szanse przyblizyc najszybciej
samoedytowalnosc GRASPa?

Ogolnie to bysmy chcieli raczej operowac na projektach, niz
na pojedynczych plikach. Projekt bysmy utozsamiali z gitowym
repozytorium, zas jego zaleznosci to by byly gitowe
submoduly. I wowczas owe submoduly by sie miescily
w internal storage'u.

Od razu tez chcemy oczywiscie miec nawigacje po kodzie
zrodlowym.

* 03.11.2023

aktualnie mamy na kompie poprawki w parserze, a na telefonie
podswietlanie "paleczki" pomiedzy glowa a ogonem

jeszcze bysmy chcieli w kliencie desktopowym poprawic wyswietlanie
quote'ow, ograniczyc scrollowanie i zoomowanie dokumentu,
wyswietlac pop-upy wewnatrz edytorow, a nie ponad nimi,
oraz zaimplementowac mechanizm wyszukiwania wyrazen
(wlaczajac w to slowa kluczowe oraz wyrazenia regularne,
a takze zagniezdzone struktury)

* 03.11.2023 (telefon)

no dobra, to w sumie teraz naszym celem jest wypolerowanie
doswiadczenia uzytkownika

- pierwsza brakujaca funkcjonalnosc to search&replace
- chcielibysmy tez wyswietlac informacje o tym, czy byly
  w pliku jakies zmiany (oraz nazwe pliku)
- i tak w sumie to bysmy chcieli, zeby scratch byl zawsze
  domyslnie otwierany, i automatycznie zapisywany
- ach no i oczywiscie chcemy
  - podswietlac HeadTailSeparator
  - miec mozliwosc drag&dropowania HeadTailSeparatora
  - kasowania go backspacem i deletem
- no i bardziej wybiorcza inwalidacja cache'u +
  renderowanie tylko tych rzeczy, ktore sa widoczne na ekranie

zaczniemy od kolorowania paleczki

to teraz jest tak, ze metoday draw! implementacji
HeadTailSeparator olewaja kontekst i wywoluja
draw-horizontal-bar! albo draw-vertical-bar! malarza
i teraz propozycja jest taka, zeby te metody dostaly
dodatkowy argument - boolean - ktory by decydowal o tym,
czy jest "highlighted".


* 02.11.2023

no dobra, to teraz trzy duze tematy, ktore bysmy chcieli miec
rozwiazane w listopadzie:
- poruszanie strzalkami w gore i w dol
- poruszanie kursorem po rozszerzeniach (w szczegolnosci
  po stepperze, no ale wiadomka)
- selekcja i integracja ze schowkiem

w sumie to tez spoko by bylo miec mozliwosc wyszukiwania rzeczy,
bo to daloby nam szanse na uzycie GRASPa do faktycznej edycji
kodu

no ale zacznijmy od ttch strzalek nieszczesnych

z grubsza rzecz powinna przebiegac w taki sposob, ze:
- w przypadku tekstu i komentarzy blokowych sprawa jest jasna
  (o ile pominiemy warunki brzegowe)
  
- w przypadku spacji/komentarzy liniowych sprawa jest
  dosc tajemnicza

- w przypadku atomow jest tak jak w przypadku tekstu

wiec teraz fundamentalny problem to owa tajemniczosc

czyli tak:
- jezeli jestesmy na tekscie, wiemy co robic
- w przeciwnym razie to lista, na ktorej jestesmy,
  powinna wiedziec

No ale jakze to?!

#+BEGIN_SRC scheme
  (define (move-cursor-up!)::void
    (let ((cursor ::Cursor (the-cursor))
	  (document ::Document (the-document)))
      (set! (the-cursor) (document:cursor-above* cursor))))

  (define (move-cursor-down!)::void
    (let ((cursor ::Cursor (the-cursor))
	  (document ::Document (the-document)))
      (set! (the-cursor) (document:cursor-below* cursor))))

  (define (cons:cursor-below* cursor::Cursor context::Cursor)::Cursor*
    )
 #+END_SRC

Czy jest jakis sposob zeby wykorzystac traverse?

* 01.11.2023

trzeba zrobic tak, zeby parser po kropce obsugiwal wszystkie
quote'y

ale w tym celu bedzie tez trzeba najpierw dopisac testy!

No dobra, wydaje sie, ze Mamy To.

W takim razie jutro bysmy sie zajely dalszymi testami,
tzn. test-editor-operations, bo je trzeba robic na telefonie


* 31.10.2023

No dobra, to teraz kwestia tego, w jaki sposob chcemy obsluzyc
cursor-above* oraz cursor-below*.

Zaczniemy od spacji.

Ale mozemy tez zajac sie innymi rzeczami, takimi jak:
- obsluga entera kiedy jestesmy na spacjach
- kasowanie rozszerzen
- rysowanie szarego tla wokol dokumentu
- albo chociaz tym, zeby podwojne klikniecie na atom albo lewy nawias
robilo nam kopie danego elementu
- oraz jeszcze chcemy miec pulling-the-rug-splicing
- (i moze tez zechcemy wrocic do naszego filtru Kalmana)
- a no i tez trzeba by bylo przywrocic dzialanie testow
- i "normalne" kopiowanie za pomoca podwojnego tapniecia

* 30.10.2023

no dobra, to musimy znow zgromadzic nieco wiedzy odnosnie tego:
- jak dzialaja teraz move-cursor-up! oraz move-cursor-down!
- jakie mamy implementacje interfejsu Element w naszej bazie
  kodu
- jak powinny wygladac implementacje cursor-above* oraz
  cursor-below* dla poszczegolnych implementacji

No to tak: mamy sobie oczywiscie
Space
oraz
wiele implementacji Tile, takich jak:
- Atom
- cons
- Text
- BlockComment
- LineComment
- ExpressionComment
- HorizontalBar
- VerticalBar  

* 29.10.2023

No to teraz plan jest taki, zeby:
- dodac metody "cursor-above*" oraz "cursor-below*" do interfejsu Element
- za ich pomoca wyrazic "move-cursor-up!" oraz "move-cursor-down!"

Ale moze najpierw sprobujmy moze rozwiazac ten blad z rysowaniem linii.

* 27.10.2023

no dobra, mamy napisany juz fragment "rozpoznawaczki" dla gestu ewaluacji,
ale zeby to skonczyc, musimy zbudowac takie oto zdanie:

- pierwszy punkt i ostatni punkt sa na tym samym poziomie
 (daja ten sam kursor)
- srodkowy punkt jest na glebszym poziomie
- ewaluujemy wyrazenie na poziomie "stemu", i za nim umieszczamy wynik

[Docelowo pewnie bedziemy chcieli moc sobie definiowac target danego
edytora jako jakis inny edytor, i wtedy bedzie to trzeba pozmieniac,
ale na razie jeszcze nie]

* 26.10.2023

trzeba tak zrefaktoryzowac Recognizera, zeby przybieral dodatkowy argument
- zwracany przez funkcje "recognizes" ktora powinna zwracac Object
zamiast boolean, i jezeli ta wartosci jest rozna od #f i #!null,
to wtedy powinnismy wywolywac "action"

* 24.10.2023

musimy na pewno naprawic zachowanie (ctrl enter) w sytuacji, gdy jestesmy
na spacji

do tego dochodzi kwestia tego, czy moze bysmy chcieli kolorowac definicje

(i ewentualnie przyklady)

* 23.10.2023

mamy juz ten modul. teraz chcemy napisac funkcje, ktora dokona
ewaluacji wyrazenia pod kursorem, i wpisze wynik tej ewaluacji
na nastepna pozycje

* 19.10.2023

stworzylibysmy modul (editor input evaluation) do ktorego
bysmy przeniesli niektore metody zwiazane z ewaluacja

* 18.10.2023

na razie proby zaktualizowania sdk spalily na panewce - byc moze
to kwestia odpowiedniego pliku android.jar (ale zmiana na szybko
nie sprawila, ze zaczelo dzialac, a i byc moze konieczne byloby
przebudowanie Kawy)

jutro zrobimy commit ze slajdow na JUG, natomiast w miedzyczasie
bysmy sie zajeli ewaluacja w edytorze

(i moze jeszcze zbudowaniem GRASP w oparciu o CheerpJ)

przy czym tutaj jest taka kwestia, ze:
- docelowo bysmy pewnie chcieli robic ekspansje makr po naszej stronie
- teraz mamy dwa interpretery: Kawe oraz stepper. Kiedy sie bedzie
  dalo, bedziemy wysylac definicje do obu z nich. Jak sie
  nie bedzie dalo do steppera, to powinnismy przynajmniej wypluc
  warning

wiec poczatkowo przyjmiemy sobie, ze rzeczy typu
`(define (,name . ,args) . ,value) oraz `(define ,name ,value)
wysylamy do steppera.

No dobra, ale ogolnie od czegos trzeba zaczac.

To zaczniemy od tego, zeby ctrl+enter oraz ctrl+e powodowaly
ewaluacje biezacego/poprzedniego wyrazenia

* 16.10.2023 (telefon)

sprobowalibysmy teraz obsluzyc zmiany w skrypcie do budowania
na Androidzie (tak zeby dalo sie budowac dla SDK>=30)


* 14.10.2023 (komputer)

plan jest taki:
- jutro commitujemy zmiany z komputera
- w poniedzialek zmiany z telefonu
- do tego implementujemy (na komputorze) obracanie ekranu (sroda)
- i moze jeszcze obsluge rolki myszki na Androidzie (czwartek)

i wtedy w kolejnym tygodniu bysmy sie zajeli integracja ewaluatora
(wlaczajac w to gest klinu), a kiedy to juz bedziemy mieli, to
zrobimy poprawki 

* 13.10.2023 (komputer)

jezeli chcemy miec mozliwosc scrollowania zawartosci pop-upu,
to prawdopodobnie powinnismy zrobic tak, zeby te metody do
scrollowania byly albo w Interactive

ok, scrollowanie popupu juz dziala. czyli w zasadzie
zostalo nam zoomowanie i scrollowanie edytora

* 13.10.2023 (telefon)

zidentyfikowalismy kilka problemow zwiazanyvh z wybieraczka,
i trzeba troche zrefaktoryzowac kod

- zmienilibysmy nazwe z open-document na open-document-file!
- musimy tez dodac opcje wczytania dokumentu z portu/strumienia

i jak to zrobimy, zintegrujemy wybieraczke
a po niej takze zapisywaczke

a na kompie bysmy zrobili te zoomy i scrolle

* 10.10.2023 (telefon)

#+BEGIN_SRC java
  import android.content.Intent;
  import android.net.Uri;
  import android.content.Context;

  private static final int OPEN_REQUEST_CODE = 1;
  private void pickFile() {
      Intent intent = new Intent(Intent.ACTION_OPEN_DOCUMENT);
      intent.addCategory(Intent.CATEGORY_OPENABLE);
      intent.setType("*/*");
      startActivityForResult(intent, OPEN_REQUEST_CODE);
  }

  @Override
  protected void onActivityResult(int requestCode, int resultCode, Intent data) {
      if (requestCode == OPEN_REQUEST_CODE
	  && resultCode == RESULT_OK
	  && data != null) {
	  open(data.getData());
      }
  }
#+END_SRC

musimy teraz jakos zintegrowac wybieraczke z nasza architektura.

konkretnie chcielibysmy miec mozliwosc wyboru, czy chcemy
uzywac wbudowanej wybieraczki, czy systemowej (na androidzie
i ew. desktopie)
  
nalezaloby to zrobic tak, ze aktualna funkcja bylaby
parametrem

#+BEGIN_SRC scheme
  (define-parameter (open-file)::(maps (byte java.io.File Editor)
				       to: (maps _ to: void))
    (lambda (finger::byte editor::Editor)
      (lambda _
	(let ((keeper ::Keeper
		      (the-keeper)))
	  (keeper:with-read-permission
	   (lambda ()
	     (let ((window ::PopUp (open-file-browser
				    (keeper:initial-directory)
				    (this)))
		   (position ::Position
			     (last-known-pointer-position
			      finger)))
	       (window:center-around! position:left position:top)
	       (screen:overlay:add! window))))))))

  (define-parameter (save-file)::(maps (byte java.io.File Editor)
				       to: (maps _ to: void))
    (lambda _
      (let ((keeper ::Keeper
		    (the-keeper)))
	(keeper:with-write-permission
	 (lambda ()
	   (safely
	    (let ((window ::PopUp (save-file-browser
				   (keeper:initial-directory)
				   "filename.scm"
				   (this)))
		  (position ::Position
			    (last-known-pointer-position
			     finger)))
	      (window:center-around! position:left position:top)
	      (screen:overlay:add! window))))))
      #t))
#+END_SRC

* 10.10.2023 (komputer)

no to teraz rzecz tak wyglada, ze bysmy chcieli zrobic scrollowanie
myszka. Ale zeby to mialo sens, nalezaloby zrobic prolongowanie animacji.

Ale tego nie idzie zrobic ot tak, na szybko.

* 09.10.2023 (komputer)

bysmy zrobili zoomowanie i scrollowanie na myszce

no dobra, ale jak to musi działać?

to ciężki orzech do zgryzienia!

powinno być tak, że kiedy obracamy walkiem w dol, to wywolujemy
metode scroll-down! na obiekcie Screen

* 09.10.2023 (telefon)

tych wszystkich zoomow i tak raczej na telefonie nie przetestujemy
wiec sie zajmijmy czym innym

najlepiej ewaluacja

czyli: wciskamy ctrl+e albo ctrl+enter albo jakis
klawisz funkcyjny (np. F3), albo rysujemy dziubek,
i w trybie ewaluacyjnym wolamy eval


ale moze na androidzie skupmy sie na razie na tym bledzie
z przesunietym y?

albo wybieraczka?

no dobra, wydaje sie ze przesuniete y juz jest naprawione

to teraz wybieraczka

Na pewno musimy zaimportowac Intent i Url

* 08.10.2023

No dobra, to teraz plan jest taki, zeby:

- zdarzenie od mouse-wheela bylo traktowane jako page-up/page-down
- zaimplementowac funkcje scroll-up! i scroll-down! 
  oraz scroll-left! i scroll-right!
- zaimplementowac funkcje zoom-in! i zoom-out!
- obsluzyc rolke myszki w kliencie terminalowym

* 07.10.2023

no dobra, to teraz plan chyba powinien byc jasny, mianowicie
w najblizszym czasie chcemy miec zoomowanie i scrollowanie
za pomoca rolki myszki, oraz mozliwosc ewaluacji (i to sie
powinno wydarzac w nadchodzacym tygodniu)

przy okazji chcemy tez obsluzyc page up/down oraz
gest ewaluacji

a jak to sie uda, to sie zajmiemy bugami w cursor-under
oraz renderowaniem krawedzi dokumentu, i refaktoryzacja
kombinatorow

scrollowanie do gory:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(409,257),absolute(415,284),button=0,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=1,preciseWheelRotation=1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

scrollowanie w dol:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(238,156),absolute(244,183),button=0,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=-1,preciseWheelRotation=-1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

zoom in:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(213,176),absolute(219,203),button=0,modifiers=Ctrl,extModifiers=Ctrl,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=-1,preciseWheelRotation=-1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

zoom out:
java.awt.event.MouseWheelEvent[MOUSE_WHEEL,(219,164),absolute(225,191),button=0,modifiers=Ctrl,extModifiers=Ctrl,clickCount=1,scrollType=WHEEL_UNIT_SCROLL,scrollAmount=3,wheelRotation=1,preciseWheelRotation=1.0] on GRASP[,0,0,564x383,alignmentX=0.0,alignmentY=0.0,border=,flags=0,maximumSize=,minimumSize=,preferredSize=]

Plan jest taki, zeby:
1. dodac last-known-pointer-position
2. ...

hmm, no wlasnie, i tutaj mamy problem.

konkretnie problem jest taki, ze obsluge klawiszy mamy zrobiona inaczej,
niz obsluge przycisku myszy.

wiec to rodzi pytanie, czy nie powinnismy tego ujednolicic?
(tak jak bylo w SLAYERze)

rzecz jednak w tym, ze jest zasadniza roznica pomiedzy wciskaniem myszy,
a wciskaniem klawiszy - w przypadku myszy mamy jeszcze obsluge upuszczania

z kolei w przypadku rolki myszy, AWT daje nam takie rzeczy, jak:
- scrollAmount
- wheelRotation
- preciseWheelRotation

ale wyglada na to, ze one i tak zawsze maja takie same wartosci :/

* 06.10.2023

kilka idei:
- wybieraczka do pliku na androidzie
- wybieraczka do pliku na desktopie

* 05.10.2023

jeszcze mamy prawdopodobnie 2 moduly (co powinnismy
moc przetestowac kompilujac na zewnetrznym storage'u)

dobra, wyglada na to ze jest ok

czyli dalszy krok to bedzie:
- przeniesienie kodu z TODO do wlasciwego kodu
- zastapienie extent extent+
- dodanie czyszczenia extent-cache'u przed rysowaniem
- zastapienie wszystkich x:extent i (invoke x 'extent)
  uzyciem (extent+ x)

no dobra. ale skoro mamy troche czasu, moze warto by sie
zastanowic, jak bysmy chcieli, zeby to wygladalo w GRASPie

najpierw otwieramy plik project.grasp

jest to plik zawierajacy anotacje dla poszczegolnych modulow.
pobjego zaladowaniu otwiera sie przegladarka modulow - mozemy na moduly
albo klikac, albo zoomowac

No ale dobrze, teraz plan jest z grubsza taki, ze mamy sobie

#+BEGIN_SRC scheme
(define-property+ (last-known-pointer-position finger::byte)::Position
  (Position left: 0 top: 0))
#+END_SRC

i chcemy, zeby:
- pop-upy sie otwieraly wokol tej pozycji
- zoomowanie za pomoca ctrl + rolki myszki bylo wokol tej pozycji
- chcielibysmy tez pgup/pgdn
- i zeby combinators przyjmowaly wariadyczne argumenty
- i ewaluacje chcemy miec, a moze nawet kompilacje

dobrze by tez bylo napisac skrypty do budowania takie, zeby
z tych samych klas budowac wszystkie 3 klienty
i zeby sledzic zaleznosci podczas kompilacji

(i skrypty do budowania moglyby byc napisane w Kawie)

* 04.10.2023

wyglada na to, ze restrukturyzacja sie powiodla - poza modulem
(extent), ktorym musielibysmy sie zajac

i przy okazji bysmy chcieli zrobic cache'owanie:

#+BEGIN_SRC scheme
(define-property (extent-cached? tile::Tile)::boolean
  #f)
#+END_SRC

i przy renderowaniu bysmy robili

#+BEGIN_SRC scheme
(define-property+ (cached-extent tile::Tile)::Extent
  (Extent width: 0 height: 0))

(define (extent+ tile::Tile)::Extent
  (let ((cached ::Extent (cached-extent tile)))
    (unless (is tile extent-cached?)
      (let ((fresh ::Extent (tile:extent)))
        (cached:assign fresh)
	(set! (extent-cached? tile) #t)))
    cached))
#+END_SRC

i na poczatku renderowania dokumentu bysmy robili

#+BEGIN_SRC scheme
(reset! extent-cached?)
#+END_SRC

tadam!

poza tym trzeba w ramach restrukturyzacji zrobic jeszcze jedna zmiane,
mianowicie pozmieniac nazwy modulow. Tak na szybko:

#+BEGIN_SRC bash
./rename-module.sh "(editor types space)" "(editor types spaces)"
# ./rename-module.sh "(extent)" "(editor types measurements)"
./rename-module.sh "(editor types text)" "(editor types texts)"
./rename-module.sh "(editor types extensions extension)" "(editor types extensions extensions)"
./rename-module.sh "(editor interfaces painter)" "(editor interfaces painting)"
./rename-module.sh "(editor interfaces postponed)" "(editor interfaces delayed)"
./rename-module.sh "(editor types extensions button)" "(editor types extensions widgets)"
./rename-module.sh "(editor input recognizer)" "(editor input gestures)"
./rename-module.sh "(editor input transform)" "(editor input transforms)"
./rename-module.sh "(editor types extensions stepper)" "(editor types extensions visual-stepper)"
./rename-module.sh "(editor document history)" "(editor document history-tracking)"
#+END_SRC

mozna rozwazyc napisanie skryptu

no dobra, wydaje sie ze wiekszosc rzeczy juz tu mamy zalatwione,
jeszcze pozostaje nam nieco problematyczny (extent).

Na razie pomysl jest taki, zeby zawartosc tego modulu przeniesc do
(editor interfaces painting), ale czy to sie uda?

Sie udalo. To teraz jutro zrobimy to cache'owanie.

* 02.10.2023

zaczniemy od zmodyfikowania skryptu analdep.scm w taki sposob,
zeby dzialal w podkatalogach

* 01.10.2023

na razie plan jest taki, zeby podzielic pliki na foldery o tak:
(i ew. pozmieniac modulom nazwy)

** lang/
for.scm
assert.scm
while.scm
examples.scm
define-interface.scm
infix.scm
define-cache.scm
define-syntax-rule.scm
hash-table.scm
parameterize-up.scm
define-type.scm
mapping.scm
match.scm
define-object.scm
keyword-arguments.scm
curry.scm
define-parameter.scm
define-property.scm

** utils
functions.scm
server.scm
conversions.scm
string-building.scm
print.scm
io.scm

** editor/
*** types
text.scm
primitive.scm
fundamental.scm
space.scm
comments.scm
extent.scm

**** extensions/
combinators.scm
quotations.scm
button.scm
extension.scm
stepper.scm
interactive.scm

*** input/
android-keymap.scm
terminal-keymap.scm
desktop-keymap.scm
recognizer.scm
input.scm
pane.scm
editor-operations.scm
touch-event-processor.scm
transform.scm

*** interfaces/
painter.scm
postponed.scm
indexable.scm

*** document/
parse.scm
document-operations.scm
document.scm
cursor.scm
history.scm

** tests/
test-stepper.scm
test-document-operations.scm
test-editor-operations.scm
test-painter.scm
test-lanterna.scm
check-comments.scm
test-parser.scm

** tools/
braille.scm
analdep.scm
run.scm
reference-stepper.scm
play-test.scm

** clients
grasp-android.scm
grasp-terminal.scm
grasp-desktop.scm
grasp.scm
term.scm
text-painter.scm

** trash
primitive-terminal-client.scm
test-writing-map.scm

* 30.09.2023

Wyglada na to, ze problem mamy taki, ze komponenty wyrazenia, 
ktore powinny zostac dissolvowane, nie zostaja.

x/19 MORPHS INTO ((lambda/58 (x/59) (x/60 x/61))
                  (lambda/54 (x/55) (x/56 x/57)))

(x/20 x/21) MORPHS INTO (((lambda/54 (x/55)
                                 (x/56 x/57))
                                (lambda/58 (x/59)
                                 (x/60 x/61))
                               ))
(lambda/22 (x/23) (x/24 x/25)
) MORPHS INTO ((lambda/58 (x/59)
                                (x/60 x/61)))

** > 0.6

((lambda/54 (x/55) (x/56 x/57))
 (lambda/58 (x/59) (x/60 x/61))) MORPHS INTO ((x/20 x/21))

to jest OK

(lambda/54 (x/55) (x/56 x/57)) MORPHS INTO (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
to juz nam przeszkadza

lambda/54 MORPHS INTO (lambda/22)
(x/55) MORPHS INTO ((x/23))
(x/56 x/57) MORPHS INTO ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)
) MORPHS INTO (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 MORPHS INTO (lambda/22)
(x/59) MORPHS INTO ((x/23))
(x/60 x/61) MORPHS INTO ((x/24 x/25))

* 29.09.2023

postanowienie jest takie, zeby sie zajac ((lambda (x) (x x)) (lambda (x) (x x)))
ale zacznijmy od tego, ze sobie opiszemy, co jest nie tak z biezacym zachowaniem,
albo w jaki sposob chcielibysmy, zeby to wygladalo.

1(2(lambda1 3(x2) 4(x3 x4)) 5(lambda5 6(x6) 7(x7 x8)))

W wyniku oczekujemy nowego wyrazenia

A(B(lambdaA C(xB) D(xC xD)) E(lambdaE F(xF) G(xG xH)))

i teraz tak:

- wyrazenie 4(x3 x4) powinno przemorfowac w A(B E)
- argument x2 powinien przemorfowac w B i E,
  ktore sa kopiami 5
- nawiasy 1 powinny zniknac
- nawiasy 2 powinny zniknac
- lambda1 i nawiasy 3 powinny zniknac
- cale wyrazenie 5 i jego podwyrazenia powinny zniknac
  (ale jego kopie, czyli B i E, powinny byc progeny
  wyrazenia x2, i oczywiscie x2 powinno byc ich originem)

Na razie wyglada tak, ze operandy sie nie dissolvuja

Teraz niejako wymusilismy na nich dissolvowanie sie

OK, juz prawie to mamy, tylko jeszcze z jakichs wzgledow w drugiej
polowie sie nam narysowywuja wyrazenia

* 29.09.2023

postanowienie jest takie, zeby sie zajac ((lambda (x) (x x)) (lambda (x) (x x)))
ale zacznijmy od tego, ze sobie opiszemy, co jest nie tak z biezacym zachowaniem,
albo w jaki sposob chcielibysmy, zeby to wygladalo.

1(2(lambda1 3(x2) 4(x3 x4)) 5(lambda5 6(x6) 7(x7 x8)))

W wyniku oczekujemy nowego wyrazenia

A(B(lambdaA C(xB) D(xC xD)) E(lambdaE F(xF) G(xG xH)))

i teraz tak:

- wyrazenie 4(x3 x4) powinno przemorfowac w A(B E)
- argument x2 powinien przemorfowac w B i E,
  ktore sa kopiami 5
- nawiasy 1 powinny zniknac
- nawiasy 2 powinny zniknac
- lambda1 i nawiasy 3 powinny zniknac
- cale wyrazenie 5 i jego podwyrazenia powinny zniknac
  (ale jego kopie, czyli B i E, powinny byc progeny
  wyrazenia x2, i oczywiscie x2 powinno byc ich originem)

Na razie wyglada tak, ze operandy sie nie dissolvuja

Teraz niejako wymusilismy na nich dissolvowanie sie

OK, juz prawie to mamy, tylko jeszcze z jakichs wzgledow w drugiej
polowie sie nam narysowywuja wyrazenia


1(2(lambda1 3(x2) 4(x3 x4)) 5(lambda5 6(x6) 7(x7 x8)))

A(B(lambdaA C(xB) D(xC xD)) E(lambdaE F(xF) G(xG xH)))


╭ ╭           ╭      ╮  ╮ ╮
│ │ lambda/18 │ x/19 │  │ │
│ │           ╰      ╯  │ │
│ │ ╭      ╮            │ │
│ │ │ x/20 │            │ │
│ │ │      │            │ │
│ │ │      │            │ │
│ │ │ x/21 │            │ │
│ ╰ ╰      ╯            ╯ │
│ ╭ ~      ~  ╭      ╮ ╮  │
│ │ lambda/22 │ x/23 │ │  │
│ │           ╰      ╯ │  │
│ │ ╭      ╮           │  │
│ │ │ x/24 │           │  │
│ │ │      │           │  │
│ │ │      │           │  │
│ │ │ x/25 │           │  │
╰ ╰ ╰      ╯           ╯  ╯

╭ ╭           ╭      ╮ ╮ ╮
│ │ lambda/54 │ x/55 │ │ │
│ │           ╰      ╯ │ │
│ │ ╭      ╮           │ │
│ │ │ x/56 │           │ │
│ │ │      │           │ │
│ │ │      │           │ │
│ │ │ x/57 │           │ │
│ ╰ ╰      ╯           ╯ │
│ ╭ ~      ~  ╭      ╮ ╮ │
│ │ lambda/58 │ x/59 │ │ │
│ │           ╰      ╯ │ │
│ │ ╭      ╮           │ │
│ │ │ x/60 │           │ │
│ │ │      │           │ │
│ │ │      │           │ │
│ │ │ x/61 │           │ │
╰ ╰ ╰      ╯           ╯ ╯

** najpierw

x/19 morphs into ((lambda/58 (x/59) (x/60 x/61))
                  (lambda/54 (x/55) (x/56 x/57)))

(x/20 x/21) morphs into (((lambda/54 (x/55) (x/56 x/57))
                          (lambda/58 (x/59) (x/60 x/61)))
                         ((lambda/54 (x/55) (x/56 x/57))
                          (lambda/58 (x/59) (x/60 x/61))))

(lambda/22 (x/23) (x/24 x/25)) morphs into ((lambda/58 (x/59)
                                (x/60 x/61)))

** i w druga strone:

((lambda/54 (x/55) (x/56 x/57))
 (lambda/58 (x/59) (x/60 x/61))) morphs into ((x/20 x/21)(x/20 x/21))
(lambda/54 (x/55) (x/56 x/57)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/54 morphs into (lambda/22)
(x/55) morphs into ((x/23))
(x/56 x/57) morphs into ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 morphs into (lambda/22)
(x/59) morphs into ((x/23))
(x/60 x/61) morphs into ((x/24 x/25))
(lambda/54 (x/55) (x/56 x/57)
 . #<not a pair>) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/54 morphs into (lambda/22)
(x/55) morphs into ((x/23))
(x/56 x/57) morphs into ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 morphs into (lambda/22)
(x/59) morphs into ((x/23))
(x/60 x/61) morphs into ((x/24 x/25))

** po zmianach

*** najpierw

x/19 morphs into ((lambda/58 (x/59) (x/60 x/61)
                  )
                  (lambda/54 (x/55) (x/56 x/57)
                  ))
(x/20 x/21
) morphs into (((lambda/54 (x/55)
                                 (x/56 x/57))
                                (lambda/58 (x/59)
                                 (x/60 x/61))
                               ))
(lambda/22 (x/23) (x/24 x/25)
) morphs into ((lambda/58 (x/59)
                                (x/60 x/61)))


*** i w druga strone

((lambda/54 (x/55) (x/56 x/57))
 (lambda/58 (x/59) (x/60 x/61))) morphs into ((x/20 x/21))
(lambda/54 (x/55) (x/56 x/57)) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/54 morphs into (lambda/22)
(x/55) morphs into ((x/23))
(x/56 x/57) morphs into ((x/24 x/25))
(lambda/58 (x/59) (x/60 x/61)
) morphs into (x/19
                               (lambda/22 (x/23)
                                (x/24 x/25)))
lambda/58 morphs into (lambda/22)
(x/59) morphs into ((x/23))
(x/60 x/61) morphs into ((x/24 x/25))

* 29.09.2023 (telefon)

na kompie dalej procesujemy lambdy, i moze sie to uda jakos
zrobic

natomiast co chcemy robic dalej?

jest sporo takich rzeczy, no powiedzmy, nieciekawych,
ktorymi jednak warto by sie bylo zajac, takimi jak edycja,
czy poruszanie sie kursorem po przyciskach, czy tez wiele
innych tego rodzaju rzeczy, ktore zapewne by trzeba bylo
skatalogowac

jest tez kwestia uporzadkowania repo, i to chyba lepiej
by bylo zrobic szybciej niz pozniej

a, no i integracja ewaluatora, i ewentualnie kolorowanie
wyrazen

i scrollowanie, pg-up/pg-dn, zoomowanie etc.

natomiast tym, co naprawde chcemy robic dalej, jest algorytm A*
i wizualizacja grafow

* 28.09.2023

bysmy sie zajeli tym, zeby nienazwane lambdy redukowac inaczej,
niz lambdy nazwane

w przypadku lambd nazwanych:
- wartosci argumentow rozszczepiaja sie do ciala

natomiadt w przypadku lambd nienazwanych
- wartosc argumentu znika, ale
- argumenty z lambdy morfuja w kopie argumentow

* 27.09.2023

przede wszystkim mamy do zrobienia renderowanie ramek w kliencie
androidowym, oraz przywrocenie dzialania klawiatury

na razie pomysl jest taki. zeby dodac haki

* 25.09.2023

dziaiaj nic nie musimy, bo jutro konferencja
czyli male swieto

natomiast dobrze by bylo zaimplementowac draw-border!
oraz border-size na Androidzie (i to by byl srodowy commit)

ale poza tym pizostaje nam w tym tygodniu:
- czwartek, piatek, sobota

i teraz bysmy wzieli na tapet, no, cos innego?

pomyslow jest kilka:
- wizualizacja grafow
- naprawianie bugow?
- obsluga rolki myszki

* 23.09.2023

dzisiaj bysmy sie zajeli tymi guzikami

no dobra, to poszlo szybko

to teraz nam jeszcze pozostaja takie rzeczy:
- po pierwsze, cos sie brzydko te nawiasy renderuja
- po drugie, musimy zrobic obwodkie wokol steppera
- po trzecie, musimy naprawc to, ze jak dochodzimy
do konca, to potem sie nie mozemy cofac

* 22.09.2023

bledy na dzis:
1. to ze sie nam 5 nie roztraja
2. jak dochodzimy do 120, to potem nie mozemy sie cofnac

(jak to sie uda zrobic, to bedzie niezle, ale w naszym backlogu
musi byc jeszcze zepsuta obsluga guzikow, i brak obwodki wokol
steppera)

To teraz zajmimy sie tym roztrajaniem piatek (bo sprawa wydaje sie
powazna)

Otoz chodzi o to, ze jak dokonujemy redukcji lambdy, to powinnismy
wtedy rowniez aktualizowac argumenty

OK, wydaje sie ze to juz jest robione, ale w dalszym ciagu cos
jest nie tak.

Mianowicie chodzi o to, ze:
- jezeli zrodlowa piatka jest rysowana jako foreground, to
wydaje sie OK (pomijajaca to, ze docelowa piatka jest rysowana
na backgroundzie)
- jezeli zas najpierw rysujemy destination, to zrodlowa piatka
w ogole nie jest rysowana


* 21.09.2023

Musimy sie teraz dowiedziec dlaczego jak mamy transformacje z

(* 5@1 (! (pred 5@2)))

do

(* 5@3 (! 4))

to odpowiednikiem 5@2 jest 5@3

bo to, ze 5@3 jest odpowiednikiem 5@1 nie jest w ogole
zaskakujace i tak powinno byc

No to przemyslmy.

ORIGIN of 5 1991027336: (n) (1456412048)
ORIGIN of 5 1319877582: (n n) (1456412048 1456412048)
ORIGIN of 5 823397198: (n n n) (1456412048 1456412048 1456412048)
drawing identical 5 1279377109 1991027336 (5) (1991027336)

No dobra, to teraz plan jest taki:
1. dodajemy interfejs "matchable" i warunek w pattern matcherze
2. implementujemy ten interfejs w Atomie
3. usuwamy implementacje hashCodei equals z Atomu
4. robimy wyszukiwanie oparte o "name" atomu

Wydaje sie, ze te rzeczy juz jako tako dzialaja.

Teraz do zrobienia mamy znowuz:
- wyjasnienie, dlaczego zamykajace nawiasy na siebie nachodza
- wyjasnienie, dlaczego ! -> (if ...) dziala OK, ale jak rysujemy
  w druga strone, tj. (if -> ...) -> !, to juz nie dziala
  (i naprawienie tego)
- sprawienie, zeby ta nieszczesna 5-tka sie roztrajala,
  bo to bedzie bardzo fajne

A jak to sie uda, to bysmy jeszcze sie zajeli naprawa guzikow
i rysowaniem obwodki wokol steppera.

* 21.09.2023 (telefon)

po pierwsze, z jakichs wzgledow "n" przy substytucji
jest zawsze zamienialne


no ale ale, wyglada na to, ze mamy naszego winowajce
- a jest nim tozsamosc atomu, ktorej uzywamy do wydobywania
  elementow ze srodowiska

zatem teraz plan jest raki, zeby pozbyc sie tozsamosci atomu,
i zeby uzywac nazwy tego atomu do wysxukiwania


* 20.09.2023

problemy, ktore chcemy teraz rozwiazac:

1. przy morfowaniu

(if (<= 5 0)
    1
    (* 5 (! (pred 5))))

do

(if #f
    1
    (* 5 (! (pred 5))))

nagle w tle pojawia sie <=, 0 oraz ostatnie 5

2. przy morfowaniu

(if #f
    1
    (* 5 (! (pred 5))))

do

(* 5 (! (pred 5)))

pozycje wyrazen sa odwrocone.

Byc moze jest tak, ze w "draw-morph!" zamieniamy
ze soba role argumentow?

3. jak mamy (* 5 (! (pred 5)))

to sie nam to wyswietla jako

(*   (! (pred 5)

Wyglada na to, ze tutaj problemem jest to, ze symbole * i 5
pojawiaja sie wiele razy

4. chcielibysmy jeszcze, zeby 5 z (! 5) bylo utozsamiane
z trzema wystapieniami 5 w definiensie
(i na to trzeba wypracowac jakis mechanizm)

Jednakowoz zajmijmy sie najpierw tym pierwszym problemem.

* 19.09.2023 (wieczor, komp)

na razie wyglada na to, ze mamy problem z tozsamoscia
obiektow. zatem plan jest pokrotce taki:
1. zmieniamy domyslne odwzorowanie pochodzenia/potomnosci
z (recons element '()) na '()
2. do reduce/substitute dodajemy kopiowanie atomow
+ sledzenie pochodzenia
3. musimy jeszcze jako uwzglednic tranzytywnosc
czegos takiego, ze mamy kilka n-ow, i one sa zastepowane
przez 5-tke

(! 5)

(lambda (n)
  (if (<= n 1)
     1
    (* n (! (- n 1)))))

(if (<= 5 1)
   1
  (* 5 (! (- 5 1))))

Na poziomie kodu odbywa sie to w taki sposob, ze wewnatrz
reduce'a robimy (reduce (cons (context:value operator) operands)),
i ten wewnetrzny reduce maczuje operator do `(lambda ,args ,body)
i robi (substitute args #;with operands #;in body).

* 19.09.2023 (telefon)

mamy stepper, ktory oglednie wydaje sie jakos dzialac,
ale w ktorym roi sie od bugow

wiec plan teraz jest taki:
- zdiagnozowac i naprawic to co sie tam dzieje
- zrobic obwodke wokol steppera
- ponaprawiac guziki

jezeli to wszystko sie uda, to dodalibysmy jeszcze
mozliwosc ewaluacji wyrazen (ctrl+enter / klin)
i bysmy mieli w zasadzie wszystko gotowe do wtorkowego
dema (i wtedy jeszcze moze bysmy zrobili animacje
wcisnietego guzika, i ewentualnie wciskanie guzikow
z klawiatury)

ale najpierw trzeba sie zajac tymi bledami w animacjach
i przemyslec to, jak je najlepiej diagnozowac

no to moze tak: bysmy zrobili, zeby guzik >| nie odpalal
animacji, a tylko zwiekszal progress w biezacym morphie,
a po dojsciu do 1.0 aktualizowal morpha - i wtedy bysmy sobie
krok po kroku ogladali co sie dzieje, najpierw z tlem,
a pozniej z foregroundem

jezeli to sie uda jako tako spiac, to bysmy najpierw zrobili
ramke wokol steppera, a nastepnie naprawili guziki,
zmieniajac kombinatory w taki sposob, zeby mogly przyjmowac
dowolnie wiele argumentow

* 18.09.2023

wyglada na to, ze musimy dostosowac nasz stepper
do wspolpracy z atomami.

do tego celu bedziemy potrzebowac:
- funkcji "grasp", ktora zmieni nam reprezentacje
lispowa obiektu na reprezentacje graspowa (czyli pairy na consy,
liste pusta na (empty), stringi na Text, a pozostale atomy
na Atomy)

 ;"▮◀◀"
 ;"▮◀ "
;;" ▶ "
;" ▶▮"
;"▶▶▮"

* 17.09.2023

potrzebujemy terax sobie zdefiniowac:
- morph-from
- morph-to

* 16.09.2023

bysmy sie zajeli memoizacja:

(memoize proc) musi dzialac tak, ze rekurencyjnie
wydobywa cache, a w momencie, gdy


* 15.09.2023

wydaje sie, ze teraz nam pozostalo:
- kopiowanie cell-display-properties
- zbudowanie playera

no, to teraz juz tylko zbudowanie playera xD


▴
▾
▲
▼

▮◀◀  ▮◀  ▶/▮▮  ▶▮  ▶▶▮


#+BEGIN_SRC scheme

  (define (PlayerWithControls player::Playable)
    (Below
	 top: player
	 bottom:
	 (Beside
	  left:
	  (Beside left: (Button label: "|<<"
				action: (lambda () (player:rewind!)))
		  right: (Button label: " |<"
				 action: (lambda () (player:back!))))
	  right:
	  (Beside
	   left: (Button label: " > "
			 action: (lambda () (player:play!)))
	   right:
	   (Beside left: (Button label: ">| "
				 action: (lambda () (player:next!)))
		   right: (Button label: ">>|"
				  action: (lambda ()
					    (player:fast-forward!))))))))
#+END_SRC

przy tej okazji mozemy zrefaktoryzowac Beside, Below i Over w taki
sposob, zeby braly listy elementow (zamiast par)

A moze na razie nie?

ok, to robimy

#+BEGIN_SRC scheme
(define-interface Playable ()
  (rewind!)::void
  (back!)::void
  (play!)::void
  (pause!)::void
  (next!)::void
  (fast-forward!)::void
  (playing?)::boolean)
#+END_SRC


#+BEGIN_SRC scheme
  ;; potrzebujemy takiego czegos, co by nam reprezentowalo
  ;; ewaluacje
  ;; Na razie mamy sobie klase Morph, i instancje tej klasy
  ;; i teraz tak:

  ;; jak musi dzialac nastepny krok?

  (define (next!)::void
    (let-values (((reduced origins progenies) (reduce next-expression)))
      (unless (equal? reduced next-expression)
	(let ((morph ::Morph (morph-between next-expression reduced
					    origins progenies)))
	(set! next-expression reduced)))))



#+END_SRC


  
* 14.09.2023

wydaje sie, ze spora czesc do tej pory napisanego kodu udalo sie
inkorporowac do modulu (stepper).

zasadniczo pozostaje nam jeszcze kopiowanie cell-display-properties
oraz kwestia substytucji

cell-display-properties jakos rozwiazemy, natomiast teraz musimy
przemyslec pewne aspekty zwiazane z substytucja

chodzi mianowicie o to, ze ilekroc dokonujemy substytucji,
chcemy otrzymywac nie podstawiony element, tylko jego kopie
(i to ja chcemy dodawac do dokumentu)

oznacza to, ze kazdy Element, a w kazdym razie kazdy Tile,
powinien byc Cloneable

wiec na te chwile plan jest taki:
1. sprawdzic, czy to, co mamy w tej chwili, nie robi
   problemiw przy budowaniu (i ew. naprawic)
2. zrobic commita

3. zajac sie tym, zeby Element byl clonable

lista instancji Element:
- Atom
- cons
- text
- comment
- quotation

 
* 13.09.2023

no to dzosiaj co robimy?
- modul stepper oraz funkcje do sledzenia "progenies"
  

* 12.09.2023

udalo sie nam sprawdzic to co chcemy, dopisujac testa.
wiec na razie mozemy sie wstrzymac z implementacja
ewaluacji (choc niewatpliwie dobrze by to bylo zrobic
w niedlugim czasie)

natomiast teraz trzeba wrocic do naszej ewaluacji

na raxie problem jest taki, ze ten nasz interpreter
nie zalezy od modulu primitive, a powinien, zebysmy
mieli dostep do takich czarodziejstw, jak cons*

wiec rzecz wyglada tak, ze:
- mamy referencyjny interpreter o zminimalizowanych zaleznosciach
- na jego bazie chcemy zbudowac docelowy interpreter, ktory
  - bedzie uzywal 'cons' z (primitive)
  - bedzie kopiowal cell-display-properties
  - bedzie odpowiednio ustawial origins i progenies
  - bedzie unikal kopiowania elementow, ktore sie nie zmieniaja
  - bedzie kopiowal elementy wynikajace z substytucji

i jak juz to sie nam uda napisac, to bedzie trzeba zrobic
ten widget playera

* 11.09.2023

przed dalszymi pracami bysmy dodali mozliwosc
ewaluacji wyrazen, co musi sie dziac w nastepujacych
krokach
1. wybieramy wyrazenie poprzedzajace kursor
2. w trybie ewaluacji wywolujemy 'eval'
3. wynik wyrazenia konwertujemy do postaci
   graspo-strawnej
4. wyrazenie wklejamy do terget-view (na razie
   przyjmujemy po prostu biezacy edytor)
   w okolicach aktualnego kursora


#+BEGIN_SRC scheme
  (define (focused-expression #;inside document #;at cursor)
    (otherwise #!null
      (and (is #;< (length cursor) > 1)
      ...)))
#+END_SRC

* 10.09.2023

mamy juz nawet przetestowany modul interpretera

no i co tera?

tera by my chcieli, zeby podczas redukcji 
zachowywac informacje o tym, ktore wyrazenia
stanowia odpowiedniki ktorych

do tego dochodzi jeszcze taka kwestia, ze mamy
te 'dwa swiaty': swiat ewaluacji i swiat edycji.

i tak: patterny sa pisane w 'jezyku ewaluacji',
ale moglibysmy sie postarac robic tak, zeby to nie mialo
znaczenia

z pewnoscia bedziemy potrzebowac zapewnienia, ze
patterny dzialaja zarowno w trybie edycji, jak i
ewaluacji

kolejna rzecz jest taka:
- jezeli wyrazenie zrodlowe i docelowe sa equal?
  to robimy

   (add! ((the-origin) result) source)
   (add! ((the-progeny) source) result)

   i w przypadku list iterujemy dodatkowo po
   wsztstkich elementach

- jezeli jeden element jest zawarty w drugim,
  to zbajdujemy ten element i robimy

  (add! ((the-origin) child) parent)
  (add! ((the-progeny) parent) child)

  i dodatkowo rekurencyjnie kojarzymy
  ze sobą wssystkie elementy child
  i podwyrazenia parent

Natomiast w przypadku substytucji powinno byc tak,
ze za kazdym razem, kiedy dokonujemy substytucji:
- generujemy nowa kopie symbolu
- jako origin tego symbolu dodajemy odpowiednia wartosc
  z tablicy 'origin'

#+BEGIN_SRC scheme
  (property (item) (recons item '()))

  (define-parameter (the-origins)::(!maps (Object) to: (list-of Object))
    (lambda (x) (recons x '())))

  (define-parameter (the-progenies)::(!maps (Object) to: (list-of Object))
    (lambda (x) (recons x '())))

  (define (tracking-relations source
			      target
			      origins := (the-origins)
			      progenies := (the-progenies))
    (cond
      ((equal? source target)
       ;; here we simply go with the default option
       target)

      ((and (pair? source)
	    (any. (is _ equal? target) source))
       (for x in source
	 (cond
	  ((equal? x target)
	   (set! (progenies x) (recons source '()))
	   (set! (origins target) (recons x '())))
	  (else
	   (set! (progenies x) '())
	   target))))
      ))

#+END_SRC


Ogolnie wydaje sie, ze najwygodniej bedzie dodac do edytora
mozliwosc ewaluacji wyrazen

* 09.09.2023

wydaje sie, ze mamy juz napisany reduktor wyrazen ktory ma
szanse zadzialac, ale trzeba go teraz przetestowac

dlatego bysmy stworzyli modul interpreter, ktory by zawieral
te nasze funkcje

* 08.09.2023

dotychczasowy progres chyba trzeba przepisac z komputera
(albo wrzucic na brancha czy cos)

natomiast warto sie zastanowic albo nad stworzeniem trackujacej
wersji matcha, albo nad jakas owijka

#+BEGIN_SRC scheme

    (define (reduce expression context::EvaluationContext)
      (match expression
	(`(if #f ,then ,else)
	 else)
	(`(if ,test ,then ,else)
	 (let ((test* (reduce test context)))
	   (if (equal? test reduced-test)
	       then
	       `(if ,test* ,then ,else))))
	(`(lambda ,args ,body)
	 expression)
	(`(quote ,_)
	 expression)
	(`(,operator . ,operands)
	 (if (and (symbol? operator)
		  (context:defines-macro? operator))
	     (error "Macros not supported (yet)")
	     (let ((operands* (reduce-operands operands context)))
	       (if (isnt operands equal? operands*)
		   `(,operator . ,operands*)
		   (match operator
		     (,@symbol
		      (cond ((context:primitive? operator)
			     (apply (context:value operator)
				    operands))
			    ((context:defines? operator)
			     (reduce `(,(context:value operator)
				       . ,operands)
				     context))
			    (else
			     `(,operator . ,operands))))
		     (`(lambda ,args ,body)
		      (substitute args #;with operands
				  #;in body))
		     (`(,_ . ,_)
		      (let ((operator* (reduce operator
					       context)))
			`(,operator* . ,operands)))
		     (_
		      `(,operator . ,operands)))))))
	(_
	 (if (and (symbol? expression)
		  (context:defines? expression))
	     (context:value expression)
	     expression))))

    (define (reduce-operators operators context::EvaluationContext)
      (match operators
	(`(,first . ,rest)
	 (let ((first* (reduce first context)))
	   (if (equal? first first*)
	       `(,first . ,(reduce-operators rest context))
	       `(,first* . ,rest))))
	('()
	 '())
	(_
	 (reduce operators context))))

    (define (in. element collection)
      (any. (is _ eq? element) collection))

    (define (substitute variables #;with values #;in expression)
      (match expression
	(`(quote ,_)
	 expression)
	(`(lambda ,args ,body)
	 (let-values (((variables* values*) (only. (isnt _ in. args)
						   variables values)))
	   `(lambda ,args
	      ,(substitute variables* #;with values*
			   #;in body))))
	(`(,operator . ,operands)
	 `(,(substitute variables #;with values #;in operator)
	   . ,(substitute variables #;with values #;in operands)))
	(_
	 (if (symbol? expression)
	     (counterpart #;of expression #;from variables
			       #;in values)
	     expression))))

    (define (counterpart #;of variable #;from variables
			      #;in values)
      (match variables
	(`(,,variable . ,_)
	 (car values))
	(,variable
	 values)
	(`(,_ . ,rest)
	 (counterpart #;of variable #;from rest
			   #;in (cdr values)))
	(_
	 variable)))

  (define-object (EvaluationContext)
    ;;(define macro-definitions ::)

    (define definitions ::java.util.Map
      (let ((table ::java.util.Map (java.util.HashMap)))
	(table:put '+ +)
	(table:put '- -)
	(table:put '* *)
	(table:put '/ /)
	(table:put '< <)
	(table:put '<= <=)
	(table:put '> >)
	(table:put '>= >=)
	(table:put '= =)
	(table:put 'eq? eq?)
	(table:put 'eqv? eqv?)
	(table:put 'cons cons)
	(table:put 'car car)
	(table:put 'cdr cdr)
	table))

    (define (value symbol)
      (cond ((definitions:contains-key symbol)
	     (definitions:get symbol))
	    (else
	     (error "undefined symbol: "symbol))))

    (define (defines-macro? symbol)
     #f)

    (define (defines? symbol)
      (definitions:contains-key symbol))

    (define (define! name value)
      (definitions:put name value))

    (define (primitive? symbol)
      (and (definitions:contains-key symbol)
	   (let ((value (definitions:get symbol)))
	     (procedure? value))))
    )

#+END_SRC

* 07.09.2023

wydaje sie ze mamy juz wszystkie polprodukty
do zaimplementowania Morpha

to teraz potrzebujemy planu co robic dalej

no bo przeciez chcielibysmy miec tego morpha w naszej
bazie kodu jak najszybciej?

1. przenosimy kod z TODO do nowego modulu,
   (visual-evaluator)
2. piszemy kod odpowiedzialny za redukcje wyrazen,
   ktory dodatkowo buduje tablice, origin i progeny
3. piszemy sobie klase EvaluationPlayer, ktora
   zawiera guziki i tworzy nowe wyrazenia na zadanie
4. integrujemy EvaluationPlayer z interfejsem
   za pomoca gestu zagla

No dobra, to sprobujmy napisac sam ewaluator - przy czym
dla kazdego zastepujacego wyrazenia musimy tworzyc
nowa kopie!

#+BEGIN_SRC scheme

  (define (reduce expression context)
    (match expression
      (`(quote ,_)
       (set! (context:origin expression)
	     (union (context:origin) expression))
       (set! (context:progeny expression)
	     (union (context:progeny) expression))
       expression)
      (`(if #false ,then ,else)
       else)
      (`(if ,test ,then ,else)
       (let ((reduced-test (reduce test context)))
	 (if (equal? test reduced-test)
	     then
	     `(if ,reduced-test ,then ,else))))
      (`(lambda ,args . ,body)
       expression)
      (`(,operator . ,operands)
       (if (macro? operator context)
	   ...
	   (let ((reduced-operands (reduce-operands
				    operands
				    context)))
	     (if (equal? operands reduced-operands)



#+END_SRC

* 07.09.2023 (wieczorem, laptop)

Teraz bysmy chcieli napisac sobie cos, co by nam przeprowadzalo
redukcje

#+BEGIN_src scheme
(define (reduce expression context)
  (match expression
    (`(if #f ,then ,else)
     else)
    (`(if ,test ,then ,else)
     (let ((test* (reduce test context)))
       (if (equal? test test*)
          then
          `(if ,test* ,then ,else))))
    (`(quote ,_)
      expression)
    (`(lambda ,args ,body)
     expression)
    (`(,operator . ,operands)
     (if (context:defines-macro? operator)
         (error "Macros not supported (yet)")
         (let ((operands* (reduce-operands operands context)))
	   (if (isnt operands equal? operands*)
               `(,operator . ,operands*)
               (match operator
                 (,@symbol?
                  (if (context:primitive? operator)
                     (apply (context:value operator) operands)
                     `(,operator . ,operands)))
		 (`(lambda ,args ,body)
                   (substitute args #;with operands #;in body))
                 (`(,_ . ,_)
                  (let ((operator* (reduce operator context))) 
                    `(,operator* . ,operands)))
                 (_
                  `(,operator . ,operands)))))))
    (_
     (if (symbol? expression)
        (context:value expression)
        expression))))
                    
(define (substitute variables #;with values #;in expression)
  (match expression
    (`(quote ,_)
     expression)
    (`(lambda ,args ,body)
     (let-values (((variables* values*) (remove args #;from variables #;& values)))
       `(lambda ,args ,(substitute variables* #;with values* #;in body))))
    
    
#+END_src

* 06.09.2023

mamy with-intensity dla klientow graficznych, zostaje nam jeszcze
wariant dla klienta terminalowego - i jak to zrobimy, to bysmy
sie zajeli with-stretch

No to w kliencie terminalowym rzecz wyglada tak, ze mamy jedna
funkcje, letter, ktora przyjmuje argumenty domyslne
(the-text-color) oraz (the-background-color).

Mozemy ja teraz tak zmienic ze dodamy parametr
(the-text-intensity), i ze ona sobie bedzie w srodku
obliczac fakyyczny text-color jako interpolacje
pomiedzy kolorem tekstu i tla

oks, with-intensity juz mamy. teraz trzeba zrobic mala analize

no to tak:
- w przypadku klientow graficznych powinna wystarczyc
  zmiana skali oraz takie przesuniecie, ktore skompensuje
  zmiane skali na pozycji current-translation-left
  oraz current-translation-top
- w przypadku klientow tekstoeych nalezaloby odpowiednio
  zmienic definicje put!, tak zeby mnozyl docelowa wspolrzedna
  przez okreslona wartosc i ja zaokraglal


* 05.09.2023

to teraz mamy dwie rzeczy:
- painter:with-intensity
- painter:with-stretch

zaczniemy od with-intensity, bo tak

i teraz namy 3 klienty

w kkientach graficznych zamysl jest taki, zeby przeanalizowac
uzycia setColor

* 04.09.2023

zostaje nam jeszcze do przemyslenia kwestia implementacji
render-foreground! w kontekscie implementacji 'draw-morph!'

no to rzecz wyglada tak, ze chyba bysmy chcieli miec troche
symetrii z render-background!

no bo tak:
- draw-morph! przeksztalca nam dwa wyrazenia
- draw-background! rysuje wyrazenia tla, ktore
  nie maja swoich odpowiednikow (w szczegolnosci
  rysuje dla pudelek same nawiasy)
- a draw-foreground! powinien
  - dla wyrazen bez swoich odpowiednikow dzialac
    analogicznie do 'draw-background!' (moze nawet
    go wywolywac, choc to mogloby powodowac, ze to
    samo wyrazenie byloby wywolywane wiecej niz raz)
  - dla pozostalych wyrazen powinien rysowac morphy
    pomiedzy nimi a odpowiednikami

#+BEGIN_SRC scheme
  (define (render-foreground! expression::Element
			      counterparts::(maps (Element)
						  to: (list-of
						       Element))
			      source-position::(maps (Element)
						     to: Position)
			      target-position::(maps (Element)
						     to: Position)
			      intensity::float)
    ::void
    (let ((links (counterparts item))
	  (painter ::Painter (the-painter)))
      (cond
       ((empty? links)
	(draw-emerging! expression
			(source-position expression)
			intensity)
	(when (gnu.lists.LList? expression)
	  (traverse
	   expression
	   doing:
	   (lambda (sub::element t::Traversal)
	     (render-foreground! sub counterparts
				 source-position
				 target-position
				 intensity)))))

       (else
	(for x in links
	  (draw-morph! item x counterparts
		       source-position
		       target-position
		       intensity))))))
#+END_SRC

ok, wydaje sie ze mamy to.

teraz pozostaja nam do zaimplementowania:

- painter:with-intensity
- painter:with-stretch

we wszystkich 3 klientach, czyli w klientach graficznych
trzeba zadbac o to, zeby wszystkie dotychczasowe renderowania
uwzglednialy przezroczystosc

* 03.09.2023

a dzis z kolei bysmy sprobowali zaimplementowac draw-morph

#+BEGIN_SRC scheme

  (define (draw-morph! foreground::Element
		       background::Element
		       counterparts::(maps (Element)
					   to: (list-of
						Element))
		       source-position::(maps (Element)
					      to: Position)
		       target-position::(maps (Element)
					      to: Position)
		       intensity::float)
    ::void
    (let* ((p0 ::Position (source-position foreground))
	   (p1 ::Position (target-position background))
	   (painter ::Painter (the-painter))
	   (left ::real (linear-interpolation
			 from: p0:left to: p1:left
			 at: progress))
	   (top ::real (linear-interpolation
			from: p0:top to: p1:top
			at: progress)))
      (cond
       ((equal? foreground background)
	;; here we just draw the foreground
	;; with full intensity
	(with-translation (left top)
	  (draw! foreground)))

       ((or (isnt foreground Tile?)
	    (isnt background Tile?))
	;; at least one of the elements is (presumably)
	;; a space, so the only way we can morph them
	;; is by fading
	(with-translation (left top)
	  (painter:with-intensity (- 1.0 intensity)
	    (lambda ()
	      (draw! background)))
	  (painter:with-intensity intensity
	    (lambda ()
	      (draw! foreground)))))

       ((and (gnu.lists.LList? foreground)
	     (gnu.lists.LList? background))
	(let* ((e0 ::Extent (extent foreground))
	       (e1 ::Extent (extent background))
	       (width ::real (linear-interpolation
			      from: e0:width to: e1:width
			      at: progress))
	       (height ::real (linear-interpolation
			       from: e0:height to: e1:height
			       at: progress)))
	  (with-translation (left top)
	    (painter:draw-box! width height))
	  (traverse
	   foreground
	   doing:
	   (lambda (item::Element t::Traversal)
	     (render-foreground! item
				 counterparts
				 source-position
				 target-position
				 intensity)))))
       ((and (Tile? foreground)
	     (Tile? background))
	(let* ((e0 ::Extent (extent foreground))
	       (e1 ::Extent (extent background))
	       (width ::real (linear-interpolation
			      from: e0:width to: e1:width
			      at: progress))
	       (height ::real (linear-interpolation
			       from: e0:height to: e1:height
			       at: progress)))
	  (with-translation (left top)
	    (painter:with-intensity (- 1.0 intensity)
	      (lambda ()
		(painter:with-stretch
		    (/ width e1:width)
		    (/ height e1:height)
		  (lambda ()
		    (draw! background)))))
	    (painter:with-intensity intensity
	      (lambda ()
		(painter:with-stretch
		    (/ width e0:width)
		    (/ height e0:height)
		  (draw! foreground)))))))
       )))
#+END_SRC

* 02.09.2023

to teraz bysmy sie zajeli draw-background!

#+BEGIN_SRC scheme
  (define (draw-emerging! expression::Element p::Position
			  intensity::float)
    ::void
    (let ((painter ::Painter (the-painter)))
      (painter:with-intensity intensity
	(lambda ()
	  (with-translation (p:left p:top)
	    (if (gnu.lists.LList? expression)
		(let ((outer ::Extent (extent expression)))
		  (painter:draw-box! outer:width outer:height))
		(draw! expression)))))))

  (define (render-background! expression::Element
			      counterparts::(maps (Element)
						  to: (list-of
						       Element))
			      position::(maps (Element)
					      to: Position)
			      intensity::float)
    ::void
    (when (empty? (counterparts expression))
      (draw-emerging! expression (position expression) intensiy))
    (when (gnu.lists.LList? expression)
      (traverse
       expression
       doing:
       (lambda (sub::element t::Traversal)
	 (render-background! sub counterparts position
			     intensity)))))
#+END_SRC

* 01.09.2023

wydaje sie, ze juz jestesmy blisko

trzeba jeszcze tylko zrobic draw-morph! oraz draw-background!.
Zacznijmy zatem może od tego ostatniego.

zasadniczo chodzi tutaj o to, ze po pierwsze rysujemy tylko
elementy bez counterpartow, a po drugie to tak:
- jak rysujemy atomy, to ze zmniejszona intensywnoscia
- jak rysujemy pudelka, to tylko nawiasy, oraz rekurencyjnie
  wszystkie elementy wewnatrz

co do zasady nie musimy tez uzywac 'traverse', poniewaz pozycje
obiektow sa 'uwolnione' (aczkolwiek wygodniej jest po prostu
olac traversale)

no dobra, czyli mozna powiedziec, ze chcemy miec
painter:with-intensity, ustawiamy odpowiednia intensywnosc
na poczatku, dla pudelka po prostu rysujemy nawiasy, i rekurencyjnie
przemiatamy, a dla atomow, spacji i rozszerzen rysujemy je tylko
wtedy, kiedy nie maja odpowiednikow, korzystajac z tabeli
z pozycjami

i tak ten draw-background powinien wygladac (a glowna trudnosc
lezy w tym, zeby go dobrze obsluzyc w painterze)

natomiast w przypadku draw-morph:
- sami wyliczamy sobie pozycje, w ktorych morphy
  maja sie znajdowac
- jezeli dwa elementy sa eq?, to rysujemy je normalnie
- jezeli mamy dwa atomy, to jakos je ze soba morfujemy
  (mozemy zaczac od zwyklej zmiany intensywnosci,
  ale pewnie najlepszy by byl Levenshtein)
- jezeli mamy dwa pudelka, to morfujemy ich rozmiar,
  a pozniej rekurencyjnie wywolujemy render-foreground!
  na elementach pierwszego z nich
- jezeli mamy atom/pudelko albo pudelko/atom, to sciagamy
  rozmiary pudelka do rozmiarow atomu i renderujemy
  z odpowiednia przezroczystoscia (w klientach graficznych
  to zadziala, ale w terminalowym bedziemy mogli uzyc
  randomizacji do skondensowania elementow)


* 31.08.2023

mamy destylat, ktory wyglada tak:

#+BEGIN_SRC scheme
  (define/kw (measure-positions!
	      expression
	      left::real := 0
	      top::real := 0
	      into:
	      measurements::(!maps (Element) to: Position)
	      := (property+ (element::Element)::Position
			    (Position left: 0 top: 0)))
    ::(maps (Element) to: Position)
    (when (list? expression)
      (traverse
       expression
       doing:
       (lambda (item::Element t::Traversal)
	 (let ((p ::Position (measurements item)))
	   (set! p:left (+ t:left left))
	   (set! p:top (+ t:top top))
	   (when (list? item)
	     (measure-positions! item p:left p:top
				 into: measurements))))
       returning:
       (lambda (t::Traversal)
	 measurements))))

  (define-object (Morph initial::Tile
			final::Tile
			origin::(maps (Element) to: (list-of
						     Element))
			progeny::(maps (Element) to: (list-of
						      Element)))
    ::Enchanted
    (define progress ::float 0.0)

    (define initial-position ::(maps (Element) to: (list-of Element))
      (measure-positions! initial))

    (define initial-extent ::Extent
      (extent original))

    (define final-position ::(maps (Element) to: (list-of Element))
      (measure-positions! final))

    (define final-extent ::Extent
      (extent final))

    (define maximum-extent ::Extent
      (Extent width: (max initial-extent:width
			  final-extent:width)
	      height: (max initial-extent:height
			   final-extent:height)))

    (define (extent) ::Extent maximum-extent)

    (define shift ::(maps (Element) to: Position)
      (property+ (element::Element)::Position
		 (Position left: 0 top: 0)))

    (define (draw! context::Cursor)::void
      (cond ((is progress <= 0.5) ;>
	     (render-background! final origin final-position
				 progress)
	     (render-foreground! initial
				 progeny
				 initial-position
				 final-position
				 (- 1.0 progress)))
	    (else
	     (render-background! initial progeny
				 initial-position
				 (- 1.0 progress))
	     (render-foreground! final
				 origin
				 final-position
				 initial-position
				 progress))))    
    (Magic))
#+END_SRC

I teraz moglibysmy zrobic cos takiego, ze napiszemy sobie
funkcje podobna do draw-sequence!, tyle ze uwzgledniajaca
shift - a moze nawet pare funkcji?

tylko jak by to mialo dzialac?

1. najpierw 'renderujemy' warstwe pod spodem (czyli te mniej widoczna)
   w taki sposob, ze jezeli brakuje odpowiednikow danego obiektu,
   to renderujemy rzecz normalnie (tylko z obnizona intensywnoscia),
   natomiast w przeciwnym razie wyliczamy shift na podstawie progresu
   
2. nastepnie 'rendrujemy' warstwe na wierzchu, przy czym robimy
   to w taki sposob, ze dla elementow bez odpowiednikow
   renderujemy rzecz normalnie, zas dla pozostalych elementow
   robimy tak, ze rysujemy morphy pomiedzy elementem
   i jego odpowiednikiem w miejscu wynikajacym z ustalonego
   przesuniecia
   
3. jeszcze pewna uwaga odnosnie rysowania morphow:
   mamy 4 rodzaje morphow:
   - atom-atom
   - pudelko-pudelko
   - pudelko-atom
   - atom-pudelko

   poniewaz jednak morfy powinny byc symetryczne, dwa ostatnie
   rodzaje to tak naprawde jeden rodzaj

   uwaga: rozszerzenia traktujemy tak jak atomy

   i teraz tak:
   - morfy 'pudelko pudelko' powinny sie odbywac w taki sposob,
     ze morfujemy rozmiar pudelka i rysujemy nawiasy,
     a nastepnie iterujemy po bazowym pudelku, rysujac
     morfy jego elementow z przesunieciami   - morfy atom-atom moga
     byc painter-specific, ale dla tekstu
     moglibysmy zrobic cos bazujacego na odleglosci Levenshteina
     natomiast w ogolnym przypadku bysmy zrobili zwykle
     przenikanie
   - morfy atom-pudelko zrobilibysmy jako zmiane rozmiaru pudelka
     i ewentualna kondensacje jego elementow do punktu poczatkowego
     przy jednoczesnym wylanianiu sie atomu


* 30-29.08.2023

#+BEGIN_SRC scheme
  (define (morph-decaying! counterparts::(maps (Element)
					       to: (list-of Element))
			   step::int
			   progress::float)
    ::void
    (assert (is 0.0 <= progress <= 1.0)) ;>>
    (let ((next-step ::int (+ step 1))
	  (painter ::Painter (the-painter)))
      (for x::Element in (keys counterparts)
	(when (and (empty? (counterparts x))
		   (= (reduction-step x) next-step))
	  (painter:with-intensity (- 1.0 progress)
	    (lambda ()
	      (x:draw! '())))))))

  (define (morph-emerging! counterparts::(maps (Element)
					       to: (list-of Element))
			   step::int
			   progress::float)
    ::void
    (morph-decaying! counterparts (- step 1) (- 1.0 progress)))

  (define (morph-expressions! original
			      derived
			      counterparts::(maps (Element)
						  to: (list-of Element))
			      step::int
			      progress::float)
    ::void
    ;; zamysl jest taki (niekoniecznie sluszny), zeby:
    ;; - w pierwszej polowie progresu zaczynac renderowanie
    ;; od 'derived' (poniewaz ma byc zaslaniane przez original),
    ;; a w erugiej od 'original' (ktore ma byc zasloniete przez
    ;; 'derived')
    ;; - z tego samego powodu w pierwszej polowie chcemy
    ;; najpierw rysowac te elementy 'derived', ktore
    ;; wylaniaja sie z nicosci, a dopiero na nich wszystkie
    ;; pozostale, zas w drugiej polowie chceny zaczynac od tych,
    ;; ktore znikaja z 'original', i dopiero na nich rysowac
    ;; rzeczy
    (cond
     ((is progress <= 0.5) ;>
      (morph-emerging! counterparts step progress)
      (morph-from! original #;to counterparts
		   #;at progress))
     (else
      (morph-decaying! counterparts step progress)
      (morph-from! derived #;to counterparts
		   #;at (- 1.0 progress)))))

  (define (morph-from! expression #;to counterparts
		       #;with progress)
    ::void
    (assert (is progress <= 0.5)) ;>
    ;; no dobra, to tutaj rzecz jest taka, ze musimy
    ;; ze soba morfowac zwykle elementy, ale rowniez
    ;; spacje.
    ;; i teraz plan jest z grubsza taki, zeby zachowywac
    ;; tozsamosc obiektow.
    ;; to jednak oznacza, ze nie mozemy miec jednej tablicy
    ;; counterparts, tylko dwie: origins i progenies
    ;; - ale wtedy nie potrzebujemy parametru step

    )


  (define/kw (measure-positions!
	      expression
	      left::real := 0
	      top::real := 0
	      measurements::(maps (Element) to: Position)
	      := (property+ (element::Element)::Position
			    (Position left: 0 top: 0)))
    ::(maps (Element) to: Position)
    (when (list? expression)
      (traverse
       expression
       doing:
       (lambda (item::Element t::Traversal)
	 (let ((p ::Position (measurements item)))
	   (set! p:left (+ t:left left))
	   (set! p:top (+ t:top top))
	   (when (list? item)
	     (measure-positions! item p:left p:top measurements))))
       returning:
       (lambda (t::Traversal)
	 measurements))))

  (define-object (Morph initial::Tile
			final::Tile
			origin::(maps (Element) to: (list-of Element))
			progeny::(maps (Element) to: (list-of Element)))
    ::Enchanted
    (define progress ::float 0.0)

    (define initial-position ::(maps (Element) to: (list-of Element))
      (measure-positions! initial))

    (define initial-extent ::Extent
      (extent original))

    (define final-position ::(maps (Element) to: (list-of Element))
      (measure-positions! final))

    (define final-extent ::Extent
      (extent final))

    (define maximum-extent ::Extent
      (Extent width: (max initial-extent:width
			  final-extent:width)
	      height: (max initial-extent:height
			   final-extent:height)))

    (define (draw! context::Cursor)::void
      (let ((painter ::Painter (the-painter)))
	(cond
	 ((is progress <= 0.5) ;>
	  (for x::Element in (keys progeny)
	    (when (is (progeny x) empty?)
	      (let ((shift ::Position (final-position x)))
		(with-translation (shift:left shift:top)
		  (painter:with-intensity (- 1.0 progress)
		    (draw! x))))))
	  (draw-morph! initial progress))
	 (else 
	  ...))))


    (Magic)
    ;; zaczynamy od tego, ze sobie "renderujemy" original
    ;; i "derived" do "niczego", tak zeby miec polozenia
    ;; wszystkich elementow
    )


#+END_SRC


* 25.08.2023

(define (draw-tween! source target progress)
  ;; rzecz jest taka, ze musimy rysowac zarazem
  ;; zrodlo i cel, przy czym (draw-tween! source target 0.0)
  ;; ma byc rownowazne (draw-tween! target source 1.0)
  ;; ktore ma byc rownowazne po prostu (draw! source)
  ;;
  ;; no i super, ale jeszcze kilka rzeczy wchodzi w gre
  ;; moze algorytm powinien dzialac tak, ze
  ;; renderujemy tak dlugo, dopoki nie zostanie
  ;; wyrenderowane wszystko z tablicy counterpart

  ;; sztuczka polega chyba na tym, ze nie renderujemy
  ;; source'a ani targeta, tylko morphy pomiedzy
  ;; sourcem i jego counterpartami, oraz pomiedzy
  ;; targetem a jego counterpartami. przy czym kolejnosc
  ;; rysowania zalezy od progresu

  ;; jest jakis taki pomysl zeby skakac po counterpartach
  ;; do czasu osiagniecia punktu stalego, tzn wyczerpania
  ;; wszystkich kluczy
  (if (is progress < 0.5);>
     (morph-from target progress)
     (morph-from source (- 1.0 progress)));; albo na odwrot
  
  )

(define (morph-from expression progress)
  (let ((targets (counterparts expression)))
    (if (null? targets)
       (decay! expression progress)
       (for target in targets
         (morph! expression target progress)))))

(define
	 
* 24.08.2023

morph expression into expressions at progress

for x in expressions
  morph1 expression into x with progress

gdzie

morph1 original into derived at progress

to cos w rodzaju

(cond
  ((and (list? original) (list? derived))
   (morph-boxes original derived progress))
  ((list? original)
   (morph-box-to-atom original derived progress))
  ((list? derived)
   (morph-atom-to-box original derived progress))
  (else
   ;; domyslnie morfujemy dwa atomy, to znaczy:
   ;; - polozenie atomu wynika z interpolacji
   ;;   polozen original i derived
   ;; - rozmiar atomu rowniez wynika z interpolacji


tak by wygladal ten kejs, w ktorym jedno wyrazenie
sie nam zwielokrotnia

natomiast jest jeszcze kejs, w ktorym jedno
pudelko zostaje przeksztalcone w inne pudelko

* 22-21.08.2023

teraz bedziemy mieli dluzsza przerwe, co oznacza nieco
wiecej swobody w pracach

za 3 tygodnie zajmiemy sie juz naprawianiem bugow
(oraz moze tez implementacja metod do poruszania
kursorem w pionie, i zalataniem mechanizmu selekcji,
i cache'owaniem 'extent')

ale do tego czasu mozemy nieco pomyslec o ewaluatorze
wizualnym

mamy miec funkcje

beginning
back
play/pause
next
ending

(define-type (Evaluation step: int
                         expansions: sequence)
  implementing Player
  with
  ...)

ogolnie tak: musimy miec jakas implementacje Animation,
czyli musi byc metoda (advance! time-step/ms::int)::boolean

musi tez byc metoda draw!, ktora musi wiedziec,
czy rysujemy finalna klatke, czy miedzyklaccie,
dlatego tez musimy znac biezacy progres

No ale dobrze, rozwazmy teraz kwestie samej ekspansji.
Kpd dokonujacy podstawienia wyglada tak:

  (define (substitute variables with: values in: expression)
    (match expression
      (`(quote ,_)
       expression)
      (`(,head . ,tail)
       `(,(substitute variables with: values in: head)
         . ,(substitute variables with: values in: tail)))
      (_
       (or (any (lambda (variable value)
                  (and (equal? variable expression)
		       value))
	        variables values)
	   expression))))
	   
i na jakis tam uzytek moze byc ok, ale my bysmy chcieli
zrobic cos takiego, ze w momencie, gdy renderujemy
klatke posrednia, wiemy, ktore wyrazenie odpowiada
ktoremu

(define (draw-between! source target progress::float)::void
  (let* ((source-extent (extent source))
         (target-extent (extent target))
         (width (interpolate source-extent:width
                             target-extent:width
      	                     progress))
	 (height (interpolate source-extent:height
	                      target-extent:height
			      progress)))
    (cond
      ((and (pair? source)
            (pair? target))
       (draw-sequence-between! source target progress))
      ...)))

no ale poczekajta! jak mamy takie cos:


((lambda (x y)
   (+ x y)) 2 3)


   (+ 2 3)

to chcielibysmy, zeby (+ 2 3) pojawilo sie w miejscu
(+ x y)

czy ogolniej, przesledzmy

(define (! n)
  (if (is n <= 1) ;>
     1
     (* n (! (- n 1)))))

i redukujemy

(! 5)

to wzamian powinismy dostac
						
(if (is 5 <= 1) ;>
     1
     (* 5 (! (- 5 1))))

i teraz w tym wyrazeniu powinnismy najpier zredukowac warunek

(if #false
     1
     (* 5 (! (- 5 1))))

i na tym etapie wyrazenia powinby byc traktowane jako rownorzedne.

ale juz kolejna redukcja, do

(* 5 (! (- 5 1)))

powinna wskazac, ze drugie wyrazenie jest w kontekscie
(7) pierwszego wyrazenia.

na dalszym etapie redukujemy

(* 5 (! 4))

ponownie nie zmieniajac kontekstu. Tak samo bedzie w przypadku

(* 5 (if (is 4 <= 1) ;>
       1
       (* 4 (! (- 4 1)))))

(* 5 (if #false
       1
       (* 4 (! (- 4 1)))))

natomiast przy kolejnej redukcji

(* 5 (* 4 (! (- 4 1))))

mamy wydobycie wyrazenia (7 5). Dalej bedziemy mieli:

(* 5 (* 4 (if (is 3 <= 1) ;>
             1
            (* 3 (! (- 3 1))))))

(* 5 (* 4 (if #false
             1
            (* 3 (! (- 3 1))))))

i na (7 5 5) mamy
	    
(* 5 (* 4 (* 3 (! (- 3 1)))))

(* 5 (* 4 (* 3 (! 2))))

(* 5 (* 4 (* 3 (if (is 2 <= 1) ;>
                  1
                 (* 2 (! (- 2 1)))))))

(* 5 (* 4 (* 3 (if #false
                  1
                 (* 2 (! (- 2 1)))))))

na (7 5 5 5)

(* 5 (* 4 (* 3 (* 2 (! (- 2 1))))))

(* 5 (* 4 (* 3 (* 2 (! 1)))))

(* 5 (* 4 (* 3 (* 2 (if (is 1 <= 1) ;>
                        1
                      (* 1 (! (- 1 1))))))))

(* 5 (* 4 (* 3 (* 2 (if #true
                        1
                      (* 1 (! (- 1 1))))))))

na (5 5 5 5 5):
		      
(* 5 (* 4 (* 3 (* 2 1))))


czyli zasadniczo mamy takie opcje:

1. oba wyrazenia sa rownorzedne
2. drugie wyrazenie powstalo z podwyrazenia pierwszego
3. drugie wyrazenie powstalo z owiniecia pierwszego

ha ha, zeby to bylo takie proste.
teoretycznie mamy jeszcze jedna mozliwosc: ze
jedno wyrazenie pojawia sie w drugim kilka razy.

Zalozmy zatem, ze mamy takie tablice:

(define-property (source-cursor cursor::Cursor)::Cursor
  cursor)

(define-property (source-position cursor::Cursor)::Position
  (error "Unknown position of source at "cursor))
  
(define-property (target-position cursor::Cursor)::Position
  (error "Unknown position of target at "cursor))

no ale troche tu mieszasz, co by nie mowic: bo czy my
chcemy moc przesuwac wyrazenia na ekranie?

moze chcemy, a moze nie chcemy. zalozmy jednak ze chcemy.

wtedy nasze dzialanie musi tak wygladac:
1. renderujemy dokument 'na pusto', zeby wypelnic tablice
   source-position i target-position
2. musimy zidentyfikowac czesci wspolne zrodla i celu
  

* 19.08.2023

scalanie splitow juz zasadniczo dziala,
wiec teraz bysmy chcieli zrobic jeszcze dwie rzeczy:
1. dodawac odpowiednie przesuniecie do dolnego/prawego
   splita
2. utrzymywac dwa odrebne zestawy podzialow
   dla orientacji pionowej i poziomej
   (a przynajmiej aktualizowac rozmiar ekranu
   po zmianie orientacji)

* 18.08.2023

zrobilismy pare zmian w implementacji filtru,
ale teraz chcialoby sie je przetestowac, czyli zintegrowac
z touch-event-processorem.

w tym celu do procesora trzeba dodac dwie zmienne,
x-tracker i y-tracker

po podpieciu okazalo sie, ze rzecz nie dziala najlepiej,
a najprostszy model pomiaru predkosci dziala w sumie
nie najgorzej

(define (drop! x y vx vy)
  (and-let* ((target ::Split (split-ref split-path))
             (first-size line-size last-size
	                 (target:sizes))
	     (velocity (target:varying-dimension vx vy)))
    (cond
     ((or (is first-size <= (* 3 line-size)) ;>
          (is velocity < -1.5)) ;>
      (merge-split! at: split-path with: SplitFocus:Last))
     ((or (is last-size <= (* 3 line-size))
          (is velocity > 1.5))
      (merge-split! at: split-path with: SplitFocus:First)))))

(define (merge-split! at: split-path with: focus::SplitFocus)::boolean
  (if (null? split-path)
    (and-let* ((split ::Split screen:top))
      (set! screen:top (split:part focus)))
    (and-let* ((`(,tip . ,root) split-path)
               (parent ::Split (split-ref root))
	       (split ::Split (parent:part tip)))
      (match tip
        (,SplitFocus:First (set! parent:first (split:part focus)))
	(,SplitFocus:Last (set! parent:last (split:part focus)))))

* 17-15.08.2023

filtr Kakmana - kroki:

1. estymacja stanu z modelu

   ~x[k] = A*x[k-1]

2. estymacja kowariancji

   ~P[k] = A*P[k-1]*A^T + Q

3. residuum pomiaru (innowacja)

   y[k] = z[k] - H*~x[k]

4. innowacja kowariancji:

   S[k] = H*~P[k]*H^T + R

5. wzmocnienie Kalmana:

   K[k] = ~P[k]*H^T*S[k]^-1

6. korekta stanu:

   x[k] = ~x[k] + K[k]*y[k]

7. korekta kowariancji:

   P[k] = (I - K[k]*H)*~P[k]

bardziej kompaktowo mamy:

   ~x[k] = A*x[k-1]
   ~P[k] = A*P[k-1]*A^T + Q
   y[k] = z[k] - H*~x[k]
   S[k] = H*~P[k]*H^T + R
   K[k] = ~P[k]*H^T*S[k]^-1
   x[k] = ~x[k] + K[k]*y[k]
   P[k] = (I - K[k]*H)*~P[k]

i teraz tak:

x[k-1] = [position-estimate
          velocity-estimate]

P[k-1] = [position-variance cross-covariance
          cross-covariance velocity-variance]

H = [1 0]

A = [1 time-step/ms
     0            1]
     
Q = [position-update-uncertainty position-velocity-uncertainty
     position-velocity-uncertainty velocity-update-uncertainty]

R = [position-measurement-uncertainty]

~x[k] = [predicted-position
         velocity-estimate]

y[k] = [prediction-error]

A*P[k-1] =
[position-variance+time-step/ms*cross-covariance  cross-covariance+time-step/ms*velocity-variance
 cross-covariance                                 velocity-variance]

A^T = [1            0
       time-step/ms 1]

A*P[k-1]*A^T =
[position-variance+time-step/ms*cross-covariance+time-step/ms*(cross-covariance+time-step/ms*velocity-variance)   cross-covariance+time-step/ms*velocity-variance
 cross-covariance+time-step/ms*velocity-variance                                                                  velocity-variance                               ]

 ~P[k] = [predicted-position-variance predicted-cross-covariance
          predicted-cross-covariance predicted-velocity-variance]

H*~P[k]*H^T = [predicted-position-variance]

~P[k]*H^T = [predicted-position-variance
             predicted-cross-covariance]

S[k] = [predicted-position-variance+position-measurement-uncertainty]

K[k] = [position-gain
        velocity-gain]

(I-K[k]*H) = [1-position-gain 0
              -velocity-gain  1]

P[k] =
[(1-position-gain)*predicted-position-variance (1-position-gain)*predicted-cross-covarianxe
 predicted-cross-covariance:-:velocity-gain*predicted-position-variance predicted-velocity-variance:-:velocity-gain*predicted-cross-covariance]


(define-interface VelocityTracker ()
  (update! position::float time-step/ms::float)::void
  (current-velocity)::float
  (reset!)::void
  )

(define-object (KalmanVelocityTracker)::VelocityTracker
  (define velocity-estimate ::float +nan.0)
  (define position-estimate ::float +nan.0)
  
  (define position-variance ::float 10.0)
  (define velocity-variance ::float 25.0)
  (define cross-covariance ::float 0.0)

  (define position-update-uncertainty ::float 5.0)
  (define velocity-update-uncertainty ::float 1.0)
  (define cross-update-uncertainty ::float 3.0)
  
  (define position-measurement-uncertainty ::float 1.0)
  
  (define (update! measured-position::float time-step/ms::float)::void
    (cond
      ((nan? position-estimste)
       (set! position-estimate measured-position))
      ((nan? velocity-estimate)
       (set! velocity-estimate
             (/ (- measured-position
	           position-estimate)
		time-step/ms))
       (set! position-estimate measured-position))
      (else
       (let* ((predicted-position ::float (+ position-estimate
                                             (* velocity-estimate
					        time-step/ms)))
	      (prediction-error ::float (- predicted-position
	                                   measured-position))
	      (predicted-position-variance ::float
                                           (+ position-variance
                                              (* time-step/ms
                                                 (+ (* 2 cross-covariance)
                                                    (* time-step/ms
				                        velocity-variance)))
			                      position-update-uncertainty))
	      (predicted-cross-covariance ::float
	                                  (+ cross-covariance
                                             (* time-step/ms
                                                velocity-variance)
					     cross-update-uncertainty))
	      (predicted-velocity-variance ::float
	                                   (+ velocity-variance
					      velocity-update-uncertainty))
	      (correction ::float
	                  (/ (+ predicted-position-variance
	                        position-measurement-uncertainty)))
              (position-gain ::float (* predicted-position-variance
	                                correction))
	      (1-position-gain ::float (- 1.0 position-gain))
	      (covariance-gain ::float (* predicted-cross-covariance
	                                  correction)))
          (set! velocity-estimate
	        (+ velocity-estimate (* covariance-gain
		                        prediction-error)))
	  (set! position-estimate
	        (+ predicted-position (* position-gain
		                         prediction-error)))
	  (set! position-variance
	        (* 1-position-gain predicted-position-variance))

          (set! cross-covariance
                (* 1-position-gain
		   predicted-cross-covariance))

          (set! velocity-variance
	        (- predicted-velocity-variance
		   (* covariance-gain predicted-cross-covariance)))))))

					  
  (define (current-velocity)::float
    velocity-estimate)
  
  (define (reset!)::void
    (set! position-estimate +nan.0)
    (set! velocity-estimate +nan.0))



ChatGPT dal nam taka dekompozycje svd:

Dana macierz A = [[a b], [c d]]

Oblicz macierz AA^T:
AA^T = [[a^2 + b^2, ac + bd], [ac + bd, c^2 + d^2]]

Oblicz wartości osobliwe (pierwiastki kwadratowe z eigenwartości macierzy A*A^T):
σ1 = sqrt(a^2 + b^2 + c^2 + d^2)
σ2 = 0 (bo to jest macierz 2x2)

Oblicz pierwszy wektor osobliwy (kolumna macierzy V):
v1 = [a/sqrt(a^2 + b^2), c/sqrt(a^2 + b^2)]

Oblicz drugi wektor osobliwy (kolumna macierzy U):
u1 = [b/sqrt(a^2 + b^2), -d/sqrt(a^2 + b^2)]

Skonstruuj macierze U, Σ i V:
U = [u1]
Σ = [[σ1, 0], [0, σ2]]
V = [v1]

* 14.08.2023

mamy na jutro poprawki do scommitowania. poza tym
implementujemy sledzenie predkosci, i uznalismy, ze
moze warto by bylo zrobic to przy pomocy filtru Kalmana

tymczasem niezaleznie od wyniku chcielibysmy zrobic
scalanie ze soba paneli

i to w dwoch sytuacjach: albo wtedy, kiedy jeden
z obszarow jest zbyt maly (powiedzmy, nie wiekszy niz
3*line-size), albo kiedy predkosc przy podnoszeniu
palca jest dostatecznie duza

w starym prototypie mielismy metode finishResizing,
ktora byla wywolywana z kontekstu przypisania, ale poniewaz
teraz nie operujemy bezposrednio na splitach, a na listach
indeksow, to bedziemy mogli dropa zaimplementowac inaczej
- a tak konkretnoe to mniej wiecej tak:

(define (drop! x y vx vy)
 ` (and-let* ((target ::Split (split-ref screen:top split-path))
             (first-size line-size last-size
	                 (target:sizes)))
    (cond
     ((is first-size <= (* 3 line-size)) ;>
      (merge-split! at: split-path with: SplitFocus:Last
                    in: screen:top))
     ((is last-size <= (* 3 line-size)) ;>
      (merge-split! at: split-path with: SplitFocus:First
                    in: screen:top)))))
* 13.08.2023

moze bysmy sie zajeli sledzeniem predkosci w event processorze

i od razu kilka uwag:

pierwsza jest taka, ze byc moze chcielibysmy
sobie reprezentowac punkty pomiarowe za pomoca
tablicy pamietajacej wskazania historyczne
z ostatnich 60-100 milisekund

natomiast inny pomysl jest taki, zeby uzyc
filtru Kalmana, gdzie nasz wektor stanu
ma postac

X = [x y vx vy]^T

* 11.08.2023

no i mamy SplitBelow gotowe (mniej wiecej)

tylko teraz tak:
- wydaje sie ze mamy jakiegos buga przy
  resize'owaniu zagniezdzonych splitow
- i chyba tez nie wszystko jest do konca teges
  jezeli idzie o zmiane orienracji na androidzie

pezyjmijmy (V a b) = (SplitBeside first: a last: b)
(H a b) = (SplitBelow first: a last: b)

i wowczas mamy

p = (V (H (V 1 (V 4 5)) 3) 2)

i teraz wezmy (pane-ref p '(Z A A))

to tak:

(pane-ref P '(A))

(H (V 1 (V 4 5)) 3)


* 10.08.2023

dzis/jutro bysmy sprobowali zrobic SplitBelow

ale w tym celu trzeba elegancko wyodrebnic Split
ze SplitBeside

* 09.08.2023

mamy troche jakby dzialajaca zmiane rozmiaru splita.
co dalej?
- refactor SplitBeside tak zeby latwiej zrobic SplitBelow
- implementacja SplitBelow
- sledzenie predkosci w touch event procesorze
- laczenie splitow
- naprawa resize/screen position
- osobne podzialy dla orientacji poziomej i pionowej
  (jak to sie uda do konca sierpnia to bedzie ekstra)
  
* 08.08.2023

jest kilka aspektow
po pierwsze, nie wiemy jaka jest 'sciezka' wiodaca do biezacego
splitu. Nalezaloby to rozwiazac w taki sposob, ze tworzymy
sobie parametr the-split-path, ktory obslugujemy wewnatrz
'propagate' w taki sposob, ze reconsujemy okreslony focus

(define (cursor-ref #!optional
		    (tile (the-document))
		    (cursor::Cursor (the-cursor)))
  (match cursor
    ('()
     tile)
    (`(,head . ,tail)
     (let ((parent (cursor-ref tile tail)))
       (part-at head parent)))
    (_
     (error "Unable to refer to cursor "cursor
	    " in "tile))))

analogicznie bysmy mieli

(define/kw (screen-area at: path := (the-split-path)
                        from: pane::Embeddable := screen
                        into: area::Area
                        := (Area left: 0 top: 0
                                 width: screen:extent:width
                                 height: screen:extent:height))
  ::Area
  (match path
    ('()
     area)
    (`(,head . ,tail)
     (match pane
      ((SplitBeside left: left right: right)

)))))

moze opiszmy sobie jak powinien wygladac ten proces.

iterujemy zaczynajac od ekranu

tak naprawde najlepiej by bylo miec cos w rodzaju cursor-ref,
tyle ze chcemy robic dwie rzeczy na raz: po pierwsze, poruszac
sie po 'drzewie' podzialow, a po drugie, sledzic polozenia
i rozmiary biezacego podzialu

(define (pane-ref top::Embeddable path::list)::Embeddable
  (match path
    ('()
     (top:final))
    (`(,h . ,t)
     (let ((parent (pane-ref top tail)))
       (match pane
         ((SplitBeside left: left right: right)
	  (match head
	    (,SplitBesideFocus:Left (left:final))
	    (,SplitBesideFocus:Right (right:final))))
	 ((SplitBelow top: top bottom: bottom)
	  (match head
	    (,SplitBelowFocus:Top (top:final))
	    (,SplitBelowFocus:Bottom (bottom:final)))))))))

no dobra, wydaje sie ze to mamy. A teraz bysmy chcieli
dodac do tego wartosci polozen i rozmiarow

(define (screen-area split-path::list pane::Embeddable := screen:top)
  ::(Values Embeddable real real real real)
  (match split-path
    ('()
     (values (pane:final)
             0 0 screen:extent:width screen:extent:height))
    (`(,h . ,t)
     (let-values (((parent x y w h) (screen-area top tail)))
       (match pane
         ((SplitBeside left: left right: right at: at)
	  (let* ((painter ::Painter (the-painter))
	         (line-width ::real (painter:vertical-split-width))
                 (inner-width ::real (- w line-width))
                 (left-width ::real (as int (round (* at inner-width))))
                 (right-width ::real (- inner-width left-width)))
	    (match head
	      (,SplitBesideFocus:Left
	       (values (left:final) x y left-width h))
	      (,SplitBesideFocus:Right
	       (values (right:final) (+ x left-width line-width) y
	                             right-width h)))))
	 ((SplitBelow top: top bottom: bottom)
	  (match head
	    (,SplitBelowFocus:Top
	     (values (top:final) x y w ...))
	    (,SplitBelowFocus:Bottom
	     (values (bottom:final) x ... w ...)))))))))


* 07.08.2023

jako sie rzeklo, robimy tak, zeby Editor byl Cloneable.

no to to juz mamy

teraz chcemy miec gruba czarna kreche

ona tez jest

wiec moze sprobujmy ja teraz resize'owac

bedziemy musieli zaimplementowac takie cos

(define-object (ResizeSplitBeside target::SplitBeside)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    ...)

  (define (drop! x::real y::real vx::real vy::real)::void
    ...))

co jednak rodzi pytanie: na jaka wartosc powinnismy
ustawic 'at'?

co wiemy: ze x i y sa we wspolrzednych ekranu

zalozmy, ze px i py to wspolrzedne ekranowe rodzica
nadzego SplitBeside'a, natomiast pw i ph to jego rozmiar.
wowczas at musi wynosic (x - px)/pw

no dobra, ale teraz skad wziac wspolrzedne rodzica?

* 06.08.2023

dzis bysmy sprobowali zaimplementowac te wczorajsze
kopiowania tak, zeby sie dalo kopiowac propertisy

a jutro bysmy uczynili Editor instancja Cloneable,
i ewentualnie sprobowali rysowac czarna kreche
(i do tego moze jeszcze robienie Drag jak sie zrobi
press! na SplitBeside)

no i pamietajmy, zeby zamiast screen-position
sledzic sobie document-position

moze w tym tygodniu sie uda mnuej wiecej te splity
obsluzyc, to w kolejnym bysmy sprobowali dodac
sledzenie predkosci do touch-event-processora


* 05.08.2023

na pewno chcemy, zeby:

- Editor zostal Cloneable
- dalo sie klonowac 'propertiesy'

trzeba tez sie zastanowic, bo jezeli ten sam dokument
mozna otworzyc w wiecej niz jednym edytorze, to
(screen-position expression) staje sie wieloznaczne
- i zamiast niego raczej chcielibysmy uzywac
(document-position expression), ktore z kolei bysmy
mogli wzglednie latwo sobie konwertowac do
polozenia wewnatrz edytora.

(define-syntax property
  (syntax-rules (::)
    ((property (object::key-type)::value-type default)
     (let* ((table (($bracket-apply$ make-weak-key-hash-table
				     key-type value-type)))
            (getter (lambda (object::key-type)
                      (hash-ref table object
				(lambda () default)))))
       (set! (setter getter)
	 (lambda (arg::key-type value::value-type)
           (hash-set! table arg value)))
       (set-procedure-property! getter 'table table)
       getter))))


(define-syntax property
  (syntax-rules (::)
  ((property (object::key-type)::value-type default)
     (let ((table (($bracket-apply$ make-weak-key-hash-table
				    key-type value-type))))
       (define (create table)
         (let ((getter (lambda (object::key-type)
                         (hash-ref table object
		            (lambda () default)))))
            (set! (setter getter)
	      (lambda (arg::key-type value::value-type)
                (hash-set! table arg value)))
	    (set-procedure-property! getter 'table table)
	    (set-procedure-property! getter 'clone
	      (lambda ()
	        (create (table:clone))))
	    getter))

       (create table)))))

* 04.08.2023

na razie mamy wydmuszki metod. dzis/jutro bysmy zrobili tak:

- zaimplementowali dobry detektor w Editor (mozemy troche
  zmienic interfejs)

- dobrze zaimplementowali detektor w SplitBeside

i wowczas moze juz dzis udaloby sie miec ekran dzielony
w pionie

no ale dopsz, chcielibysmy zrefaktoryzowac SplitBeside
na modle - czego? propagatora w ColumnGrid w (button)


* 03.08.2023

dzis chcemy zaimplementowac metody

  (can-split-beside? line::Area)::boolean
  (split-beside! line::Area)::Embeddable
  
  (can-split-below? line::Area)::boolean
  (split-below! line::Area)::Embeddable


* 02.08.2023

trzeba by dodac do paintera parametr, line-simplification-resolution,
ktory moze dla klienta terminalowrgo wynosilby 3, dla desktopu
10, a dla androida 20.

No dobra, jest, i co dalej?

mozemy zaczac od tego zeby wyswietlac nazwe rozpoznanej rzeczy
do loga

(define-cache (f x y) ?)

(define-early-constant f
  (let ((cached (cache (x) (cache y) ?)))
    (lambda/kw (x y) ((cached x) y))))

problem mamy taki, ze chcielibysmy jakos
zinwalidowac ten kesz

czyli bysmy to jakos tak zrobili, ze by to wygladalo tak:

(define-early-constant f
  (let* ((cached (cache (x) (cache y) ?))
         (invoker (lambda/kw (x y) ((cached x) y))))
    (set-procedure-property! invoker 'cache cached)
    invoker))

(define (invalidate! cache . point)
  (let ((table (procedute-property cache 'table)))
    (match point
      ('() (table:clear))
      (`(,head . ,tail)
       (apply invalidate! (cache head) tail)
       (table:remove head)))))

(define (invalidate-cache! invoker . point)
  (apply invalidate! (procedure-property invoker 'cache) point))

ok, jakos to wyglada. Wykrywanie linii poziomej tez wydaje
sie dzialac.

to teraz zerknijmy sobie jak to bylo robione kiedys
(no bo przeciez 'kiedys to bylo')


mielismy metody w panelu:
canBeSplittedVertically(rect)
splitVerticallyBy(rect)

i teraz zrobimy to dokladnie tak samo!

tylko zdefiniujemy sobie

(define-type (Area left: real top: real
                   right: real bottom: real))

i znajdzmy sposob wyliczania

(define (area points::(sequence-of Position))::Area
  (let* ((result ::Area (Area left: +inf.0 top: +inf.0
                              right: -inf.0 bottom: -inf.0)))
    (for p::Position in points
      (set! result:left (min result:left p:left))
      (set! result:top (min result:top p:top))
      (set! result:right (max result:right p:left))
      (set! result:bottom (max result:right p:left)))
    result))

(pane:can-be-splitted-vertically-by? (area points))

(set! pane (pane:split-vertically-by! (area points)))

* 01.08.2023

(define (simplify points::java.util.List epsilon::real)
  ::java.util.List
  (let* ((n ::int (length points))
         (n-1 ::int (- n 1)))
    (if (is n <= 2) ;>
        (let ((result ::java.util.List (java.util.ArrayList)))
	  (result:addAll points)
	  result)
	(let* ((first ::Position (points 0))
	       (last ::Position (points n-1))
	       (interior (points:subList 1 n-1))
	       (distance-to ::(maps (Position) to: real)
	                    (distance-to-line-through first last))
	       (furthest-distance ::real (distance-to (interior 0)))
	       (index ::int 0))
	  (for i::int from 1 below (length interior)
	    (let* ((element ::Point (interior i))
	           (distance ::real (distance-to element))) ;<
               (when (is distance > furthest-distance)
	         (set! index i)
		 (set! furthest-distance distance)))) ;<
	    (if (is distance > epsilon)
	      (let* ((left (points:subList 0 (+ index 1)))
	             (right (points:subList index n))
		     (left* (simplify-stroke left epsilon))
		     (right* (simplify-stroke right epsilon)))
                (left*:addAll right*)
		left*)
	      (java.util.ArrayList first last))))))

no dobra, mamy chyba dzialajacy RDP. Jutro bysmy sprobowali
dodac dzielenie ekranu.
	      
* 31.07.2023

Oto RDP ktoregosmy napisali 2 lata temu dla zabawy
w (grand scheme):

(define ((perpendicular-distance [x1 y1] [x2 y2]) [x y])
  (let ((dx (- x2 x1))
        (dy (- y2 y1)))
    (/ (abs (+ (* dy x) (* -1 dx y) (* x2 y1) (* -1 y2 x1)))
       (sqrt (+ (* dx dx) (* dy dy))))))

(define (Ramer-Douglas-Peucker points epsilon)
  (if (is (length points) <= 2)
      points
      (let* (([first middle ... last] points)
             (furthest distance index-1
		       (apply argmax
                              (perpendicular-distance first last)
                              middle))
             (index (+ index-1 1)))
        (if (is distance > epsilon)
            (let* ((left right (split-at points (+ index 1)))
                   ([_ ... pivot] left)
                   (left* (Ramer-Douglas-Peucker left epsilon))
                   ([pivot . right*] (Ramer-Douglas-Peucker
				      `(,pivot . ,right) epsilon)))
              `(,@left* ,@right*))
            `(,first ,last)))))

(e.g. ;; cf. https://rosettacode.org/wiki/Ramer-Douglas-Peucker_line_simplification
 (Ramer-Douglas-Peucker
 '((0 0) (1 0.1) (2 -0.1) (3 5) (4 6)
    (5 7) (6 8.1) (7    9) (8 9) (9 9))
  1.0) ===> ((0 0) (2 -0.1) (3 5) (7 9) (9 9)))

I mamy kilka uwag. Przede wszystkim okreslenie
'perpendicular-distance' mowi niewiele, podczas gdy
tak naprawde chodzi o odleglosc pomiedzy prosta wyznaczana
przez punkty [x1 y1], [x2 y2].

Czyli de facto interesuje nas

(define-type (Line direction: Position
                   displacement: real))

odleglosc punktu od plaszczyzny mozna wyznaczyc w taki sposob, ze:

1. wyznaczamy rzut wektora na te linie (z iloczynu skalarnego)
2. odejmujemy ten rzut od wektora
3. liczymy dlugosc wektora, ktory nam pozostal

(define (distance-to-line-through p1::Position p2::Position)
  ::(maps (Position) to: real)
  (let* ((dx ::real (- p2:left p1:left))
         (dy ::real (- p2:top p1:top))
         (1/d ::real (/ (hypotenuse dx dy)))
	 (cross ::real (- (* p1:left p2:top)
	                  (* p2:left p1:top))))
     (lambda (p::Position)::real
       (* (- (* dy p:left) (* dx p:top) cross) 1/d))))

* 30.07.2023

mamy juz nowy modul recognizera,
kolejnym krokiem bedzie [chyba] napisanie algorytmu
RDP w taki sposob, zeby dzialal na ArrayListach
[albo moze nawet na dowolnych Listach]

* 27.07.2023

plan na dzis:
- dodac oznaczanie pozycji kursora przy renderowaniu
  nawiasow w graficznych klientach
- do klienta androidowego dodac uwzglednienie
  rozmiaru klawiatury przy wyliczaniu rozmiaru ekranu
- zaczac przygotowania do implementacji podzialow ekranu


* 26.07.2023

wiemy juz, ze:
- cursor-position zwraca polozenie kursora we wspolrzednych
  ekranowych
- potrzebujemy mechanizmu do wyznaczenia wspolrzednych
  i rozmiaru edytora, zeby zmapowac polozenie kursora
  na wspolrzedne edytora
- stad mozemy latwo zmapowac polozenie kursora
  na wspolrzedne dokumentu

  ;<
  (define (screen->document xs::real ys::real)::(Values real real)
    (let-values (((xe ye) (screen->editor xs ys))
      (editor->document xe ye))

no i teraz wszystko jest pieknie (bo nie mamy optymalizacji
i "rysujemy" nawet rzeczy poza ekranem), ale co kiedy bedziemy
chcieli zrobic optymalizacje?

wowczas bysmy dodali metode cursor-marked? do interfejsu
Painter, i bysmy rysowali tak dlugo, az 'cursor-marked'
byloby oznaczone (to jednak wymaga tez wywolywania 'mark-cursor'
podczas renderowania nawiasow w klientach graficznych)

ewentualnie bysmy dodali nowa metode 'find-cursor'.
Albo po prostu bysmy uzyli screen-position, zeby dobrac sie
do rodzica, i pozniej bysmy wywolali jakas mwtode na spacji,
ktora by nam pozwolila wyznaczyc pozycje kursora (czy cos)

cos na pewno wymyslimy.

ok, czyli dzisiaj zasadniczo chcielibysmy stworzyc mechanizm,
ktory pozwolilby nam na okreslanie wspolrzednych ekranowych
edytora, czyli rzeczone

(the-pane-left)
(the-pane-top)
(the-pane-width)
(the-pane-height)

czy to ma sens?

czy moze zamiast tego powinnismy zapamietywac
(screen-position editor)?

oczywiscie mozna by tak robic, ale wtedy co z rozmiarem?



* 25.07.2023 (komputer)

Musimy przemyslec to i owo. Rozwazmy definicje z telefonu:

(define (adjust-view!)
  (let ((painter ::Painter (the-painter))
        (editor ::Editor (the-editor)))
    (unless (cursor-visible?)
       (painter:play!
          (Transition of: editor:transform
                      from: (copy editor:transform)
                      to: #| takie przesuniecie zeby kursor byl na srodku |#
                      duration/ms: 500)))))

I teraz tak: w Painterze jest metoda "mark-cursor!" oraz
(cursor-position), przy czym pojawia sie takie pytanie, w jakim
ukladzie wspolrzednych wyrazone sa te wartosci?

Otoz: mark-cursor! pobiera wartosci wzgledem biezacego przesuniecia,
natomiast cursor-position wyraza pozycje kursora na ekranie.

I od razu mamy kilka uwag, zwiazanych z tym, jak rzecz mozemy w ogole
zaimplementowac, tzn. jak zintegowac te kwestie z pojeciem edytora.

Poza tym - niby to przy okazji - w gre wchodzi jeszcze taka kwestia,
ze w kliencie terminalowym powinnismy oznaczac tylko kursor w aktywnym
edytorze (co moze nie byc problemem dopoki mamy tylko jeden edytor)

No ale dobra, pytanie numer 1: skad mozemy wiedziec, jaka pozycje ma kursor
wewnatrz dokumentu?

Bo jezeli wiemy to, to za pomoca transforma mozemy tez okreslic, jaka
jest jego pozycja w edytorze. Natomiast kiedy mamy rowniez i to, to
teoretycznie z pomoca (the-pane-extent) powinnismy byc w stanie okreslic,
czy wspolrzedna kursora jest poza ekranem

No to teraz wyobrazmy sobie, ze mamy do dyspozycji nastepujace parametry:

(the-editor-left)
(the-editor-top)
(the-editor-width)
(the-editor-height)

przechowujace wspolrzedne ekranowe poszczegolnych edytorow.

Ale jezeli mamy takie cos, to mozemy operowac na wspolrzednych ekranowych

Warto tez przyjrzec sie, gdzie ow "mark-cursor!" jest wywolywany:

w text-painter jest w:
- draw-custom-box!
- draw-quote-markers!
- draw-quasiquote-markers!
- draw-unquote-markers!
- draw-unquote-splicing-markers!
- draw-string!

w spaces:
- Space:draw!

w grasp-android:
- w draw-text!

w grasp-desktop:
- w draw-text!

Mozemy sobie zmapowac wspolrzedne ekranowe na wspolrzedne w edytorze,
a je z kolei na wspolrzedne w dokumencie

* 25.07.2023 (telefon)

mamy jako tako dzialajace animacje, moglibysmy jeszcze
zrobic tak, zeby sie focusowac na danej linii i dopasowywac
skale do szerokosci

no ale dobrze. skupmy sie na sledzeniu kursora. chodzi o to,
ze jezeli kursor wyjedzie poza ekran, to powinnismy
odtworzyc tranzycje, ktora sprawi, ze ow kursor znajdzie sie
w polowie wysokosci ekranu


poniedzialek - system animacji
wtorek - animacje przy podwojnym kliknieciu
sroda - sledzinie kursora
czwartek - rysowanie tla
piatek - dzielenie ekranu


ponadto dobrze byloby, zeby:
- po lewej stronie edytora byl pasek scrollujacy
- podczas scrollowania skala automatycznie by sie
  dopasowywala tak, zeby wszystko miescilo sie
  na szerokosc
- nie dalo sie obracac ekranu

no i swietnie, tylko co teraz?

zdefiniujmy funkcje tak:

(define (adjust-view!)
  (let ((painter ::Painter (the-painter))
        (editor ::Editor (the-editor)))
    (unless (cursor-visible?)
      (painter:play!
        (Transition of: editor:transform
	            from: (copy editor:transform)
		    to: #|takie przesuniecie, zeby kursor
byl na srodku|#
                    duration/ms: 500)))))

no dobra, to jak zdefiniowac cursor-visible?

* 24.07.2023

dzisiaj plan jest taki: chcemy zrobic, ze jak bedzie podwojne
klikniecie i niezerowy kat, to zeby byla dodawana tranzycja
do zerowego kata

od tego w kazdym razie zaczniemy

no dobra, to juz mamy zrobione

AAAA i trzeba jeszcze zrobic tak, zeby edytor pamietal
transformacje dla poszczegolnych dokumentow


* 23.07.2023

chcemy dodac animacje tranzycji do modulu (transform)


* 22.07.2023

dzis/jutro/pojutrze bysmy moze sprobowali zaimplementowac
animacje tranzycji oraz tweening oparty na sinusie,
i zintegrowali to z podwojnym kliknieciem (tak jak
to wczoraj omawialismy)

* 21.07.2023 (urodzinki corenki)

wydaje sie ze juz mamy jakies systemy animacji dla
klienta awt i terminalowego, i pozostaje nam
andtoidowy

stary system animacji byl oparty o zwykle javowe timery
- a one maja taka drobna niedogodnosc, ze nie da sie
ich zatrzymac. poza tym tego postpone'a jakos chyba
zrobilismy bez timerow to moze teraz tez sie uda.

tymczasem trzeba by bylo zajac sie tweeningiem.

i trzeba to moze tak zrobic:
- jezeli kat jest niezerowy, to dodajemy animacje,
ktora go zeruje
- jezeli przesuniecie pozione jest niezerowe albo pionowe
  dodatnie, to zerujemy oba parametry
- jezeli transformacja jest skalowalna i przesuniecie
  w obu kierunkach jest zerowe, a tapnelismy na toplevelowej
  spacji, to skalujemy tak, zeby wysokosc dokumentu
  pokrywala sie z wysokoscia ekranu
- w przeciwnym razie przesuwamy tak, zeby wysokosc klikniecia
  znalazla sie na srodku ekranu, i ewentualnie dobieramy taka
  skale (nie wieksza niz 1) zeby dokument miescil sie
  na szerokosc


* 20.07.2023

tak naprawde dzis glownie sie zajelismy renderowaniem
popupoq w kliencie terminalowym, co wynikalo
z podejrzenia, ze moze cos jest nie tak z tymi
ThreadedPoolExecutorService - okazalo sie jednak,
ze problem bierze sie z pisania poza zakres
w lanternowym buforze

teraz zatem pozostaje nam teraz do zrobienia
implementacja metodd play! we wszystkich nietrywialnych
painterach, przy czym teraz jest pomysl, zeby
uzyc ConcurrentLinkedQueue na interfejsie Collection


* 19.07.2023

tak jak i wczoraj, dzis byloby dobrze zaimplementowac
tranzycje i system animacji, ale zeby tranzycje
mogly dzialac na wszystkich transformacjach (a nie tylko
na Isogonal), trzeba by bylo dodac get-scale, set-scale!,
get-angle, set-angle! get-left, set-left!, get-top,
set-top! do interfejsu Transform.

(define-type (Transition of: Transform
                         from: Transform
			 to: Transform
			 around: Point := #!null
			 duration/ms: int
			 progress/ms: int := 0)
  implementing Animation
  with
  ((advance! timestep/ms::int)::boolean
   (set! progress/ms (+ progress/ms timestep/ms))
   (let ((progress ::float (/ progress/ms duration/ms)))
     (cond
      (around
       (let*-values (((x0 y0) (of:unmap around:x around:y))
                     ((scale) (tween (from:get-scale)
		                     (to:get-scale)
		                     progress))
		     ((angle) (tween (from:get-angle)
		                     (to:get-angle)
		                     progress))
	             ((x1 y1) (begin
		               (of:set-scale! scale)
			       (of:set-angle! angle)
			       (of:unmap around:x around:y))))
         (of:translate! (- x1 x0) (- y1 y0))))
      (else
       (of:set-scale! (tween (from:get-scale) (to:get-scale)
			     progress))
       (of:set-angle! (tween (from:get-angle) (to:get-angle)
			     progress))
       (of:set-left! (tween (from:get-left) (to:get-left)
			    progress))
       (of:set-top! (tween (from:get-top) (to:get-top)
			   progress))
       ))) ;<
    (is progress/ms > duration/ms))

  ((tween initial-value::real final-value::real progress::real)
   ::real
   (cond
     ((is progress <= 0) initial-value)
     ((is progress >= 1) final-value)
     (else
      (+ initial-value
         (* (- final-value initial-value)
	    (sin (* progress pi/2))))))))

(painter:play!
  (Transition of: transform
              from: (copy transform)
	      to: (Isogonal scale: (transform:get-scale)
	                    angle/rad: 0.0
			    left: (transform:get-left)
			    top: (transform:get-top))
	      around: (Point x y)
	      duration/ms: 100))

ok, to teraz jak zaimplementowac funkcje play! w poszczegolnych
klientach?

wydaje sie, ze w kazdym przypadku to bedzie z grubsza to samo.
moze nawet nie bedziemy tego spinac z painterem?
	      
* 18.07.2023

dzis byloby dobrze zeby zaimplementowac:
- tranzycje
- system animacji

na poczatku bysmy sie skupili na kliencie
androidowym, bo aktualnie tylko w nim
dziala obracanie widoku

(define-type (Transition of: Isogonal
                         from: Isogonal
			 to: Isogonal
			 around: Point)
  implementing Animation
  with
  ((advance! timestep/ms::int)::boolean
   ...))

ale wowczas trzeba by bylo wywalic 1/scale
oraz s i c z Isogonal (co pewnie nie robi
wielkiej roznicy)

(painter:play!
  (Transition of: transform
              from: (copy transform)
	      to: (Isogonal scale: transform:scale
	                    angle/rad: transform:angle/rad
			    )
	      around: ...))

(define-interface Animation ()
  (advance! timestep/ms::int)::boolean)

(define-type (Transition of: Isogonal
                         from: Isogonal
			 to: Isogonal
			 around: Point := #!null
			 duration/ms: int
			 progress/ms: int := 0)
  implementing Animation
  with
  ((advance! timestep/ms::int)::boolean
   (set! progress/ms (+ progress/ms timestep/ms))
   (let ((progress ::float (/ progress/ms duration/ms)))
     (cond
      (around
       (let*-values (((x0 y0) (of:unmap around:x around:y))
                     ((scale) (tween from:scale to:scale
		                     progress))
		     ((angle) (tween from:angle/rad
		                     to:angle/rad
		                     progress))
	             ((x1 y1) (begin
		               (set! of:scale scale)
			       (set! of:angle/rad angle)
			       (of:unmap around:x around:y))))
         (of:translate! (- x1 x0) (- y1 y0))))
      (else
       (set! of:scale ...))))))

* 17.07.2023

teoretycznie 'pierwsza rzecz' z czwartkowej listy
juz rozwiazana - i w jakiejs mierze siodma tez.

co do drugiej i czwartej, ich wspolnym mianownikiem
jest system animacji, i to na nim bysmy sie dzis
skupili

konkretnie, w prototypie Javowym mielismy dwie
klasy:
- Animation
- AnimationSystem

pierwsza z nich reprezentuje postep pojedynczej
animacji oraz tweening z funkcja sinus.

druga natomiast posiada Timer - animate - oraz
TimerTask, ktory co 40ms wola na obiekcie android.os.Handler
metode 'post' z callbackiem, ktory - dla wszystkich
animacji - wywoluje metode 'step', a na koncu
robi screen.invalidate()

Ale my wiemy, ze tym razem nie bedzie tak latwo,
bo musimy obsligiwac (co najmniej) 3 srodowiska.

Dodatkowo moze mamy tutaj tez jakas czesc wspolna
z implementacjami Postponed i Cancellable.

W kazdym razie powinnismy wyjsc od najwazniejszego
pytania, mianowicie: jak chcemy z tego korzystac.

Ach, bo tak: bo do tej pory Animation bylo klasa,
po ktorej dziedziczyly inne klasy, a w szczegolnosci
Transition (i tak naprawde chyba tylko ona)

No ale dobra, co byśmy chcieli pisać w tym Edytorze?

;; w Editor
  (define (double-tap! finger::byte x::real y::real)::boolean
    (center-around! x y))


no swietnie, zesmy sie, kurwa, wysilili.

ale co ma robic 'center-around!'?

ma dodac nowy 'proces', czy tez nowa animacje,
do listy animacji, i ta animacja ma w kazdym
kroku wywolywac okreslona funkcje.

mozna by powiedziec tak:

(define-interface Animation ()
  (step!)::void
  (target)::Object
  )

no dobra. i teraz co?
czy animacja powinna sie odbywac z innego watku?

no raczej ze tak. z watku timera, odpalanego
co 40 ms, i zatrzymywanego gdy nasza lista jest
pusta.

w kazdym razie bysmy chyba musieli miec

(painter:animate!
  (CenterAround x y (this)))

a jeszcze raz, jak jest w starym prototypie?

jest tak, ze tworzymy obiekt Transition,
a potem wywolujemy na nim
setTargetAngle(0.0)
setTargetScale(1.0)
fixPoint(x, y)
start(duration)

kolejne pytanie by brzmialo: jaka czesc funkcjonalnosci
bedzie sie dawala przenosic pomiedzy klientami,
a jaka bedzie specyficzna?

czyli tak:

do Paintera bysmy dodali

(animate! animation::Animation)::void

oraz

(define-interface Animation ()
  (step! progress::float)::void
  (finished?)::boolean
  )


(define-object (Transition target::Isogonal)::Animation
  ...)

* 14.07.2023

okazuje sie ze z tych wszystkich rzeczy zajalem
sie problemem wstawiania elementow do dokumentu
- problem jest taki, ze w kontekscie drop! parametr
  (the-document) ma zla wartosc

stad tez trzeba bedzie dodac moze

(define-interface Embeddable (Pane Map2D)
  (pane-under x::real y::real)::Embdable
  )

* 13.07.2023

obracanie widokiem juz jako tako dziala (jupi), ale
jeszcze nie calkiem dziala mapowanie elementow
na dokument - i to jest pierwsza rzecz, ktora bysmy
sie zajeli

druga to zerowanie rotacji za pomoca podwojnego
klikniecia (i to bedzie wymagalo dodania mechanizmu
do kontrolowania animacji)

trzecia to rysowanie krawedzi dokumentu,

czwarta to niedopuszczanie do tego, zeby dokument
znalazl sie poza widokiem edytora

piata wreszcie to sprawienie zeby wyjechanie kursorem
poza krawedz widoku powodowalo przesuniecie tego
widoku

szosta, to oprogramowac walek myszki, i jeszcze
zrobic tak, zeby klawiatura dzialaka na windowsie

siodma to zrobic tak, zeby przenoszenie elementow
i zmiana ich rozmiaru z powrotem dobrze dzialaly


No dobra, chyba mamy maly problemix.
Jest sobie funkcja 'screen-position', ktora
podczas rysowania zapamietuje
'painter:current-translation-left' oraz
'painter:current-translation-top'.

A tymczasem my chcielibysmy raczej miec
document-position, czyli pozycje wzgledem dokumentu
- bo ja mozemy sobie wygodnie (za pomoca unmap?)
  przeksztalcic we wspolrzedne edytora

powinnismy tez znalezc jakis sposob, zeby te wspolrzedne
edytora przeksztalcic we wspolrzedne ekranu

* 12.07.2023

z jakichs wxgledow jak zmieniamy "default-transform"
to system nam wybucha :o (na androidzie)

* 10.07.2023

sama transformacja juz jest zaimplementowana.

teraz musimy zrobic jakiegos Draga

(define-object (Translate target::Transform)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    (target:translate! dx dy))

  (define (drop! x::real y::real vx::real vy::real)::void
    (values)))

i dodac go do drag! przy second-pressie.

To juz dziala. Mamy tez lokalne poprawki, zeby prawidlowo
mapowac wspolrzedne wskaznikow na wspolrzedne dokumentu.

Natomiast dalsze kroki, to:
- implementacja Isogonal i podpiecie stretch! do edytora
- rysowanie na szaro dokumentu poza jego
  krawedziami
- wymuszanie, zeby zawsze byla na ekranie widoczna
  jakas czesc dokumentu
- zerowanie rotacji, centrowanie na wyrazeniach itp.
  po dwukrotnym kliknieciu na pustej przestrzeni
  (co bedzie wymagalo dobudowania managera animacji)

i to by chyba byly najblizsze dwa tygodnie,
a po nich sie juz zajmiemy dzieleniem ekranu
i usprawnianiem edycji

No to teraz wrocmy z naszym tym:

;; ... wewnatrz on-press! ...
(cond
  ;; jeszcze bysmy sprawdzili czy nie ma tutaj
  ;; od razu jakiegos stretcha dla biezacego
  ;; edytora
 ((any (lambda (layer::Layer)
         (and-let* (((Stroke source-pane: ,(this)) layer))
	     layer))
           screen:overlay) ;<=
  => (lambda (stroke::Stroke)
       (screen:overlay:remove! stroke)
       (unset! (screen:dragging stroke:finger))
       (let ((p0 (stroke:points 0))
             (p1 (Point xe ye)))
         (set! (screen:dragging stroke:finger)
             (object (Drag)
	       ((move! x::real y::real dx::real dy::real)::void
	        (let ((p1x ::real (+ p1:x dx))
	              (p1y ::real (+ p1:y dy)))
		  (editor:transform:stretch!
		   p0:x p0:y p1:x p1:y
		   p0:x p0:y p1x  p1y)
	          (set! p1:x p1x)
		  (set! p1:y p1y)))
	       ((drop! x::real y::real dx::real dy::real)::void
	        (values))))

         (set! (screen:dragging finger)
             (object (Drag)
	       ((move! x::real y::real dx::real dy::real)::void
	        (let ((p0x ::real (+ p0:x dx))
		      (p0y ::real (+ p0:y dy)))
		  (editor:transform:stretch!
		   p0:x p0:y p1:x p1:y
		   p0x  p0y  p1:x p1:y)
	          (set! p0:x p0x)
		  (set! p0:y p0y)))
	       ((drop! x::real y::real dx::real dy::real)::void
	        (values)))))))
  ...)

teraz teoretycznie pozostaja nam dwie rzeczy:
- wkleic to
- zaimplementowac stretch!

a po tym bysmy sprobowali rysowac krawedzie dokumentu?


* 09.07.2023

plan jest taki, zeby:
1. zaczac od transformacji "samego przesuwania",
   Translation
2. klient terminalowy musi miec osobna implementacje
   transformacji (bez wsparcia dla obrotu i skalowania)
3. na poczatek wszystkie klienty beda obslugiwaly
   tylko te transformacje
4. ale pozniej dodamy jeszcze stretch do klientow
   nieterminalowych - Isogonal

* 07.07.2023

(define-interface Transform
  (apply! painter::Painter)::void
  (unapply! painter::Painter)::void

  (map x::real y::real)::(Values real real)
  (unmap x::real y::real)::(Values real real)

  (translate! dx::real dy::real)::void

  (stretch! x00::real y00::real x10::real y10::real
            x01::real y01::real x11::real y11::real)
  ::void
  )
  
;; i wowczas renderowanie edytora
;; wygladaloby tak

  (define (draw!)::void
    (parameterize ((the-document document)
		   (the-cursor cursor)
		   (the-selection-anchor selection-anchor))
      (let ((painter ::Painter (the-painter)))
        (transform:apply! painter)
        (document:draw! '())
	(transform:unapply! painter))))

;; no i fajnie, i teraz sobie sprobujmy wyobrazic
_'';; co trzeba zrobic zeby rozciagac widok.
;; przede wszystkim, od strony mechanicznej:

;; ... wewnatrz on-press! ...
(cond
  ;; jeszcze bysmy sprawdzili czy nie ma tutaj
  ;; od razu jakiegos stretcha dla biezacego
  ;; edytora
 ((any (lambda (layer::Layer)
         (and-let* (((Stroke source-pane: ,(this)) layer))
	     layer))
           screen:overlay)
  => (lambda (stroke::Stroke)
       (screen:overlay:remove! stroke)
       (unset! (screen:dragging stroke:finger))
       (set! (screen:dragging stroke:finger)
             
             ...)
       (set! (screen:dragging finger)
             ...)))

* 06.07.2023

jak zwykle zaczelibysmy sobie od analizy rozwiazania
ze starego prototypu.

Mamy tam interfejs Transform z metodami:
x, y, unx, uny, canvas, uncanvas, anchor,
towards.

Do tego wyglada na to, ze mamy dwie implementacje:
Grab oraz Shift, zas same obiekty mozns przekazywac
(za pomoca metod inwards i outwards) do Below,
Drag, DragAround, Point, Popup, Resize, Scroll,
Shift, Split oraz Stretch.

Obiekty Shift sa tworzone w: Below, Beside,
Panel i Popup, i sprawdzane w Resize.

Obiekty Grab sa tworzone w Editor, GRASP i
Resize.

Sprobujemy teraz zrozumiec role tych uzusow.
Jezeli idzie o Below, Beside, Panel i Popup,
mozna sobie wyobrazic, ze chodzi o to, co teraz
rozwiazujemy odejmowaniem.

Natomiast co do Grab, to tutaj oczywiscie
wchodzi w gre obracanie i skalowanie (i przesuwanie)
Edytora. Dlatego tez mamy tam haszmape

documentTransform : Document -> Grab

ktora zapamietuje, w jakiej pozycji w danym edytorze
byl ostatnio edytowany dokument

co do naszej sytuacji, to nie bedziemy robic Shiftow.
Natomiast nasxa transformacja winna sie nazywac
IsogonalTransform albo ConformalTransform

(define-type
  (Isogonal scale: real
            shift-left: real
	    shift-top: real
	    rotation: real))
	    
przy czym jest pare spraw, ktore bysmy chcieli ogarnac:

1. renderowanie klienta androidowego
2. renderowanie klienta desktopowego
3. renderowanie klienta terminalowego (tylko translacja)
4. mapowanie klikniec od edytora do dokumentu
5. scrollowanie - czyli zmiany przesuniecia
6. scrollowanie, zoomowanie i obracanie
7. do tego chcielibysmy tez zaimplementowac
   rolke myszki do scrollowania ekranu, ale takze
   do scrollowania scrolli
8. oraz sprawic, zeby wyjechanie kursorem poza
   ekran powodowalo odpowiednie przewiniecie ekranu
9. dodatkowo chcemy to, co sie znajduje poza granicami
   dokumentu renderowac na szaro


zaczelibysmy od tego, zeby podwojne klikniecie
na dokument powodowalo scrollowanie ekranu,
tzn. stworzenie obiektu Drag, ktore odpowiednio
by modyfikowalo wartosci przesuniecia w edytorze

(define-object (Editor)
  (define (second-press! finger::byte #;at x::real y::real)
    ::boolean
    (parameterize/update-sources ((the-document document)
				  (the-cursor cursor)
				  (the-selection-anchor
				   selection-anchor))
      (let-values (((selection-start selection-end)
		    (the-selection)))
    
        (and-let* ((path (cursor-at x y))
                   (`(,tip . ,subpath) path)
	           (parent ::Element (the-expression
		                      at: subpath))
	           (target ::Element (parent:part-at tip)))
          (cond
	    ((is target Space?)
             (screen:drag! finger
	                   (ScrollEditor (this))))

	    ((is target Tile?)
	     ;; tworzymy kopie elementu
	     ;; co zasadniczo powinno stworzyc operacje,
	     ;; ktora przy dodaniu elementu do dokumentu
	     ;; dodaje do historii
	     ;; (CopyElement at: source into: destination)
	     )
	     
(define-object (ScrollEditor editor::Editor)::Drag
  (define (move! x::real y::real dx::real dy::real)::void
    (editor:transform:translate! dx dy))
  (define (drop! x::real y::real vx::real vy::real)::void
   (values)))



   
* 05.07.2023

teraz tak: metody initialize nie ma. zamiast niej
jest globalna hszamapa, co wydaje sie lepszym
rozwiazaniem.

natomiast teraz bysmy sie zajeli scrollowaniem, przy czym
w kluencie terminalowym nie bedzie obslugi zoom ani rotate.

* 04.07.2023

paln na dzisiaj to doprowadzenie do edytowalnosci
tego pola tekstowego

co tam sie nam w nocy przysnilo:
zeby dodac do Layer metode "initialize"
wolana w momencie gdy juz stworzymy kursor
dla danej warstwy

no ale dobrze, kiedy juz to zrobimy, to co
wtedy bedzie?

to bysmy sie zajeli zrobieniem przelaczania
dokumentow

a kiedy to juz bedzie, to sie z kolei zajmiemy
scrollowaniem itp., przy czym tym razem bysmy
sprobowali zachowac pewne wiezy

a jak bedzie scrollowanie, zrobimy podzial
ekranu

a po nim zajmiemy sie poprawkami w edycji
i ewaluacja

i ewaluatorem wizualnym

i wizualizacja grafow


* 03.07.2023

dzis bysmy:
1. sprobowali doprowadzic do dzialania
   save-file-browser
2. jak sie uda, dodali okienko wyboru dokumentow

ad 1: musimy:
- zmniejszyc guzik
- dorobic tlo do pola tekstowego
- dobrze obsluzyc klawiature w popupie/polu tekstowym

  to bysmy zaczeli od tego, zeby dodac do paintera
  fill-background
  
* 02.07.2023

teraz bysmy zrobili text-input, co by wygladalo tak
mniej wiecej, ze oprocz Text, ktory mamy teraz, bysmy
zrobili jeszcze dziedziczaca po nim klase text-input,
ktora po prostu by uzywala innej czcionki


* 01.07.2023

teraz stoimy przed takim problemem, ze nie wiemy,
jakiej czcionki uzyc do tekstu

pomysl jest taki, ze:
- jako caption font uzyjemy tej czcionki, ktora
  mielismy w javowym prototypie
- i jako czcionki pola tekstowego rowniez
  uzyjemy odpiwiedniej czcionki, ktora nazwiemy
  text-input-font
- do paintera dojdzie draw-input-text! i input-text-extent

  ok, to tak: input-text uzywa stings_font, czyli
  NotoSerif-Regular
  guziki uzywaja menu_font, czyli Basic-Regular


* 30.06.2023

dzis niby ma byc notyfokacja hapoc, wiec jezeli
sie uda, to bym w niedziele dodal pejper do repo

poza tym trzeba wcommitowac te 8pix do repo

no a poza tym, to sie trzeba zajac tym polem tekstowym.

I teraz moze taka uwaga ogolna: pole tekstowe bedzie
mialo stala wysokosc, natomiast jego szerokosc bedzie
zmienna, i bedziemy ja ograniczac

ewentualnie mozemy zrobic tak, ze scroll przed rysowaniem
koloruje tlo? wowczas jednak nie daloby sie uzywac TextInputa
(czy moze TextFielda) spoza Scrolla.

Ewentualnie mozemy po prostu osadzic nieudekorowany tekst
w scrollbarze (nieudekorowany tj bez cudzyslowiow) i nazwac
to dniem.

* 29.06.2023

sprobujmy moze przypomniec sobie dlaczego chcemy, zeby
Pane bylo Indexable? (bo chyba byloby lepiej, gdyby
jednak nie bylo)

Zasadniczo idzie o to, ze jak mamy sobie te warstwy,
to chcemy na nich wywolac cursor-climb-up. I tylko tyle.

Ale moze powinnismy raczej zrobic

(define-interface Layer (Indexable Pane))

i sprawic, zeby PopUp bylo  Layer (co jest o tyle
latwe, ze juz nim de facto jest)

ale wtedy potrzebujemy innej nazwy na to co
teraz nazywa sie Layer. A moze nie?

Kod sie juz kompiluje i jest scommitowany.

Teraz bysmy chcieli:
- dodac obsluge pola tekstowego
- dodac obsluge nawigacji strzalkami
  (w szczegolnosci pole "scroll" powinno sie
  doscrollowywac tak, zeby zfocusowany element
  byl widoczny)


* 28.06.2023

no dobra, to plan jest taki:
1. dodajemy parametr "context" do key-typed
2. dodajemy Pane do Indexable
3. do 'overlay' dodajemy 'cursor', ktorym
   bedziemy parametryzowac (the-cursor)
4. dodajac nowego pane'a do overlaya,
   wywolujemy na nim "cursor-climb-front"

sprawdzamy, czy takie cos zadziala :D

Pane jeszcze nie jest 'indexable'.
Poki co, trzeba zrobic tak, zeby Overlay nie trzymalo
"Pane", tylko pare (Pane, cursor)

(define-type (Layer content: Pane cursor: Cursor))

wowczas bysmy robili tak, ze overlay:add!
by robil (cursor-climb-front content '())
jako pozycje poczatkowa kursora.

I wowczas te nieparzyste indeksy tak naprawde nie mialyby
znaczenia.

Ok, ale po drodze sie pojawil taki problem:
- co jezeli bedziemy mieli nielokalne wyjscie
  z parameterize/update-sources ?

Kawa definiuje np. dynamic-wind o tak:

(define (dynamic-wind before thunk after)
  (before)
  (try-finally
   (thunk)
   (after)))

zrobilismy fixa i to co teraz mamy byc moze dziala,
ale nie ma jak tego przetestowac, dlatego sobie sklonujemty druga
kopie repo i wytestujemy poprawke

no dobra, to chyba niczego nie psuje (albo testy okazaly sie
na owo zepsucie niewrazliwe - ale czy to aby mozliwe?)

to wracamy do naszego glownego tematu, czyli
sprawienia, zeby Pane bylo Indexable.
   

* 27.06.2023

dzis sie zajmiemy tym, zeby combinatorsy byly
zaczarowane

ok, to powinno dzialac - pomijajac kwestie
obslugi klawiatury

co do klawiatury, plan moglby byc taki, zeby:
- dodac kontekst do funkcji key-typed
- przeslaniac (the-cursor) przy obsludze
  overlay

To to by tak wygladalo, ze:
- z HorizontalSplit usuwamy focus
- dodajemy HorizontalSplit do Indexable
- czy ogolniej dodajemy Pane do Indexable?
- uzywamy "cursor-climb-front" do inicjalizacji kursora

* 26.06.2023

dzis dla idmiany bysmy sie skupili na zapisywaniu
plikow

widok by tak wygladal mniej wiecej:

(Below
 top:
 (Beside left: (text-field) right: (button))
 bottom:
 (file-list))

a konkretniej moze tak:

(define (save-file-browser directory::string
                           name-hint::string
			   editor::Editor)
  ::PopUp
  (let* ((window ::PopUp #!null)
         (text-field ::Scroll (text-field 0 name-hint))
         (button (Button label: "Save"
	                 action: (lambda _
			           (screen:clear-overlay!)
				   (save-document!
				     (java.io.File
				      directory
				      text-field:content)))))
	 (files (file-list directory
	                   (lambda (file::java.io.File)::void
			     (set! text-field:content
			       (text-input (file:toString))))
			   (lambda (dir::java.io.File)::void
                             (screen:remove-overlay! window)
                             (screen:overlay!
                              (save-file-browser directory
			                         text-field:content
                                                 editor)))))
	 (button-size ::Extent (button:extent))
	 (file-list-size ::Extent (files:extent))
	 (content (Below top: (Beside left: text-field right: button)
                         bottom: files)))
     (set! text-field:width (- file-list:width button:width))
     (set! window (popup content))
     window))
     
ok

czyli ogolniej: w tym tygodniu bysmy chcieli zrobic zapisywanie
plikow, co wymaga:
- uczynienia combinatorsow "Enchanted"
- zaimplementowania TextField
- ewentualnie drobnych refaktoryzacji po stronie file-list,
  tak zeby miec slowa kluczowe w argumentach i obsluge
  podwojnego klikniecia

natomiast juz nas troche swedzi, zeby zrobic jakas narracje
na SplashCon, w tym:

if we look at the top 20 languages on the TIOBE index,
we'll notice, that most of them share a common trait,
and the one which doesn't share this trate isn't considered
a 'real' (or 'professional') programming language

;; concrete data
;; pattern matching
;; (and possibly other textual notations)
;; abstract definitions

- emacs i lisp
- pliki tekstowe vs s-wyrazenia


plan developerski jest z grubsza taki:
jutro(wtorek): zrobic zeby kombinatory byly zaczarowane

pojutrze(sroda): zaimplementowac pole tekstowe

popojutrze(czwartek): zaimplementowac zapisywanie plikow

piatek: ewentualne refaktoryzacje, zapis podwojnym kliknieciem,
elastyczny mechanizm ladowania pliku init.scm tak zeby dzialal
rowniez z pliku .jar

no i przelaczanie dokumentow!

i tak w kolejnym tygodniu bysmy:
- zaczeli robic zgloszenie na splash
- przesuwanie widoku edytora
- zoomowanie widoku edytora
- i ewentualnie obracanie

a nastepnie: dzielenie ekranu

a nastepnie? ewaluacje wyrazen?

a nastepnie: pomiar predkosci ruchu palcem

a nastepnie: naprawic bledy w edycji

a nastepnue: zaczac edytowac GRASP w GRASP
oraz rozpoczac implementacje ewaluacji wizualnej


* 25.06.2023

plan jest taki, zeby:
- dodac sprawne ladowanie pliku do modulu (document)
- uzyc tej funkcji do ladowania "assets/init.scm"

i jezeli to bedziemy mieli, to sie zajmiemy scrollowaniem,
zoomowaniem i obracaniem dokumentu
(a pozniej dzieleniem ekranu i taka zmiana reprezntacji,
zeby "a::b" bylo interpretowane jako 3 tokeny podczas
ewaluacji)


* 24.06.2023

teraz chcielibysmy miec funkcje ktora laduje nam dokument
z pliku. Czyli cos w rodzaju:


(define (open-document file::java.io.File)
(call-with-input-file file ; ew. (file:getAbsolutePath)
    (let-values (((result spaces) (read-list)))
      (Document (if (empty? result)
	          (EmptyListProxy spaces)
		  result)
		file))))

* 23.06.2023

to na razie plan jest taki, zeby dodac nowy modul,
(document), w ktorym bedzie zdefiniowany typ Document,
a w kolejnym kroku bysmy sprobowali podmienic wszystkie
wystapienia document::pair na document::Document

mozemy zrobic tak:
- (parse) bedzie inkludowal (document)

czy moze na odwrot?

- draw-document! przenosimy z (primitive) do (document)

najwiecej document::pair jest w (history), ale moze
lepiej tak zostawic

* 22.06.2023

na razie nie ma pomyslu na to w jaki sposob pozycjonowac
okna - w starym prototypie mielismy zmienne globalne;
w nowym moglibysmy chciec miec parametry

pointer-left/screen, pointer-top/screen, pointer-index,
pointer-left/pane, pointer-top/pane
pointer-left/parent, pointer-top/parent

albo cos takiego.

ale na razie to olewamy, i jezeli kiedys sie pojawi
taka potrzeba w innym kontekscie, to sie nia zajmiemy

a tymczasem chcemy sie skupic na ladowaniu plikow

editor:load-file powinno dzialac tak, ze
powinna byc jakas instancja, ktora nam sledzi
wszystkie otwarte dokumenty, i to ja powinnismy
prosic o dokument - i to ona powinna byc
odpowiedzialna za ewentualne ladowanie
dokumentu, gdyby mialo sie to okazac
konieczne


Otwieranie wygląda tak:

Document document = Document.fromFile(file);
screen.layers.clear();
editor.previousDocument.put(document, editor.document);
editor.switchToDocument(document);

gdzie w klasie Document jest sobie statyczna lista
openedDocuments, natomiast Editor posiada dwie mapy:
previousDocument, ktora wskazuje na dokument, ktory
byl otwarty przed zadanym dokumentem, oraz documentTransform,
ktory przechowuje transformacje dokumentu w edytorze

a jak bysmy to chcieli miec w nowym edytorze?

... Editor ...


(define-type (Document content: ... source: File))

(define-parameter (open-documents)::(list-of Document)
  '())

(define (open-document source::File)::Document
  (or (find (is _:source eq? source) (open-documents))
    (let* ((document ...))
      (set! (open-documents) (cons document (open-documents)))
      document)))

(define-property (previously-edited document::Document)::Document
  (or (and-let* ((`(,_ ,next . ,_) (first-cell (is (car _) eq? document)
                                      (open-documents))))
         next)
      (and-let* ((`(,first . ,_) (open-documents))
                 ((isnt first eq? document)))
	 first)
      document))

(define (open-file file::File)::void
  (let ((opened ::Document (open-document file)))
    (set! (previously-edited opened) document)
    (set! document opened)))

* 21.06.2023

Okienko z plikami dziala na Androidzie, ale na desktopowych
klientach sa problemy. Prawdopodobnie jest to zwiazane
z implementacja (initial-directory) w domyslnym Keeperze,
i temu chcielibysmy sie przyjrzec najpierw

Jak to sie uda naprawicm to bysmy jeszcze sprobowali
dodac przegladanie folderow i otwieranie plikow, i bysmy sie
juz zaczeli sposobic do tego, zeby zapisywac pliki
(do tego bedzie potrzebne pole tekstowe)

no ale dobrze, najpierw testy co może być nietak
- ale podejrzenie jest takie, ze problemem jest uzycie
  wzglednej sciezki

ok, podejrzenie potwierdzone

czyli co robimy dalej?

- klikniecie na katalog powinno nam otwierac nowe okienko
  (ewentualnie usuwac stare)
- klikniecie na plik powinno otwierac ow plik w edytorze
- okienka powinny sie otwierac wokol palca
- maksymalna wysokosc okienka nie powinna
  byc wieksxa od 2/3 wysokosci ekranu


to tak jak mamy funkcje

(define (file-list directory::File
                   file-action::(maps (File) to: void)
		   directory-action::(maps (File) to: void))
  ::PopUp
  ...)

to bysmy sobie zrobili

(define (open-file-browser directory::File editor::Editor)
  ::PopUp
  (letrec ((popup ::PopUp
    (file-list directory
      (lambda (file::File)::void
        (screen:clear-overlay!)
        (editor:load-file file))
      (lambda (directory::File)::void
        (screen:remove-overlay! popup)
        (screen:overlay! (open-file-browser directory editor))))))
     popup))

no i to jako tako dziala, ale nie ma mozliwosci wypozycjonowania

pytanie jak to bylo zrobione w poprzednim prototypie

* 20-19.06.2023

teoretycznie mamy juz te ikonki, choc w praktyce
sa jeszcze nieprzetestowane

to teraz bysmy wzieli te funkcje, ktore wczesniej napisalismy,
i umiescili w odpowiednim miejscu w kodzie (no i doszlifowali
tak zeby dzialalo)

tylko pytanie: gdzie to umiescic?

Wydaje sie, ze (button) jest do tego
najodpowiedniejszym modulem

* 18.06.2023

zaczniemy od tego, zeby pobrac rozmiary ikonek dla klienta
desktopowego, a pozniej to samo dla androidowegp

* 17.06.2023

musimy zaimplementowac wyswietlanie ikon w edytorach:
- tekstowym (latwizna)
- androidowym (bylo grane)
- desktopowym (z jsvg)

  w tym drugim przypadku mamy juz dograne budowanie
  i teoretycznie napisanie kodu powinno wystarczyc

  no to teraz: jak ma wygladac ten kod?

  do paintera dochodza 3 metody:

  (icon-extent)::Extent
  (draw-directory-icon!)
  (draw-file-icon!)

teraz trzeba zaimplementowac te metody i dodac je
do interfejsu Painter


* 16.06.2023

Keeper wydaje sie dzialac.

Teraz mamy do zrobienia zasadniczo dwie operacje, tj.
otwieranie i zapis pliku

zaczniemy od otwierania, bo do zapisu bedziemy jescze
potrzebowac pola tekstowego

no ale dobra.

i teraz sprawa tak wyglada, ze chcemy miec funkcjem
ktora pobiera plik (tzn obiekt typu java.io.File)
i zwraca nam Popup z list gridem

czyli cos takiego

(define-alias File java.io.File)
(define-alias Array java.util.Arrays)

(define-type (FileButton target: File
                         action: (maps (File) to: void))
  extending Magic
  with
  ((draw! context::Cursor)::void
   (let* ((painter ::Painter (the-painter))
          (icon ::Extent (painter:icon-extent))
	  (caption ::String (target:label)))
     (draw-icon!)
     (with-translation (icon:width 0)
       (draw-caption! caption))))

  ((as-expression)::cons
   (origin (this)))

  ((extent)::Extent
   (let* ((painter ::Painter (the-painter))
          (icon ::Extent (painter:icon-extent))
	  (label ::String (target:label))
	  (caption ::Extent (painter:caption-extent label)))
     (Extent width: (+ icon:width caption:width)
             height: (max icon:height caption:height))))

  ((key-pressed key::char)::boolean
   (cond ((eq? key #\newline)
	  (act)
	  #t)
	 (else
	  #f)))

  ((label)::String
   (target:getName))

  ((draw-icon!)::void
   (let ((painter ::Painter (the-painter)))
     (painter:draw-file-icon!)))

  ((press! finger::byte x::real y::real)::boolean
   #t)

  ((tap! finger::byte x::real y::real)::boolean
   (action target)
   #t)

  implementing ($bracket-apply$ java.lang.Comparable FileButton)
  with
  ((compareTo other::FileButton)::int
   (if (other:target:isDirectory)
      +1
      (target:compareTo other:target))))

(define-object (DirectoryButton)::Enchanted
  (define (typename)::String "DirectoryButton")
  (define (draw-icon!)::void
    (let ((painter ::Painter (the-painter)))
      (painter:draw-directory-icon!)))

  (define (compareTo other::FileButton)::int
    (if (not (other:target:isDirectory))
      -1
      (target:compareTo other:target)))

  (FileButton))


(define-object (ParentDirectoryButton)::Enchanted
  (define (typename)::String "ParentDirectoryButton")
  (define (label) "..")
  (define (compareTo other::FileButton)::int -1)
  (DirectoryButton))

(define (file-list directory::File
                   file-action::(maps (File) to: void)
		   directory-action::(maps (File) to: void))
  ::Enchanted
  (let* ((filename ::String[] (directory:list))
         (n ::int (length filenames))
         (button ::FileButton[] (FileButton[] length: (+ n 1))))
    (set! (button 0) (ParentDirectoryButton
                       target: (directory:getParentFile)
		       action: directory-action))
    (for i from 0 to n
      (let ((file (File directory (filename i))))
        (set! (button (+ i 1))
	     (if (file:isDirectory)
	       (DirectoryButton target: file
	                        action: directory-action)
               (FileButton target: file
                            action: file-action)))))
    (Array:sort button)
    (let* ((scroll ::Scroll
                   (Scroll content: (ColumnGrid button)))
           (popup (PopUp content: scroll))
	   (outer ::Extent (popup:extent))
	   (available ::Extent (screen:size)))
      (set! scroll:width (- scroll:width
                            (max 0 (- outer:width
			              available:width))))
      (set! scroll:height (- scroll:height
                             (max 0 (- outer:height
			               available:height))))
      popup)))


zakladajac, ze powyzszy kod jest sprawny, zrobilibtsmy tak,
ze przycisk Open dodaje nowy file-list do overlaya, taki
ze akcja "directory-action" rowniez dodaje do overlaya
odpowiedni file-list, natomiast file-action czysci overlaye
i dodaje nowy domument, ktory otwiera w edytorze


* 15.06.2023

czyli na razie wiemy juz, ze potrzebujemy
obiekt (the-keepeer), ktory w nieandroidowych
klientach tylko wywoluje okreslone funkcje,
a w androidowych - wywoluje po otrzymaniu okreslonych
uprawnien


* 14.06.2023

wstepnie wyglada na to, ze Scroll w terminalu dziala
(choc cos sie z jakichs wzgledow jeszcze zawiesza)

no to teraz tak: w klientach graficznych bysmy chcieli
ladowac svg, natomiast w kliencie tekstowym
po prostu uzylibysmy ikonek z unicode'a

📁 ..
📄 file.grasp

po stronie paintera bysmy zrobili

(draw-directory-icon!)::void
(directory-icon-size)::Extent
(draw-file-icon!)::void
(file-icon-size)::Extent

duzo chyba teraz bedzie rozkminy koncepcyjnej, bo
na androidzie przegladarka plikow musi miec uprawnienia,
ale u pozostalych klientow juz niekoniecznie

no dobra, to odgrzebmy moze dzialanie starej przegladarki


lomNg press powoduje wstawienie pop-upu OpenFileBrowser
albo SaveFileBrowser, ktore implementuja (nasz wlasny)
interfejs PermissiomGrantedHandler, ktory dziala tak,
ze w klasie GRASP mamy metodd

@override
public void onRequestPermissionsResult(
  int requestCode,
  String[] permissions,
  int[] grantResults
)

no dobra. ale teraz takie pytanie:
w jaki sposob zroznicowac obsluge plikow
w kliencie androidowym i pozostalych?

moze opiszmy sobie jak dziala OpenFileBrowser:
ma metode perform, ktora jest wywolywana
przy nacisnieciu przycisku Open w menu edytowa

kiedy do tego dojdzie, zostaje wywolane zapytanie
o dostep do plikow, a jako kontynuacja zostaje
ustawiony sam ten obiekt.

za wywolanie kontynuacji odpowiada system, i to
on wywola metode onPermissionGranted, ktora
tworzy nowe okienko

gdybysmy chcieli dodac te funkcje do paintera,
to bysmy mieli metody

(define-interface Keeper ()
  (with-read-permissions action::(maps (...) to: void))::void
  (with-write-permissions action::(maps (...) to: void))::void
)

(define-object (PermissiveKeeper)::Keeper
  (define (with-read-permissions action::(maps () to: void))::void
    (action))
  (define (with-write-permissions action::(maps () to: void))::void
    (action)))

(define-parameter (the-keeper)::Keeper (PermissiveKeeper))


* 13.06.2023

wyglada na to, ze implementacja with-clip jest niepoorawna,
a lezace u jej podstaw funkcjonalnosci niedostateczne
do dostarczenia poprawnej implementacji.

Dlatego dzis skupilibysmy sie na tym, zeby odpowiednio
rozbudowac paintera

Zamiast

(define-syntax-rule (with-clip (w h) . actions)
  (let ((painter (the-painter)))
    (let ((x0 (invoke painter 'current-clip-left))
	  (y0 (invoke painter 'current-clip-top))
	  (w0 (invoke painter 'current-clip-width))
	  (h0 (invoke painter 'current-clip-height))
	  (x! (invoke painter 'current-translation-left))
	  (y! (invoke painter 'current-translation-top))
	  (w! w)
	  (h! h))
      (invoke painter 'clip! x! y! w! h!)
      (begin . actions)
      (invoke painter 'clip! x0 y0 w0 h0))))

chcielibysmy raczej miec

(define-syntax-rule (with-clip (w h) . actions)
  (let ((painter ::Painter (the-painter)))
      (painter:store-state!)
      (painter:clip! w h)
      (begin . actions)
      (painter:restore-state!))

znow musimy porownac Androida, AWT i terminal.
W terminalu musimy wszytskie mechanizmy
sami zaimplementowac i tak.


w starym kliencie Androidowym mielismy

canvas.save();
canvas.clipRect(0, 0, _width, _height);
canvas.translate(-hscroll, -vscroll);
target.render(canvas);
canvas.restore();

byc moze w Androidzie mozna uzyc pary

clipRect

clipOutRect

natomiast w awt mozemy zrobic tak:


(let ((previous-clip ::Shape (graphics:getClip)))
  (graphics:clipRect ...)

  (graphics:setClip previous-clip))


(define-alias ClipState java.lang.Object)

(clip! width::real height::real)::Clip
(restore-clip! clip::Clip)::void

(define-syntax-rule (with-clip (w h) . actions)
  (let* ((painter ::Painter (the-painter))
         (previous ::Clip (painter:clip! w h)))
      (begin . actions)
      (painter:restore-clip! previous)))

i w kliencie awt to by bylo:

(define (clip! w h)::Clip
(let* ((previous-clip (graphics:getClip))
         (transform ::AffineTransform
 		      (graphics:getTransform))
         (x (transform:getTranslateX))
	 (y (transform:getTranslateY)))
    (graphics:setClip x y w h)))

(define (restote-clip! clip::Clip)::void
  (graphics:setClip (as Shape clip)))


a w kliencie androidowym

(define (clip! w h)::Clip
  (let ((clip ::RectF (RectF 0 0 w h)))
    (canvas:clipRect clip)
    clip))


(define (restote-clip! clip::Clip)::void

a moze po prodtu dodac:

(with-clip w::real h::real action::(maps () to: void))

no, to na tym w koncu stanelo. jak na razie dziala
na desktopie i androidzie, zas terminal musi jeszcze zostac
przetestowany

wydaje sie, ze nastepnym krokiem jest implementacja
przegladarki plikiw - i tutaj chyba najrozsadniej
jest zaczac od implementacji przegladarki plikow
z poprzedniego prototypu

i wyglada na to, ze:
- w kliencie androidowym chcemy dodac biblioteke android-svg
- a do klienta desktopowego bysmy sprobowali jsvg



* 12.06.2023

mamy juz wyswietlanie menu w kliencie terminalowym,
a teraz bysmy sie postarali, zeby miec to samo
na androidzie i na desktopie

zasadniczo mamy to, ale nie wyglada to tak, jak bysmy
tego chcieli: funkcja do rysowania grida powinna
rysowac biale tlo

czyli do paintera powinnismy dodac

(fill-grid-cell! width::real height::real)::void

Ok, a jak to juz bedziemy mieli, to co wtedy bedzie?

W dalszym kroku bedziemy chcieli zrobic widget Scrollable
oraz przegladarke plikow.

A kiedy to juz bedzie, zrobimy ladowanie plikow oraz
okienko "Switch to...", zamiemy sie scrollowaniem okna edytora

**** I od tego momentu mozemy juz probowac rozwijac GRASP w GRASP.

I kiedy to juz bedzie, zrobimy dzielenie ekranu
oraz wstepny zarys systemu do rozpoznawania gestow.

No ale dobra. Teraz zajmijmy sie Scrollem.

(define-type (Scroll width: real
                     height: real
		     left: real := 0
		     top: real := 0
		     content: Enchanted)
  implementing Drag
  with
  ((move! x::real y::real dx::real dy::real)::void
   (let ((inner ::Extent (content:extent)))
     (set! left (max 0 (min (- inner:width width) (- left dx))))
     (set! top (max 0 (min (- inner:height height) (- top dy))))))

  ((drop! x::real y::real vx::real vy::real)::void
   (values))

  implementing Enchanted
  with
  ((draw! context::Cursor)::void
   (with-clip (width height)
     (with-translation ((- left) (- top))
       (content:draw! (recons 0 context)))))

  ((tap! finger::byte  x::real y::real)::boolean
   (content:tap! finger (- x left) (- y real)))

  ((press! finger::byte x::real y::real)::boolean
   (screen:drag! finger (this)))

  ((second-press! finger::byte #;at x::real y::real)::boolean
    (content:press! finger (- x left) (- y real)))

  ((double-tap! finger::byte x::real y::real)::boolean
    (content:double-tap! finger (- x left) (- y real)))

  ((long-press! finger::byte x::real y::real)::boolean
    (content:long-press! finger (- x left) (- y real)))

  ((key-typed! key-code::long)::boolean
    (content:key-typed! key-code))

  ((extent)::Extent
   (Extent width: width
           height: height))

  ((cursor-under* x::real y::real path::Cursor)::Cursor*
   (content:cursor-under* (- x left) (- y top) (recons 0 path)))

  ((part-at index::Index)::Indexable* content)

  ((first-index)::Index 0)

  ((last-index)::Index 0)

  ((next-index index::Index)::Index 0)

  ((previous-index index::Index)::Index 0)

  ((index< a::Index b::Index)::boolean #f)

  ((as-expression)::cons
   (invoke-special Base 'to-list cons to-expression)))

* 11.06.2023

No dobra, to teraz chcemy dodac nowe widgety:

(define-type (Link on-tap: (maps (Link byte real real) to: boolean) := always
                   on-double-tap: (maps (Link byte real real) to: boolean) := always
                   on-press: (maps (Link byte real real) to: boolean) := always
                   on-second-press: (maps (Link byte real real) to: boolean) := always
                   on-long-press: (maps (Link byte real real) to: boolean) := always
                   on-key: (maps (Link char) to: boolean) := always
                   content: Enchanted)
  implementing Enchanted
  with


* 10.06.2023

Na razie bedziemy dodawac do modulu (button):
- ColumnGrid
- Capture
- Caption

ale tez musimy dodac 3 metody do Painter
(na razie do TextPainter)

  (define 4dirs-code
    (let ((4dirs (mapping (4p::char)::int 0)))
      (set! (4dirs #\space) #b0000)
      (set! (4dirs #\╵) #b0001)
      (set! (4dirs #\╶) #b0010)
      (set! (4dirs #\└) #b0011)
      (set! (4dirs #\╷) #b0100)
      (set! (4dirs #\│) #b0101)
      (set! (4dirs #\┌) #b0110)
      (set! (4dirs #\├) #b0111)
      (set! (4dirs #\╴) #b1000)
      (set! (4dirs #\┘) #b1001)
      (set! (4dirs #\─) #b1010)
      (set! (4dirs #\┴) #b1011)
      (set! (4dirs #\┐) #b1100)
      (set! (4dirs #\┤) #b1101)
      (set! (4dirs #\┬) #b1110)
      (set! (4dirs #\┼) #b1111)
      4dirs))

  (define 4dirs ::char[]
    (char[] #\space
	 #\╵ #\╶ #\└ #\╷ #\│
	 #\┌ #\├ #\╴ #\┘ #\─
	 #\┴ #\┐ #\┤ #\┬ #\┼))

  (define (4dirs-put! c::char x::int y::int)::void
    (put! (4dirs (bitwise-ior
                  (4dirs-code (get y x))
                  (4dirs-code c))) y x))

* 09.06.2023

mamy z grubsza zarysowane metody draw! i extent,
ale do pelni szczescia bylyby nam jeszcze potrzebne:

  (define (part-at index::Index)::Indexable*
    (items index))

  (define (first-index)::Index 0)
  (define (last-index)::Index (- (length items 1)))

  (define (next-index index::Index)::Index
    (min (+ index 1) (last-index)))

  (define (previous-index index::Index)::Index
    (max 0 (- index 1)))

  (define (index< a::Index b::Index)::boolean
    (is a < b)) ;>>

przy czym te ostatnie raczej powinny byc robione
na jedno kopyto (analogicznie do tego jak zrobilismy
tego PopUpa)

(define (propagate finger::byte x::real y::real
                   action::(maps (Enchanted byte real real int) to: ?))
  (let* ((painter ::Painter (the-painter))
         (grid-border ::real (painter:grid-border))
	 (ceiling ::real grid-border)
	 (n ::real 0))
    (call/cc
      (lambda (return)
        (for item::Enchanted in items
          (let ((inner ::Extent (item:extent)))
	    (when (is ceiling < y < (+ celiing inner:height));>>
	      (return (action item finger
	                 (- x grid-border) (- y ceiling))))
	      (set! ceiling (+ inner:height grid-border))
	      (set! n (+ n 1))))
	#f))))

  (define (cursor-under* x::real y::real path::Cursor)::Cursor*
    (otherwise #!null
      (propagate 0 x y
        (lambda (item::Enchanted finger::byte x::real y::real
                 index::int)::boolean
          (item:cursor-under* x y (recons index path))))))

  (define (tap! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:tap! finger x y))))

  (define (press! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:press! finger x y))))

  (define (second-press! finger::byte #;at x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:second-press! finger x y))))

  (define (double-tap! finger::byte x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:double-tap! finger x y))))

  (define (long-press! finger::byte x::real y::real)::boolean
    (propagate finger x y
      (lambda (child::Enchanted finger::byte x::real y::real index::int)
        (child:long-press! finger x y))))

  (define (key-typed! key-code::long)::boolean
    ;; na razie tego nie obslugujemy; docelowo warto by bylo
    ;; przemyslec obsluge klawiatury
    #f)

* 08-07.06.2023

mamy zintegrowany touch event processor
- no i super, i teraz musimy to przetestowac,
  i zajac sie implementacja ButtonList
  (czyli po stronie paintera to bedzie
  rysowanie i wymiarowanie gridow)

Tyle ze to nie bedzie ButtonList.
To bedzie raczej cos w rodzaju

(Link content: (Caption "Open...")
      action: ...)

czyli Link bedzie troche jak Button

Natomiast tabele bysmy budowali tak,
ze mamy

(Table
 (Column
  (Row content: (Link content: ...)
       span: 1)


Niewazne, nie skupiajmy sie na razie na tabeli.

W razie czego to sobie przemodelujemy
Natomiast teraz pytanie jest takie, jak sie
z tym uporac od strony paintera?

Na pewno musimy zaczac od tego, zeby zmienic nazwy
metod draw-horizontal-line na draw-horizontal-split itd.

ok, to juz zrobione

teraz bysmy dodali do paintera
draw-horizontal-grid!
draw-vertical-grid!
grid-border



Jak powinien wygladac kod renderujacy
ButtonList?

(define (column . items)
  (Column items))


(define-object (Column items::(sequence-of Enchanted))::Enchanted
  (define (extent)::Extent
    (let* ((painter ::Painter (the-painter))
           (grid-border ::real (painter:grid-border))
           (max-width ::real 0)
           (total-height ::real grid-border))
      (for item::Enchanted in items
        (let ((inner ::Extent (item:extent)))
          (set! max-width (max max-width inner:width))
	  (set! total-height
	        (+ total-height inner:height grid-border))))
      (Extent width: (+ max-width (* 2 grid-border))
              height: total-height)))

  (define (draw! context::Cursor)::void
    (let* ((painter ::Painter (the-painter))
           (grid-border ::real (painter:grid-border))
	   (total ::Extent (extent))
           (n ::int 0)
           (x0 ::real (painter:current-translation-left))
	   (y0 ::real (painter:current-translation-top)))
      (painter:translate! grid-border grid-border)
      (for item::Enchanted in items
        (let ((inner ::Extent (item:extent)))
          (item:draw! (recons n context))
	  (painter:translate! 0 inner:height)
	  (painter:draw-horizontal-grid! total:width)
	  (painter:translate! 0 grid-border)
	(set! n (+ n 1))))
      (painter:translate!
       (- (painter:current-translation-left) x0)
       (- (painter:current-translation-top) y0))))




* 06.06.2023

dzisiaj priorytetem jest implementacja funkcji
do rysowania pop-upow w kliencie desktopowym,
zeby przywrocic jego budowalnosc

a jesli to sie uda, to bysmy moze sprobowali
podzialac z tym touch-event-processorem, zeby
miec juz pop-upy we wszystkich klientach

ok budowalnosc mamy,
to teraz sprobujemy zintegrowac touch-event-processor

z desktopem sie to chyba udalo. teraz zas
bysmy zrobili to samo, tylko dla terminala


w tym celu:
- stworzymy sobie

  (define events ::BlockingQueue
    (ArrayBlockingQueue 32))

teraz mamy:
    (let* ((editing (future (edit io)))
	   (rendering (future (render io))))
      ;; we want the rendering thread to have a lower
      ...)

stworzylibysmy sobie nowy watek:

(let* ((events ...)
       (preprocessing (future (process io events)))
       (editing (future (edit ioevents)))
       (rendering (future (render io))))
  ...)

ale do tego potrzebny bylby rowniez timer.

a moze sie uda bex tego preprocessingu, tylko
wtedy trzeba rozwazyc kwestie ewentualnych
wyscigow

w kazdym razie jak ma w teeminalu dzialac nasz EventRunner?


(define-interface CancellableRunner (Postponed Cancellable))

(define-object (EventRunner queue::BlockingQueue)
  ::CancellableRunner

  (define postponed-action ::(maps () to: boolean) never)

  (define timer ::java.util.Timer (java.util.Timer))

  (define (cancel)::Cancellable
    (invoke-special TimerTask (this) 'cancel)
    (timer:purge)
    (this))

  (define (after time-ms::long action::procedure)
    ::Cancellable
    (timer:schedule (this) time-ms)
    (this))

  (define (run)::void
    (queue:put postponed-action))

  (TimerTask))

Ok, to jakis zamysl jest (i jutro sie tym bardziej zajmiemy),
a tymczasem mozna pomalu myslec o widgecie ButtonsList
i o tym, jak to obsluzyc od strony Paintera


(define (rewrite-events io::LanternaScreen queue::BlockingQueue)::void
  ;; although a thread rewriting stuff from one place
  ;; to another may not seem very useful, the point is
  ;; to expose a queue, so that things can be added to it
  ;; asynchronously, from a timer event
  (while #t
    (let ((event ::KeyStroke (io:readInput)))
      (queue:put event))))


* 05.06.2023

mamy juz zrobione "rusztowanie" do odpalinia
pop-upow (w kliencie terminalowym i desktopowym),
teraz bysmy sprobowali to odpalic (np. dodajac
do pop-upa jakiegos buttona) i przeniesc tez
na desktopa, a jak to bedzie gotowe, to bysmy
tez zaimplementowali widget ButtonList

jak do tej pory naprawilismy tez aktualizacje
ekranu po opoznionym zdarzeniu (tap!), i jeszcze by
wypadalo zrobic rysowanie tla w guzikach w kliencie
androidowym, oraz zdebugowac zachowanie popupow

co niniejszym rowniez sie udalo

no to tetaz tak:
- dodac rysowanie pop-upa do klienta desktopowego
- zintegrowac touch-event-processor z klientem terminalowym
- zintegrowac touch-event-processor z klientem desktopowym
- zaimplementowac ButtonList
- zrobic menu glowne
- zaimplementowac przegladarke plikow
- funkcjonalnosc odczytu i zapisu
- przelaczanie dokumentow
- scrollowanie edytora
- podzial ekranu


* 04.06.2023

dzis wykonamy drugie podejscie do rozbicia pane
na mniejsze moduly

przede wszystkim, Screen musi sie stac interfejsem

po drugie, chcemy stworzyc null-objecta implementujacego
Screen, NullScreen, bedacego domyslna wartoscia screen.

po trzecie, biezacy Screen powinien sie stac RealScreen
albo ActualScreen

No dobra, chyba to mamy.

To teraz: tak naprawde wcale nie chcemy dodawac tego
okienka z poziomu ekranu, tylko z poziomu edytora.

Mozemy zatem skasowac sobie tego NullScreena, ale chcemy
wyizolowac modul editor

i teraz problem jest taki, ze ActualScreen
ma swoj 'top' ktory jest Editor.

Zamiast tego:
- top powinno sie nazywac content
- content powinien byc ustawiany w init,
  w sensie cos w rodzaju
  (screen:set-content! (Editor document: ...))

no, to teraz powinnismy juz moc dosc gladko
wyodrebnic modul edytora

i w dalszym kroku mozemy zaimportowac (popup) w module
(editor) i dodac przy akcji (long-press!) nowy pop-up
z jakims buttonem do screena

teraz trzeba jeszcze wyjasnic dlaczego w PopUp
nie ma metody "to-list" (czy aby jest klasÿ Struct
albo Base?)

* 03.06.2023

dzisiaj bysmy sprobowali dodac do tekstowego paintera
opcje rysowania plywajacych okien

to akurat chybs sie udalo :P

ale jest taki problem, ze modul (pane) ma zbyt wiele zaleznosci.

wiec chcielibysmy go rozbic na nastepujace:

- pane
- editor
- screen
- split
- stroke

* 01-02.06.2023

w najblizszym czasie chcemy zrobic takie rzeczy:
- plywajace okienka
- widget z lista guzikow
- ewentualnie mrugniecie guzika przed aktywowaniem akcji

najpierw sie zajmiemy plywajacym oknem

to by dzialalo jakos tak:

(define/kw (pop-up-action pop-up::PopUp
                          x::real y::real
                          inside: inner-action
			  ::(maps (Tile byte real real . list)
                             to: boolean) := never
                          outside: outer-action
                          ::(maps (PopUp byte real real . list)
                                  to: boolean) := never
			  on-the-edge: boundary-action
			  ::(maps (PopUp byte real real . list)
                                  to: boolean) := never
		          . args)
   (let* ((painter ::Painter (the-painter))
          (content ::Tile pop-up:content)
          (inner ::Extent (content:extent))
	  (horizontal ::real (painter:horizontal-popup-margin))
	  (vertical ::real (painter:vertical-popup-margin))
	  (inner-left ::real (+ left horizontal))
	  (inner-top :: (+ top horizontal))
	  (inner-right ::real (+ inner:width horizontal))
	  (inner-bottom ::real (+ inner:height vertical))
	  (right ::real (+ inner-right horizontal))
	  (botom ::real (+ inner-bottom vertical)))
     (cond ((and (is inner-left <= x < inner-right) ;>>
                 (is inner-top <= y < inner-bottom)) ;>>
	    (apply inner-action content finger
	           (- x inner-left) (- y inner-top) args))
	   ((or (is x < left) (is x > right)
	        (is y < top) (is y > bottom))
	    (apply outer-action pop-up finger x y args))
	   (else
	    (apply boundary-action pop-up finger x y args)))))


(define-type (PopUp left: real := 0 top: real := 0
                    content: Tile)

  implementing Tile
  with
  ((part-at index::Index)::Indexable*
   (match index
    ('edge (this))
    ('content content)))

  ((first-index)::Index 'edge)
  ((last-index)::Index 'content)

  ((next-index index::Index)::Index 'content)
  ((previous-index index::Index)::Index 'edge)

  ((index< a::Index b::Index)::boolean ;>
   (and (eq? a 'content) (eq? b 'edge)))

  ((cursor-under* x::real y::real path::Cursor)::Cursor*
   (call/cc
    (lambda (return)
     (pop-up-action (this) x y
      inside:
      (lambda (content::Tile finger::byte x::real y::real)::boolean
        (return
	 (otherwise #!null
	   (and path
	     (content:cursor-under*
	      x y (recons 'content path))))))
      outside:
      (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
        (return #!null))
      on-the-edge:
      (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
        (return
	  (otherwise #!null
	    (and path (recons 'edge path)))))))))

  implementing Drag
  with
  ((move! x::real y::real dx::real dy::real)::void
   (set! left (+ left dx))
   (set! top (+ top dy)))

  ((drop! x::real y::real vx::real vy::real)::void
   (values))

  implementing Pane
  with

  ((tap! finger::byte #;at x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:tap! finger x y))
     outside:
     (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
       (screen:overlay:remove! pop-up))
     on-the-edge:
     (lambda (pop-up::PopUp finger::byte x::real y::real)::boolean
       (let ((dragging screen:dragging))
         (set! (dragging finger) pop-up)))))

  ((second-press! finger::byte #;at x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:second-press! finger x y))))

  ((double-tap! finger::byte x::real y::real)::boolean
   (pop-up-action (this) x y
    inside:
    (lambda (content::Tile finger::byte x::real y::real)::boolean
      (content:double-tap! finger x y))))

  ((long-press! finger::byte x::real y::real)::boolean
   (pop-up-action (this) x y
     inside:
     (lambda (content::Tile finger::byte x::real y::real)::boolean
       (content:long-press! finger x y))))

  ((key-typed! key-code::long)::boolean
   (content:key-typed! key-code))

  implementing Enchanted
  with
  ((as-expression)::cons
   (to-list cons to-expression))
)

(define (to-expression object)
  (match object
    (magic::Enchanted
     (magic:as-expression))
    (struct::ListSerializable
     (struct:to-list cons to-expression))
    (cell::cons
     cell)
    (cell::pair
     (cons (to-expression (car pair))
           (to-expression (cdr pair))))
    (s::symbol
     (Atom (symbol->string s))
    (,@(null? object)
     (empty))
    (n::number
     (Atom (number->string n))
    (t::Text
     t)
    (s::string
     (text s))))

(painter:draw-popup!
  (+ inner:width (* 2 (painter:horizontal-popup-margin)))
  (+ inner:height (* 2 (painter:vertical-popup-margin))))


a ogolnie "kamienie milowe" bysmy okreslili jako:
- edycja GRASP w GRASP (i wypchniecie do sklepu)
- ewaluator wizualny
- kompozycjonalny system budowania rozszerzen
- ksiazka o GRASP
- ksiazka w GRASP o komputerach

* 31.05.2023

chyba ze wzgledu na klienta terminalowego
zaimplementujemy raczej ButtonList. Czyli
cos w rodzaju

(define-object (Editor)::Pane
  ...
  (define (long-press! finger::byte x::real y::real)::boolean
    (screen:overlay:add!
      (PopUp
        left: x top: y
	content:
        (ButtonList
	  (Button label: "New" action: ...)
	  (Button label: "Open..." action: ...)
	  (Button label: "Switch to..." action: ...)
	  (Button label: "Save as..." action: ...)
	  (Bitton label: "Close" action: ...)))))
  ...)

Wtedy mozemy na razie zupelnie zrezygnowac
z ustawiania rozmiaru

trzeba sie zastanowic jak do tego podejsc od strony
painterow

i moze tym sie zajmiemy pozniej.

najpierw jednak skupimy sie na przywroceniu funkcjonowania
rysowania gestow, bo to zepsulismy nasza refaktoryzacja

no dobra, to juz wyglada na naprawione

to co dalej?


teraz bysmy chcieli stworzyc pop-upa

📁 ..
📄 file.grasp

co sie stanie jezeli wyrzucimy zawartosc pop-upa ze starego
prototypu?

ogolnie nie ma takiej mozliwosci, bo kazdy pop-up
ma jakis target.


ok, to teraz painter bedzie musial otrzymac nowe metody:




* 30.05.2023

udalo sie zrobic tak zeby Overload bylo Pane
- i ten klient terminalowy teraz nawet dziala,
  choc sa problemy z androidowym, a desktopowy
  to nawrt nie byl jeszcze testowany

i pomijajac kwestie przywrocenia dzialania
- co chcemy robic dalej?

na pewno chcielibysmy miec menu, takie
jak w kliencie javowym

musimy zatem odkopac nieco starego kodu

To by teraz jakos tak wygladalo

(define-object (Editor)::Pane
  ...
  (define (long-press! finger::byte x::real y::real)::boolean
    (screen:overlay:add!
      (PopUp
        left: x top: y
	content:
        (Below
	  (Button label: "New" action: ...)
	  (Button label: "Open..." action: ...)
	  (Button label: "Switch to..." action: ...)
	  (Button label: "Save as..." action: ...)
	  (Bitton label: "Close" action: ...)))))
  ...)

no dobrze, w Javowym prototypie mielismy metode trySetSize,
i element Below mogl go sobie wywolac

I tutaj tez bysmy chcieli miec cos podobnego.

(define-interface PotentiallyResizable ()
  (try-set-width! width::real)::void
  (try-set-height! height::real)::void
  )

no dobra, ale teraz pojawia sie nam tutaj nowy aspekt,
mianowicie chcielibysmy, zeby wszystkie widgety byly
"Enchanted"

i wowczas bysmy:
1. zaimplementowali try-set-<size>! dla Button
2. zmienili czcionki na takie
   ktore wygladaja jak w starym kliencie javowym

tylko jeszcze pytanie, jak sprzac ze soba guziki
w taki sposob, zeby w kliencie terminalowym te guziki
wygladaly tak

╭────────────────╮
│┌──────────────┐│
││ New          ││
│├──────────────┤│
││ Open...      ││
│├──────────────┤│
││ Switch to... ││
│├──────────────┤│
││ Save as...   ││
│├──────────────┤│
││ Close        ││
│└──────────────┘│
╰────────────────╯

Zamiast

┌──────────────┐
│ New          │
└──────────────┘
┌──────────────┐
│ Open...      │
└──────────────┘
┌──────────────┐
│ Switch to... │
└──────────────┘
┌──────────────┐
│ Save as...   │
└──────────────┘
┌──────────────┐
│ Close        │
└──────────────┘


* 29.05.2023

zmiany, od ktorych zaczynamy obsluge plywajacych
okien:
- usuwamy move! z interfejsu Pane
- tworzymy klase Screen, zawierajaca:
  - overlay
  - dragginng
  - top-pane
  - metode move!
  - elementy overlay rowniez powinny stac sie
    Pane, natomiast Drag powinno byc klasa
    abstrakcyjna implementujaca Pane

no dobra, klase Screen juz mamy (choc bez podniety),
natomisdt pozostaja nam jeszcze takie rzeczy, jak:
- usunac move! z Pane
- spraeic, zeby Drag bylo Pane


no ale chwila

dlaczego chcemy zeby Drag bylo Pane?

to chyba bez sensu?

chcemy za to, zeby Overlay bylo Pane.



* 26.05.2023

plany na najblizszy czas to:
- przeniesc nowe cymesy tak zeby manifestowaly
  sie w kliencie graficznym

to sie moze udac nawet dzis. ale co dalej?

jeszcze bysmy chcieli moze zintegrowac
touch-event-processor z klientami pecetowymi
- ale tak naprawde chyba najlepiej to zrobic
  jak bedziemy mieli obsluzony second-press itp.,
  no bo jak inaczej to przetestujemy?

w takim razie wydaje sie, ze byc moze kolejnym
istotnym do zaimplementowania ficzerem jest
wyswietlanoe menu oraz otwieranie i zapisywanie
plikow


ale mozemy to potraktowac jako okazje do
przemyslenia jak to powinno wygladac

na razie mamy

New
Open...
Switch to...
Save as...
Close

i takue cos powinno sie rzeczywiscie pojawiac
na pustym dokumencie

ale do tego jeszcze:
Paste
History view/Document view

na wyrazeniu zas bysmy chcieli miec:
Copy
Cut
Paste (replace)

* 24.05.2023

male podsumowanie: udalo sie dodac do klienta
androidowego quote, quasiquote i unquote.

jutro bysmy sie jeszcze zajeli unquote-splicingiem
oraz cudzyslowami do stringa, a takze odpowiednim
kolorowaniem kreski oddzielajacej glowe od ogona,
a takze przeniesieniem tych zmian do klienta AWT


* 23.05.2023

no dobra, to dzisiaj bysmy wreszcie sie zajeli tymi
klientami graficznymi

czyli mamy do dodania 16 nowych funkcji,
o implementacjach raczej trywialnych

przede wszystkim jednak chcemy zaprojektowac wyglad
tych znaczkow, i moze przy tej okazji przeprojektowac
nawiasy

do tego dochodzi jeszcze taka mysl, zeby funkcje rysujace
dla quote'a i quasiquote'a sprawdzaly, czy elementem
wewnetrznym jest unquote, i w takich przypadkach rysowaly
sie ciasniej, niz w pozostalych

* 22.05.2023

dzis bysmy sie zajeli poprawka zachowania kursora
na quote'ach:
- jezeli "expression" to lista, to wtedy sie
  pod nia podszywamy
- natomiast w przeciwnym razie implementujemy
  schemat indeksacji [ 0 ]

Do tego dochodza rzeczy, o ktorych nie myslelismy,
czyli obsluga w ramach naszego systemu edycji
- i to chyba bysmy sprobowali zrobic przed implementacja
w klientach graficznych

no ale moze najpierw uporzadkujemy kwestie
kursora po zaczarowaniu wyrazenia

wydaje sie tez, ze mamy pewne problemy z unquote-splicing

ok, chyba je rowniez sie udalo naprawic.

No to co dalej?

teraz bysmy sie chyba zajeli klientami graficznymi.

albo ewentualnie obsluga cytowan w parserze.

* 20.05.2023

na pewno trzeba poprawic zachowanie kursora podczas
zaczarowywania wyrazenia, oraz zaimplementowac
podswietlanie markerow (tak jak to jest z nawiasami)

* 19.05.2023

mamy juz mniej wiecej zdefiniowane rozszerzenia
dla quote'ow. teraz:

- przetestujmy je na kliencie terminalowym
- dodajmy stosowne funkcje do klientow graficznych
- zintegrujmy te rozszerzenia z parserem

no ale najpierw trzeba dopiescic samego klienta
terminalowego, czyli:

- wyswietlanie kursora
- resize


do tego jeszcze bysmy chcieli dodac funkcje edycji:
- wcisniecie ` na nawiasie


* 18.05.2023

otoz mamy to.
teraz dalsze akcje:
- napisac rozszerzenie dla quote

  Na razie robimy to recznie, a potem moze
  cos sobie wyabstrahujemy.

wydaje sie, ze trzeba troche wyprostowac
zaleznosci w modulach

ok, to sie udalo

to terax chcemy dla tych swoich cycatow zaimplementowac:

  (part-at index::Index)::Indexable*

  (first-index)::Index
  (last-index)::Index

  (next-index index::Index)::Index
  (previous-index index::Index)::Index

  (index< a::Index b::Index)::boolean

  (draw! context::Cursor)::void
  (cursor-under* x::real y::real path::Cursor)::Cursor*

  (extent)::Extent


* 17.05.2023

to dzis moze bysmy zaimplementowali metody do quote'ow
w kliencie tekstowym, ale jeszcze bez rozszerzania
interfejsu Painter (albo na razie tylko w komentarzach)

* 16.05.2023

z jednej strony mozemy sie zajac tym event-processorem,
z drugiej - warto sie skupic na tych quote'ach
(co wydaje sie o tyle problematyczne, ze od razu
bysmy tez chcieli zrobic zmiany dla klientow graficznych)

No ale dopsz. Przywolajmy sobie rysowanie sekwencji:

tak wyglada metoda draw! w klasie cons:

  (define (draw! context::Cursor)
    ::void
    (let* ((inner (sequence-extent (this)))
	   (painter (the-painter))
	   (paren-width (painter:paren-width)))
      (painter:draw-box! (+ inner:width (* 2 paren-width))
			 inner:height
			 context)
      (with-translation (paren-width 0)
	  (draw-sequence! (this) context: context))))

moglibysmy zrobic taki enum:

(define-enum ParenType
  (Regular Quote Quasiquote Unquote UnquoteSplicing))

( quote x )
[0  1  234]


a jeszcze z innej beczki: chcielibysmy, zeby
long-press robil nam inwalidacje ekranu na Androidzie

no ale dobra, bysmy dodali takie metody do paintera:

-draw-quote-box!
-draw-quasiquote-box!
-draw-unquote-box!
-draw-unquote-splicing-box!

-draw-quote-mark!
-quote-mark-width

-draw-unquote-marks!
-unquote-mark-width
-draw-quasiquote-marks!
-quasiquote-mark-width
-draw-unquote-splicing-marks!
-unquote-splicing-mark-width

-quote-paren-width
-quasiquote-paren-width
-unquote-paren-width
-unquote-splicing-paren-width


* 15.05.2023

no to co teraz robimy:
wtorek - commitujemy to co mamy,
sroda - dodajemy touch event processor do klientow pctowych?
czwartek - operator "quote" w malarzu i parserze?

kolejny tydzien bysmy poswieili na quasiquote'y

nastepnie bysmy troche zmienili reprezentacje atomow,
dodali mozliwosc scrollowania ekranu i wczytywania plikow,
i juz od tego momentu bysmy probowali uzywac edytora
do edytowania niego samego

* 14.05.2023

no dobra, to na czym stoimy:
- mamy w miare chyba sprawny mechanizm rozszerzen
  (choc jeszcze nie wszedzie nalezycie podpiety)
- mamy touch event processor czekajacy na podpiecie
  do klientow pecetowych

i to sa takie drobniejsze rzeczy, ktorymi mozemy zajmowac
sie w miedzyczasie

natomiast tym, co nas ekscytuje nieco bardziej,
jest mechanizm cytowania

do tego trzeba:
- dodac mechanizm do paintera
- dodac rozszerzenie
- zmodyfikowac parser


natomiast samo rozszerzenie powinno z grubsza tak dzialac:
- sprawdzamy, czy nasz 'target' to lista. jezeli tak,
to renderujemy te liste ze specjalnymi nawiasami, a jezeli
nie, to renderujemy specjalne markery wokol elementu


zaczniemy od quote'a

no i trzeba pamietac, ze oprocz klienta terminaloaego
wypadaloby dodac te funkcjonalnosc w klientach graficznych,
wiec bedzie trzeba dodac odpowiednie funkcje rysujace

(define-object (quote target)::Extension

 (define (draw! context)::void
  (cond
    ((gnu.lists.LList? target)
     (draw-sequence! ze specjalnymi nawiasami)
     ...)
    (else
     (draw! ale najpierw narysuj prostokacik)
     ...)))

 (define (extent)::Extent
  (cond
    ((gnu.lists.LList? target)
     ;; rozmiar targetu + rozmiar nawiasow
     ...)
    (else
     ;; rozmiar markera + rozmiar targetu
     ...)))

 ;; i jeszcze inne metody
   )



* 13.05.2023

na razie niewiele udalo sie ustalic
(choc pewnie rzecz ma zwiazek ze status
barem)

na razie poprawilismy renderowanie
zaokraglonych prostokatow

poniewaz jednak w klientach graficznych te
napisy wygladaja dosc brzydkawo, trzeba bedzie
troche pokomplikowac malarza (ale to nic)

rowniez rysowanie linii w kliencie androidowym
powoduje swego rodzaju brzydkosc, chociaz
to pewnie szybko poprawimy


* 12.05.2023

dzis moze zaczniemy od tego przesuniecia

* 11.05.2023

rzeczy do wyjasnienia:
- dlaczego button w androidzie powoduje crash?
  - ok to juz wyjasnione (i naprawione)
- dlaczego klikanie na button nie dziala
  w klientach terminalowych?
- skad jest to przesuniecie

co wiecej, chcemy touch-event-processor podpiac
do klienta terminalowego i desktopowego
(najlepiej na asusie, tylko trzeba tam najpierw
postawic system, a zeby to sie udalo - trzeba
go uruchomic)

a kiedy to sie uda, zajmiemy sie tym quasiqouote'owaniem

normalnie 'x to (quote x)

(quote (quote x))

czyli tak:

(quote x)

jezeli x jest param to renderujemy ja
w specjalnych nawiasach


* 10.05.2023

plan z grubsza taki:
- poprawne renderowanie guzika w klientach graficznych
  (wymaga poprawek w malarzu)
- podpiecie zdarzen do rozszerzen
- podpiecie touch-event-processora do klientow pecetowych


Do tego bysmy chcieli zrobic rozszerzenie
"quote", ktore po prostu renderuje grubsze
nawiasy, albo

      ▖ ▗
'x =>  x

      ▗
'x =>  x

      ▖    ▗
'x =>  atom


▼    ▼
 atom

◤    ◥
 atom

◥    ◤
 atom



czyli tak: jezeli mamy (quote (quote ...))

* 07.05.2023

na razie bysmy tak zrobili, zeby guziki
sie dobrze wyswietlaly w klientach

trzeba tez cos wykombinowac zeby klikniecie
na atomy powodowalo wysuwanie klawiatury
(a na przyklad wcisniecie guzika tego nie powodowalo)



* 01.05.2023

teraz jakos bardziej siedzi w glowie system
obslugi zdarzen (dla kazdego klienta bedzie
trzeba zrobic osobno)

ale oprocz niego chcemy:
- mechanizm rozszerzen
- kwazi-kwotacje
- otwieranie i zapisywanie plikow
- dzielenie ekranu
- scrollowanie
- pozbycie sie bugow

  moze sie to uda osiagnac w kolejnym ufo

* 27.04.2023

no to teraz plan jest taki:
- najpierw analizujemy dzialanie systemu zdarzen
  na androidzie i ew w starej aplikacji
- nastepnie przenosimy ten model do klientow kawowych

a i jeszcze w miedzyczasie naprawiamy moze
renderowanie guzika w klientach graficznych?

* 26.04.2023

wydaje sie ze tab juz dziala (tylko trzeba jeszcze
potestowac na kliencie terminalowym), teraz zas
bysmy jeszcze sprobowali popodpinac te event handlery
w normalnych klientach (tak jak w primitive-terminal-client).

no dobra, a teraz bedzie jeszcze kilka uwag dotyczacych
obslugi inputu

mamy wszak trzy klienty, i wszystkie dzialaja
nieco inaczej


* 25.04.2023

ostatnich pare dni krecilo sie glownie wokol ELS,
w tym mojej wczorajszej prezentacji (ktorej odbior
byl zdecydowanie pozytywny)

teraz commity beda juz tylko we srode i w czwartek,
a pozniej przynajmniej tydzien przerwy

do tego czasu vysmy sprobowali zaimplementowac
te guziki w normalnych klientach

jest tez pare warpliwosci zwiazanych z reprezentacja
- bo mamy tylko jedna funkcje 'cons', choc tak naprawde
 bysmy chcieli miec dwie takie funkcje - pierwsza
do uzywania w ramach dokumentu, oraz druga do uzywania
wewnatrz aplikacji.

Rzecz jest jeszcze do przemyslenia, ale na pewno
trzeba to jakos bedzie uporzadkowac, przede wszystkim
ze wzgledu na pisanie rozszerzen.

No dobra, ale teraz mamy przed soba dwa cele:
- przetestowac zaczarowywanie i odczarowywanie
i spiac je z interfejsem (i przetestowac czy
guzik bedzie dzialal)
- zaimplementowac quasi-quotacje i te pe.

No dobra. Teoretycznie operacja  jest zaimplementowana,
tylko trzeba ja podpiac do interfejsu...

* 22.04.2023

wczoraj palcem nie kiwnelismy, to moze dzis
kiwniemy? (w samolocie?)

* 21.04.2023

To moze dzisiaj:
- dodamy enchant! i disenchant! do naszych operacji
  historycznych
- dodamy


* 20.04.2023

No dobra, czyli teraz tak:
- rozrywamy enchant/disenchant! na dwie osobne funkcje
- linkujemy te funkcje z operacjami historycznymi


* 19.04.2023

no to mamy problem.

problem pomiedzy przechodzeniem miedzy swiatem struktur,
a swiatem wartosci i z powrotem.

dotychczasowe rozwiazanie polegalo na tym, ze
mielismy mape, ktora przechowywala wyrazenie,
na podstawie ktorego zostalo wygenerowane
rozszerzenie.

ograniczeniem tego rozwiazania jest to, ze zmiany
w rozszerzeniu nie zostana uwzglednione po konwersji
z powrotem do listy

problem objawia sie np. przy wyrazeniach lambda,
ktorych po ewaluacji nie mozemy zserializowac

ale wydaje sie, ze wiekszym problemem jest brak
klarownosci umyslu.

Chodzi o to, ze z jednej strony mamy wyewaluowane struktury,
z drugiej - drzewa rozbioru skladniowego, a z trzeciej
- te same drzewa, ale jako edytowalne byty

do tej pory naszym jedynym zrodlem drzew bylo parsowanie,
ale teraz bedziemy jeszcze dodatkowo mieli:
- wyniki ewaluacji
- serializacje rozszerzen

I teraz pomysl jest taki, zeby to autor rozszerzenia byl
odpowiedzialny za jego serializacje.

Czyli w przypadku Button rzeczywiscie moglibysmy
zachowywac i przywracac oryginalna liste.

No dobra. Cos tam sobie wyjasnilismy,
a teraz pora przeniesc rozwiazanie do normalnych klientow.
To bedzie wymagalo:
1. rozbicia enchant-expression! na dwie operacje
2. dodania EnchantExpression i DisenchantExpression
   do historii
3. podpiecia tej nowej funkcji do inputu
   (w assets/init.scm?)

* 18.04.2023

plan na dzis/jutro:
- przetestowac 'construct'
- zrobic podmianke w extension i button
- zintegrowac rozszerzenia z docelowymi klientami?

A jak to sie uda, to bedziemy pisac implementacje
dla quote-ow - najpierw jako rozszerzenia, pozniej
do parsera


* 17.04.2023

no to co?

plan na dzis taki, ze refaktoryzujemy
enchant-expression! tak zeby disenchant!
bylo osobna operacja; podpinamy je
do historii i wywalamy origin, zastepujac
je uzyciem metody to-list.

No, ale tutaj pomysl jest taki, ze
bysmy mieli:

(define-property (construct type-name::symbol)::(maps (list) to: Struct)
  (lambda (_) #!null))

i define-type by dodatkowo robilo

(set! (constructor 'type)
  (lambda (properties)
    (let ((item (type)))
      (let init ((properties (cdr initializer)))
        (otherwise item
          (and-let* ((`(,key ,value . ,rest) properties))``
	    (slot-set! item (keyword->symbol key) value)
	    (init rest)))))))

a zamiastveval btsmy mieli

(define (construct struct-spec::list)::Struct
  ((constructor (car struct-spec)) (cdr struct-spec)))


a tu w niedzyczasie sie rodzi plan prezentacji
1. zamiast jednego duzego dema - duzo malych dem (i opowiesc)
2. programowanie jako srodek rozumienia
3.


* 16.04.2023

No to teraz plan jest taki, ze
dodajemy nowe metody do define-type:
- (fields transform::procedure)::list
- (as-list transform::procedure)::list

w praktyce wyszlo troche inaczej,
ale to niewazne

moglibysmy tez cos wykombinowac, zeby
nie alokowac kazdorazowo listy, tylko
zeby w zamian przechowywac zcache'owana
liste w ktorej tylko aktualizujemy pola
(za pomoca set-car!), bo w ten sposob
zachowamy spacje pomiedzy elementami

no ok, to tym sie tez zajmiemy,
i co dalej?

dalej wywalamy "origin" z (extensions)
i uzywamy to-list jako disenchant, natomiast
list->struct, a moze raczej list->extension
zamiast evala w przypadku enchanta.

No wlasnie, bo teraz chodzi o to, ze z list->struct
bedziemy mieli do czynienia tylko w sytuacjach,
gdy "extension" bedzie implementowalo Struct.

Z pewnoscia takie sytuacje beda typowe, ale
waznym wyjatkiem od tej reguly bedzie quote
i przyjaciele.

Oznacza to, ze bedziemy potrzebowac jakiejs
globalnej tablicy, ktora bedzie nam mapowala
symbole na funkcje tworzace.

ALe ale w (extension) takie cos jest juz zdefiniowane!

(define-mapping (extension keyword)
  (begin
    (WARN "no extension for "keyword)
    #f))

i jest uzywane np. przez Button o tak:

(set! (extension 'Button)
      (object (Extension)
	((create-from source::cons)::Enchanted
	 (try-catch
	  (or (as Button (eval source)) #!null)
	  (ex java.lang.Throwable
	      (WARN "Unable to create Button from "source": "
		    (java.lang.String:valueOf ex))
	      #!null)))))

No ok, i teraz zamiast (eval source) bedziemy
robili (list->struct source)?

No dobra, to sie nawet wydaje miec sens.

Natomiast dla quote'ow i innych zdefiniujemy sobie
po prostu jakis inny mechanizm (licze ze sie to wyjasni
w tym tygodniu)

Czyli jaki ma byc kolejny krok?

Teraz caly czas naszym celem jest wywalenie "origin"
z (extension). Ale z pewnoscia jak to zrobimy, to
nam sie rozlezie to wyrazenie.

Dlatego bysmy sobie wprowadzili cache'owanie
i update, i opracowali wariant Buttona, ktory
juz z "origin" nie bedzie korzystal.

Nastepnie bysmy to zintegrowali z trzema "prawdziwymi"
klientami (co byc moze bedzie wymagalo zmiany tylko
w jednym miejscu - tylko koniecznie trzeba pamietac
o uwzglednieniu historii), i napisali rozszerzenia
dla quote'a, quasiquote'a itd (co juz bedzie wymagac
zmian we wszystkich klientach, a w kazdym razie w ich
malarzach)

Jezeli sie to uda zrobic w ciagu tego tygodnia, to bedzie
arcy-zacnie.

* 15.04.2023

No dobra, to teraz mamy nowy plan:
chcemy aktywować mechanizm rozszerzen
dla guzika, tak jak w primitive-terminal-client.

powinnismy wszelako miec operacje
zaczarowywania i odczarowywania
na poziomie historii

No dobra, ale to tylko jeden aspekt.

w (extensions) mamy wlasciwosc origin,
uzywana przez enchant-expression.

chcielibysmy sie jej pozbyc, a w zamian
bysmy dodali metode to-s-expression
ktora by sie automatycznie generowala
dla struktur definiowanych przez
define-type.

Cos w stylu

(define-interface Structurizable ()
  (as-structure)::(either Atom List Text)
  (from-structure s::(either Atom List Text))::Structurizable)

(define (structure x)::(either Atom List Text)
  (match x
    (n::number
     (Atom (number->string n))
    (s::symbol
     (Atom (symbol->string s))
    (t::string
     (text t))
    (r::Structurizable
     (r:as-structure))
    (e::Element
     e)))


(as-structure conversion::(maps Object to: Object))::Object

* 14.04.2023

mamy jeszcze jakis blad z tym
komentarzem, ale na razie to sobie
odpuszczamy

no to co robimy?

dobrze by bylo sie zajac tymi
quasiquote'ami.

i tutaj plan jest taki:

- dodac wsparcie w parserze
- zintegrowac mechanizm rozszerzen

no dobra, co do parsera to
jezeli wczytamy ' ,@ , `, #' #,@ #, #`
to wywolujemy read rekurencyjnie,
po czym zwracamy odpowiednia liste
dwuelementowa

tyle ze zamiast listy powinnismy
raczej zwrocic rozszerzenie

i teraz: jak w ogole chcemy
te rozszerzenia definiowac?

(define-extension (quote item)
  ((draw! context::Cursor)::void
   (cond
     ((list? item)
      ;; zmien typ nawiasow,
      ;; wnetrze wyrenderuj normalnie
      )
     (else
      ;; wyrenderuj patyczek
      ;; przed atomem
      )))
  ((cursor-under* x y cursor)
   ...)
  ((first-index) #\')
  ((last-index) 0)
  ...)


* 13.04.2023

udalo sie zlokalizowac jeden blad
(gdy wykomentowujemy pierwszy element
listy), i teraz bysmy sie postarali
to naprawic

i moze jeszcze ten nasluch na serwerze
bysmy zrobili jako

./grasp-terminal debug-port: 12345

* 12.04.2023

Ale dzisiaj to juz na pewno zrobimy to
wykomentowywanie wyrazen, prawda?

no, to teraz tak:

do test-editor-opeations dodajemy
testy wykomentowywania wyrazen

udalo sie, ale mamy bledy, wiec
trzeba dla tych bledow napisac testy,
i nastepnie te testy naprawic.

na razie sprobujmy jednak uzupelnic
implementacje paintera dla klientow
graficznych


* 11.04.2023

Serwer gotowy i zintegrowany. Zidenyfikowalismy tez
miejsce w kodzie ktote nie tryka.

Z rzeczy do zrobienia na dzis mamy zatem:
- poprawic pejper na ELS
- dopracowac wykomentowywanie wyrazen srednikiem
- moze napisac testy?

Pod haslem 'niedaleka przyszlosc' wisi nad nami jeszcze
implementacja tgch niwych metod paintera w kliencie
graficznym, ale tym sie pewnie zajmiemy dopiero
jutro albo pojutrze.

Mamy natomiast - w zwiazku z przyszloscia nieco
odleglejsza - pewne zagwozdki odnosnie quasiquote'a.

Abstrahujac na razie od mechanizmu rozszerzen,
powinno to dzialac tak:
- jezeli renderujemy quasiquote'a po ktorym
  nastepuje wyrazeni w nawiasach, to zmieniamy nawiasy
  na podwojne
- od tej pory:
  - wszystkie wyrazenia w nawiasach renderujemy
    w podwojnych nawiasach
  - jezeli natrafimy na unquote i nawiasy,
    to renderujemy jako zwykle nawiasy,
    a zawartosc renderujemy normalnie
  - jezeli natrafimy na unquote-splicing
    i nawiasy, to renderujemy je jako zwykle
    nawiasy z wielokropkami, a zawartosc renderujemy
    normalnie
  - jezeli natrafimy na unquote bez nawiasow, to
    uzywamy 'malych haczykow na dole'
  - (analogicznie przy splicingu)

- jezeli renderujemy quasiquote'a po ktorym nastepuje
  cos innego, niz lista, to uzywamy do tego 'rozkow'

UWAGA, ZMIANA:

nie chcemy uzywac podowjnych nawiasow.

Zrobimy sobie aliasy dla `() ,() '() i ,@(), ale
tak poza tym nie bedziemy robic zadnych regul.

        0 1 2 3 4 5 6 7 8 9 A B C D E F
U+250x  ─ ━ │ ┃ ┄ ┅ ┆ ┇ ┈ ┉ ┊ ┋ ┌ ┍ ┎ ┏
U+251x 	┐ ┑ ┒ ┓ └ ┕ ┖ ┗ ┘ ┙ ┚ ┛ ├ ┝ ┞ ┟
U+252x 	┠ ┡ ┢ ┣ ┤ ┥ ┦ ┧ ┨ ┩ ┪ ┫ ┬ ┭ ┮ ┯
U+253x 	┰ ┱ ┲ ┳ ┴ ┵ ┶ ┷ ┸ ┹ ┺ ┻ ┼ ┽ ┾ ┿
U+254x 	╀ ╁ ╂ ╃ ╄ ╅ ╆ ╇ ╈ ╉ ╊ ╋ ╌ ╍ ╎ ╏
U+255x 	═ ║ ╒ ╓ ╔ ╕ ╖ ╗ ╘ ╙ ╚ ╛ ╜ ╝ ╞ ╟
U+256x 	╠ ╡ ╢ ╣ ╤ ╥ ╦ ╧ ╨ ╩ ╪ ╫ ╬ ╭ ╮ ╯
U+257x 	╰ ╱ ╲ ╳ ╴ ╵ ╶ ╷ ╸ ╹ ╺ ╻ ╼ ╽ ╾ ╿

          ┏     ┓
'(...) => ┃ ... ┃
          ┗     ┛
          ┌     ┐
`(...) => │ ... │
          ╵     ╵
       ┈┐     ┌┈
,@() => │ ... │
        └     ┘
       ╷     ╷
,() => │ ... │
       └     ┘
      ▗
'x =>  x

      ┌ ┐
`x => ╵x╵


,@x => ┈┐x┌┈
        └ ┘

,x =>╷x╷
     └ ┘

`(f ,(+ x y) ,@(- y z))

╓   ╷       ╷  ╷       ╷  ╖
║ f │ + x y │ ┈┤ - y z ├┈ ║
╙   └       ┘  └       ┘  ╜

* 10.04.2023

Wyglada na to, ze laptop od Piotra zdechl (czy
w zasadzie zepsul mu sie wlacznik)

Mamy niedzialajacy kawalek kodu do komentowania,
ale nie mamy jak odpalac desktopowego klienta.

Stad pomysl na maly skok w bok: napiszemy sobie
serwer tcp, ktory bedzie implementowal interfejs
output-server-port

Czyli tak: wywolanie (tcp-outpt-server port::short)


no dobra, to mamy tak:
(current-output-port) ma typ gnu.kawa.io.BinaryOutPort
ktory rozszerza gnu.kawa.io.OutPort,
ktory rozszerza gnu.lists.PrintConsumer i implemenfuje Printable



* 09.04.2023

jezeli jestesmy na atomie albo na spacji,
to wcisniecie srednika powinno spowodowac
zakomentowanie wyrazenia

a jezeli jestesmy na komentarzu wyrazeniowym,
to powinnismy zamiast tego odkomentowac wyrazenie

* 08.04.2023

napisalismy test, ktory jednakowoz nie przechodzi.

problem chyba jest taki, ze procedura extract!
dla nie-komentarzy dodaje szerokosc wyrazenia
do spacji, natomiast procedura insert! dla
komentarzy juz tego nie robi

no dobra, mamy poprawke.

jutro bysmy sie zajeli
- integracja wykomentowywania z interfejsem
- implementacja trybu rysowania komentarzy
  w klientach graficznych

* 07.04.2023

no dobra. mamy hipoteze dotyczaca tego, jak powinna
dzialac nasza operacja. teraz zostaje nam jeszcze
przetestowanie tych operacji, dodanie ich do interfejsu,
i dodanie testu do operacji edycji

a do tego chcemy dodac nowe metody paintera
do grasp-desktop i grasp-android

a pozniej co?

- quote'y
- scrollowanie
- podzial ekranu
- ladowanie plikow

a pozniej co?

- ewaluacja
- rozszerzenia
- partykularne rozszerzenia
- sklep + wersja platna

* 06.04.2023

test wykazal, ze trzeba jeszcze troche dopiescic
insercje. i to bysmy zrobili, plus:
- dodali operacje historyczne
- zaimplementowali w kliencie desktopowym i androidowym


(define (f x y) z)

(the-expression at: '(5 3 1 1)) ===> y

(define (f x #;y) z)

(the-expression at: '(2 4 3 1 1)) ===> #;y


(define-type (CommentExpression at: Cursor following: int)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* ((`(,expression) (take! at: at from: document))
              (`(,tip . ,root) at)
	      (cursor (recons* following (- tip 1) root)))
     (insert! (ExpressionComment expression: expression)
              into: document at: cursor)
     cursor))
  ((inverse)::Edit
   (and-let* ((`(,tip . ,root) at))
     (UncommentExpression at: (recons* following (- tip 1) root)))))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::Document)::Cursor
   (and-let* (((ExpressionComment expression: expression)
               (take! at: at from: document))
	      (`(,tip ,top . ,root) at))
     (insert! (cons expression '()) at: at into: document)
     (recons (+ top 1) root)))
  ((inverse)::Edit
   (and-let* ((`(,tip ,top . ,root) at))
     (CommentExpression at: (recons (+ top 1) root)
                        following: tip))))

* 05.04.2023

mamy niby napisany insert dla komentarzy,
ale trzeba jeszcze napisac testa.

* 04.04.2023

wyglada na to ze mamy awarie karty pamieci
i nasz projekt quote'ow wzial w leb

no to co teraz:
- insert!
- operacje historyczne
- integracja z interfejsem
- implementacje w edytorach graficznych

  ok to zacznijmy od analizy inserta

* 01.04.2023 (telefon)

Extract! juz jest zrobiony.
Teraz co jeszcze musimy zrobic:
- insert! dla komentarzy
- CommentExpression i UncommentExpression
- renderowanie wykomentowanych wyrazen
  - jako tekst
  - w terminalu (ciemniejszy kolor)


* 27.03.2023

pomysl jest taki, zeby zrefaktoeyzowac
funkcje "extract!" - tak zeby mogla zwracac
albo pare, albo separator, albo komentarz.

No, ale w tym celu musimy najpierw
przeanalizowac dotychczasowe dzialanie
tej funkcji, bo jest tak, ze rozne byly
zachowania w zaleznosci od tego,
ktory element zesmy ekstrahowali.

Rownolegle - poniewaz rysowanie gestow
zdaje sie pomagac w diagnozie - warto
poprawic klienta desktopowego

To moze przeanalizujmy architekture:

mamy screen-renderer, implementujacy
Paintera i bedacy JComponentem,
unterfejs InputListener agregujacy
rozne event handlery, oraz InputHandler,
rozszerzajacy JFrame i dostarczajacy
trywialnych implementacji.

Wreszcie jest window-screen, ktory rozszerza
InputHandler, dostarczajac nietrywialnych
implementacji handlerow tam gdzie trzeba.

I teraz plan jest taki, zeby window-screen
nie dziedziczyl po JFrame, tylko zebysmy
tworzyli JFrame, na ktorym bysmy
wywolywali setContentPane

No dobra. A co z tym naszym extractem?

* 27.03.2023 (komputer)

Master plan: window-screen powinien byc JComponentem,
run-in-AWT-window powinno tworzyc javax.swing.JFrame,
ktorego content-pane: to bedzie wlasnie window-screen.

Tylko kilka uwag:

- window-screen to nie jest dobra nazwa, i trzeba
wymyslic inna

- byc moze warto sie zastanowic nad scaleniem ze soba
tej klasy ze screen-rendererem

* 26.03.2023

(define/kw (fully-expanded? cursor::Cursor
             on: document := (the-document))::boolean
  (and-let* ((`(,tip . ,root) cursor)
             (target (cursor-ref document root)))
    (eq? target (part-at tip target))))

(define (cursor-trace document cursor)
  (match cursor
    ('() (cons document '()))
    (`(,tip . ,root)
     (and-let* ((trace (cursor-trace document tail))
                (`(,parent . ,elders) trace))
	(cons (part-at tip parent) trace)))))

no dobra. i teraz co?


* 25.03.2023

1. Wykomentowywanie wyrazen
dwie nowe operacje:

(define-type (CommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((preceding-cursor (cursor-retreat at document))
              (`(,item::Tile) (extract! at: at from: document)))
     (insert! (ExpressionComment expression: item)
              into: document at: preceding-cursor)
     preceding-cursor))
  ((inverse)::Edit
   (UncommentExpression at: ???)))

(define-type (UncommentExpression at: Cursor)
  implementing Edit
  with
  ((apply! document::pair)::Cursor
   (and-let* ((
  ((inverse)::Edit
   (CommentExpression at: ???)))

Aczkolwiek problem jest taki, ze extract!
nie obsluguje komentarzy.

To pomysl jest teraz taki, zeby
- albo dodac obsluge komentarzy
  do 'extract!' (ktorej to funkcji
  jednak nie lubimw)
- albo po prostu po chamsku
  samemu wyciagnac z komentarza


A gdybysmy tak mieli napisac extract! drugi raz?

* 24.03.2023

zmiana rozmiaru dziala w miare OK.

to teraz skupilibysmy sie na takich
tematach:
- rysowanie kresek
- wykomentowywanie wyrazen
- poprawne dzialanie drag&drop na komentarzach?

Dobra, zacznijmy od tego rysowania kresek.

(define-object (Drawing stroke::Stroke)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    (stroke:add (Point x y)))

  (define (drop! x::real y::real vx::real vy::real)::void
    (the-overlay:removeIf (is _ Stroke?)))

  (the-overlay:add! stroke))

No, to rysowanie kresek juz jako tako dziala.
Wprawdzie jest jeszcze sporo do przemyslenia,
ale juz sie troche nie moge doczekac poniedzialkowego
commita.

No dobra, i co dalej?

Kolejna rzecz jaka mozemy robic, to:

- wykomentowywanie wyrazen
- poprawki w edycji komentarzy
- drag&drop na komentarzach


* 23.03.2023

Dzisiaj:
- naprawilibysmy buga zwiazanego ze zmiana rozmiaru
  pudelka w ktorym znajduje sie linia zakonczona
  komentarzem
- dodalibysmy mozliwosc rysowania kresek

Ale warto sie zastanowic czy nie lepiej
byloby ujednolicic reprezentacje spacji w taki
sposob, zeby nowa linia pojawiala sie explicite.

Do przemyslenia (choc tak po prawdzie to pewnie
raczej nie, bo wydaje sie, ze jestesmy dosc blisko
funkcjonujacego kodu)

Wyglada na to, ze bedzie trzeba troche popracowac :/

* 22.03.2023

Dzis bysmy sprobowali przemyslec co jest
do zrobienia w kontekscie poszczegolnych
klientow (terminalowego, desktopowego
i androidowego), a jaka kompetencje powinien
miec (pane), jezeli idzie o rysowanie gestow.

I takie pytanie: czy moglibysmy zaimplementowac
rysowanie gestu jako 'Drag'?

(define-object (DrawingGesture gesture::Gesture)::Drag

  (define (move! x::real y::real dx::real dy::real)::void
    ;; dodajemy Point do stroke'a
    ...)

  (define (drop! x::real y::real vx::real vy::real)::void
    ;; wywolujemy recognizer
    ...)

  (the-overlay:add! gesture))

* 21.03.2023

Przeanalizujmy obsluge gestow w grasp-android:

mamy globalny obiekt

(define the-stroke ::Stroke #!null)
(define the-gesture ::Gesture (Gesture))

oraz funkcje 'isShapeBeingDrawn'

(define (gesture-is-being-drawn?)::boolean
  (isnt the-stroke eq? #!null))

a do tego funkcje

(define (start-drawing-gesture!)::void
  (set! the-stroke (Stroke)))

(define (cancel-drawing-gesture!)::void
  (gesture:clear!)
  (set! the-stroke #!null))


no i dobrze. ale ciekawsze jest to, w jaki sposob
te funkcje sa wywolywane:

cancelDrawingShape jest wolany w:
-onDoubleTap
-onDown (gdy przycisnieto drugi palec
albo gdy onPress zwrocilo obiekt Drag)
-onMotion gdy wygenerowano DoublePress
-onUp jezeli udalo sie rozpoznac gest
-onSingleTap
-onLongPress

z kolei startDrawingShape jest uzywany
w onDown (jezeli nic innego sie nie wydarza)

wreszcie isShapeBeingDrawn jest:
- w onDown przy sprawdzaniu czy przycisnieto
  drugi palec i przy rozpoczynaniu rysowania
  ksztaltu
- w onMotion przy dodawaniu nowego odcinka
  do aktualnego stroke'a
- w onUp przed rozpoczeciem rysowania


natomiast finalizeStroke jest wywolywany przy
konczeniu rysowania

* 20.03.2023

Rysowanie gestow
ma dwojaki sens:
- czlowiek rysuje gesty
- program rysuje linie

No ale dobra
trzeba pomyslec
w jaki sposob chcemy
reprezentowac.

Teraz w (pane) mamy cos, co sie nazywa overlay,
i do czego mozemy wlozyc obiekty Drawable.

i teraz: chcielibysmy miec obiekt "Drawable",
ktory bylby dodawany do Overlay w momencie,
kiedy zaczynamy cos rysowac.

ale jak sie on bedzie nazywal?


* 19.03.2023

teraz to bysmy chcieli miec funkcje

(define 4pix-code
  (let ((4pix (mapping (4p::char)::int 0)))
(set! (4pix #\space) #b0000)
(set! (4pix #\▘) #b0001)
(set! (4pix #\▝) #b0010)
(set! (4pix #\▀) #b0011)
(set! (4pix #\▖) #b0100)
(set! (4pix #\▌) #b0101)
(set! (4pix #\▞) #b0110)
(set! (4pix #\▛) #b0111)
(set! (4pix #\▗) #b1000)
(set! (4pix #\▚) #b1001)
(set! (4pix #\▐) #b1010)
(set! (4pix #\▜) #b1011)
(set! (4pix #\▄) #b1100)
(set! (4pix #\▙) #b1101)
(set! (4pix #\▟) #b1110)
(set! (4pix #\█) #b1111)
4pix))

(define 4pix ::char[]
  (char[]
  #\space
  #\▘
  #\▝
  #\▀
  #\▖
  #\▌
  #\▞
  #\▛
  #\▗
  #\▚
  #\▐
  #\▜
  #\▄
  #\▙
  #\▟
  #\█
  ))

(define (4pix-set! x4::int y4::int)::void
  (let* ((x ::int (quotient x4 2))
         (h ::int (remainder x4 2))
         (y ::int (quotient y4 2))
	 (v ::int (remainder y4 2))
	 (c ::char (get y x))
	 (existing-code ::int (4pix-code c))
	 (mask ::int (arithmetic-shift 1 (+ (* 2 v) h)))
	 (new-code ::int (bitwise-ior existing-code mask))
	 (c* ::char (4pix new-code)))
    (put! c* y x)))


x^2 + y^2 = r^2

y^2 = r^2 - x^2

y = sqrt(r^2 - x^2)


(x0 - radius + i)


(define (draw-circle-4pix! x0::real y0::real radius::real)::void
  (let ((diameter ::int (ceiling (* 2 radius)))
        (r^2 (* radius radius)))
    (for i from 0 to diameter
      (let* ((dx ::real (- i radius))
             (dy :: real (sqrt (- r^2 (* x x))))
	     (x ::int (as int (round (+ x dx))))
	     (+y ::int (as int (round (+ y dy))))
	     (-y ::int (as int (round (- y dy)))))
        (4pix-set! x +y)
        (4pix-set! x -y)))))


* 18.03.2023


x1-x0   y1-y0
----- = -----
  m       n

y0 = ax0 + b
y1 = ax1 + b


(define (draw-line! x0::real y0::real x1::real y1::real)::void
  (let* ((x1-x0 ::real (- x1 x0))
         (y1-y0 ::real (- y1 y0))
	 (angle ::real (atan y1-y0 x1-x0)))
    (cond
      ((is -pi/4 <= angle <= pi/4) ;>>
       (let ((slope ::real (tan angle))
             (x0 ::int (round x0)))
         (for i from 0 to (as int (ceiling x1-x0))
	   (let ((x (+ x0 i))
	         (y (+ y0 (* slope i))))
             (put! #\█ (as int (round y)) x)))))
      ((is pi/4 <= angle <= (* 3 pi/4)) ;>>
       (let ((slope ::real (/ (cos angle) (sin angle)))
             (y0 ::int (round y0)))
         (for j from 0 to (as int (ceiling y1-y0))
	   (let ((x (+ x0 (* slope i)))
	         (y (+ y0 i)))
	   (put! #\█ y (as int (round x))))))
      (else
       (draw-line! x1 y1 x0 y0)))))


▞▚
▚▞

  ▄
 ▞ ▚
▐   ▌
 ▚ ▞
  ▀

▖▗ ▘▝

 ▗▀
▐   ▌

  ▀
* 17.03.2023 (telefon)

W ramach odpinki moze sprobujemy dodac do systemu
funkcjonalnosc rysowania gestow.

Ogolnie to musi wygladac tak, ze
jak zaczynamy rysowac gest, to dodajemy
'stroke' do overlaya, natomiast sam 'stroke'
to nic innego jak lista punktow.

Na pozor wydaje sie to latwe, ale pamietajmy
takze o tym, ze chcemy tez rysowac linie
w terminalu - i dlatego chcielibysmy dodac
mozliwosc rysowania linii do interfejsu Painter.

(mozna sie tez zastanowic nad uzyciem
w GRASP renderowania w stylu Figlet)

Oczywiscie rysowanie linii trzeba zaimplementowac
dwojako: w kliencie tekstowym i terminalowym.

W przypadku klienta terminalowego bedziemy
uzywac koloru, natomiast w przypadku klienta
tekstowego bysmy uzyli tego:

▞▀▀▀▚
▌    ▌
▚    ▐
 ▚   ▞
  ▚▄▞

▛▜
▙▟ █

czyli dodajemy do paintera funkcje

(draw-line! x1::real y1::real x2::real y2::real)::void

i implementacje dla androida i awt (wolajace
pod spodem odpowiednie funkcje) oraz dla klienta
tekstowego

* 14.03.2023

Popsute klikniecia udalo sie naprawic, i powinny wyjsc
w jutrzejszej serii commitow.

Natomiast teraz chcemy sie zajac nastepujacymi rzeczami:
- dodawanie, usuwanie i edycja komentarzy blokowych
(poprzez wpisanie #| albo |# w kontekscie atomu - wowczas
powinnismy podzielic atom, np. ab#|cd powinno nam zrobic
dwa atomy ab cd, a miedzy nimi pusty komentarz blokowy)

tak naprawde to wcisniecie | powinno dzialac w taki sposob,
ze jezeli jestesmy na przedostatnim elemencie listy, to
sprawiamy, ze ta lista bedzie "dotted?". Jezeli natomiast
jestesmy na symbolu i po lewej albo prawej stronie
od kursora znajduje sie znak #, to go usuwamy
i wstawiamy komentarz blokowy (i przy okazji byc moze
rowniez rozbijamy atomy)

Wydaje sie, ze dodatkowo bedziemy chcieli zrobic
nowy rodzaj operacji edycji, ktory sobie nazwiemy
"EditSequence", o taki mniej wiecej

#+BEGIN_SRC scheme
(define-type (EditSequence operations:  (list-of Edit))
  ((apply! document)::Cursor
   (let ((result ::Cursor #!null))
     (for operation in operations
       (set! result (operation:apply! document)))
     result))
  ((inverse)::Edit
   (define (transform sequence inverted)
     (match sequence
       (`(,head::Edit . ,tail)
        (transform tail (cons (head:inverse) inverted)))
       ('()
        inverted)))
   (transform operations '())))
#+END_SRC

* 12.03.2023

Wyglada na to, ze biezaca implementacja komentarzy
blokowych popsula zupelnie detekcje klikniec.

* 09.03.2023

Do zrobienia mamy:
- usuwanie komentarzy
- chyba poprawki w inwersji dodawania komentarzy?
- renderowanie komentarzy blokowych
- edycja komentarzy blokowych
- dodawanie i usuwanie komentarzy blokowych

No dobrze, uznajmy komentarze liniowe za skonczone
(choc niewatpliwie trzeba sie jeszcze bedzie uporac
z bugami i roznymi corner case'ami, ktore jedak
na razie nie sa naszym priorytetem)

To teraz robimy komentarze blokowe.
Renderowanie musi tak przebiegac,
ze rysujemy prostokat, a wewnatrz
renderujemy tekst


* 08.03.2023

Wczoraj napisalismy funkcje do dodawania komentarzy
do spacji, oraz test dla niej.

Dzis bysmy sprobowali zintegrowac te funkcje z edytorem,
tak zeby wcisniecie srednika powodowalo dodanie komentarza
- aczkolwiek do tego bedzie jeszcze konieczne dodanie
operacji odwrotnej, tj. usuniecie komentarza

* 07.03.2023

Dzis bysmy sie zajeli edycja liniowych komentarzy.

W kolejce czeka jeszcze kilka pomniejszych rzeczy,
takich jak:
- naprawa polozen kursora na spacjach
- renderowanie lewej belki przy liniowych komentarzach
- renderowanie cudzyslowow przy stringach
- obsluga drag&dropa przy rysowaniu stringow i komentarzy

Ogolnie plan jest taki, ze najpierw skonczymy edycje
liniowych komentarzy, pozniej zrobimy pudelkowe
komentarze, a na koncu wyrazeniowe komentarze.

Kiedy to bedzie zrobione, zajmiemy sie quote'ami itd.
(oraz moze syntaxami itd.?),

a dalej bysmy zrobili to ladowanie i zapisywanie
i scrollowanie i dzielenie ekranu (ach jakie to bedzie
piekne)

i wowczas dalsze rzeczy bedziemy juz robic w samym
GRASPie! (jupi!)

No ale dobra. Teraz robimy edycje komentarzy.
Powinno to dzialac tak mniej wiecej:
1. jezeli jestesmy na spacji i wcisniemy ;,
to dodajemy do tej spacji nowy liniowy komentarz
(i odpowiednio przesuwamy kursor)
2. jezeli od tego miejsca nacisniemy na (pustym)
komentarzu backspace, to usuwamy komentarz
3. jezeli nacisniemy "delete" na poczatku komentarza,
to usuwamy caly komentarz
4. jezeli wciskamy na zwykly klawisz, to po prostu
   dopisujemy odpowiedni znak do komentarza
5. jezeli mielibysmy dopisac znak nowej linii,
   to dzielimy komentarz

To ostatnie bedzie najpewniej wymagalo zaimplementowania
interfejsu Textual w LineComment

Trzeba bedzie dodac nowe operacje:
(InsertComment content: TextualComment at: Cursor)

oraz

(RemoveComment content: TextualComment at: Cursor)

a takze

(CommentExpression at: Cursor)

oraz

(UncommentExpression at: Cursor)


* 06.03.2023

Dzisiaj musimy tak zmodyfikowac cursor-under* w Space,
zeby dawal poprawne indeksy podczas iterowania
(zeby klikanie na komentarze umieszczalo kursor
w odpowiednim miejscu)

Ponadto mozna by cos pokombinowac, zeby kursor
znajdujacy sie normalnie na spacji byl na takiej
samej wysokosci, co liniowy komentarz, jezeli
za nim znajduje sie liniowy komentarz.

No dobrze. To "Space::cursor-under*" powinien
sie zachowywac analogicznie do "advance!".

Wyglada na to, ze w pierwszym wierszu
komentarza wszystko dziala jak nalezy
- ale ze w drugim wierszu juz nie udaje
sie zlapac.

To sie chyba udalo jakos naprawic.

** Problem z generic-dispatch i subclassigniem

Przy okazji - problem, ktory pojawia sie, gdy mamy
"generic dispatch" oraz "subclassing" - i jest to
problem zasadniczo nierozwiazywalny:

(define-class <a> ())

(define-class <b> (<a>))

(define b (make <b>))

(define-class <c> (<a>))

(define c (make <c>))

(define-method (m (x <a>) (y <a>)) 'aa)
(define-method (m (x <b>) (y <a>)) 'ba)
(define-method (m (x <a>) (y <c>)) 'ac)

(m b c)

* 05.03.2023

W najblizszym czasie - w zwiazku z implementacja
komentarzy liniowych - bedziemy mieli do zrobienia
takie oto prace:
1. zeby klikanie na ekranie powodowalo umieszczenie
kursora w odpowiednim miejscu
2. zeby pisanie powodowalo dodawanie tekstu do komentarza
3. zeby komentarze mozna bylo przeciagac i upuszczac
4. zeby upuszczenie pudelka nad komentarzem powodowalo
   jego serializacje? (ale wtedy chyba to samo chcielibysmy
   dla stringow, c'nie?)


* 03.03.2023

Chyba z rysowaniem komentarzy udalo sie juz jakos dojsc
do ladu.

Ale teraz z kolei mamy inny problem:

kiedy kursor jest we wlasciwej czesci dokumentu, to nie dochodzi
do rysowania go.

* 02.03.2023

Wyglada na to, ze mamy problem z przypisywaniem indeksow
podczas rysowania spacji.

No to w takim razie przeanalizujmy sobie

Mamy 3 interesujace metody w Space:
1. draw!
2. advance!
3. cursor-under*

No i dobra, i teraz rozwazmy sobie te metode
draw!.

Ona robi tak, ze definiuje sobie wewnetrzna petle,
ktora "zjada" fragmenty spacji i sledzi wartosc "total".

I teraz tak: czym jest ow parametr "total"?

Pierwotna interpretacja byla taka, ze jest to
informacja o tym, ile spacji udalo sie juz przeskoczyc.

Mamy jednak przed soba kilka trundych kwestii:
- nie wiemy, czy poprzednia interpretacja w ogole byla dobra
- nie wiemy, jaka powinna byc nowa interpretacja

No, wezmy sobie

(Space fragments: (list 2 LC 2 LC))

Dziala to tak, ze najpierw total wynosi 0. Nastepnie:
- wywolujemy (advance-with-cursor! width) i dodajemy
width do total
- nastepnie mamy LC. Ono powinno byc na indeksie 3
kolejna 2


** a to takie tam bazgrolki:

︴
︴

⌇
⌇
⌇

╭  ╮
︴ ︴
︴ ︴
︴ ︴
╰

⸾        ╭         ╮      ⌇
⸾ define ┆ map f l ┆      ⌇
⸾        ╰         ╯      ⌇
⸾ ⸾                     ╮ ⌇
⸾ ⸾ match l             ┆ ⌇
⸾ ⸾                     ┆ ⌇
⸾ ⸾ ⸾ ┏  ┓ ┏  ┓ ╮       ┆ ⌇
⸾ ⸾ ⸾ ┇  ┇ ┇  ┋ ┆       ┆ ⌇
⸾ ⸾ ⸾ ┗  ┛ ┗  ┛ ╯       ┆ ⌇
⸾ ⸾ ⸾ ╓      ╥      ╖ ╮ ┆ ⌇
⸾ ⸾ ⸾ ┋ head ┋ tail ┋ ┆ ┆ ⌇
⸾ ⸾ ⸾ ╙      ^      ╜ ╯ ╯ ⌇


⸾   ⌇
⸾   ⌇
⸾   ⌇


⏭ ⏮ ⏯
⏴⏵⏶⏷⏸⏹⏺

* 01.03.2023

Wczoraj nie udalo sie osiagnac zbyt wiele - ale mimo
wszystko cos sie udalo!

Dzis zajelibysmy sie pisaniem staromodnych testow
dla "space-fragment-index", "delete-space-fragment!",
"Space:last-index", oraz zaimplementowalibysmy
w LineComment interfejs Textual
(ogolnie chcielibysmy zeby BlockComment takze
obslugiwal ten interfejs - ale ExpressionComment
juz niekoniecznie)

No ale dobra: rzecz ma sie tak, ze:
- wystapienie LineComment powodje pojawienie
  sie nowej linii (czyli tak jak pojawienie sie
  dwoch liczb po sobie)
- ale wystapienie BlockComment czy ExpressionComment
  juz niekoniecznie

Ale teraz jak to ogarnac?

Mamy takie operacje:
- rysowanie
- mierzenie
- klikanie

Poniewaz na razie rzecz wyglada nieco kiepskawo
jezeli idzie o diagnostyke, to zaimplementujemy
renderowanie komentarzy w kliencie desktopowym.

* 28.02.2023

Wczoraj z grubsza sie udalo zaimplementowac renderowanie
w kliencie tekstowym i terminalowym, ale nie mamy jeszcze
obslugi klikania, i strzalki w lewo i prawo tez jeszcze
nie calkiem dzialaja.

Dlatego dzis moze sprobowalibysmy sie zajac tymi dwiema
kwestiami.

* 27.02.2023

Do rozdzielenia juz doszlo, i wyglada na to,
ze niczego to nie psuje.

Teraz mamy dwa najistotniejsze watki:
1. zaimplementowac min-box-height na Androidzie
2. sprobowac dodac slowo kluczowe 'default
do domyslnych interfejsow, i usunac metode
"advance!" z implementacji Tile.

A w dalszej kolejnosci sprobowalibysmy pojsc
taka droga:
1. zaimplementowac komentarze liniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
2. zaimplementowac komentarze blokowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
3. zaimplementowac komentarze wyrazeniowe
  - dla klienta terminalowego
  - dla klienta desktopowego
  - dla klienta androidowego
4. rozwazyc uzycie mechanizmu rozszerzen
  do wyswietlania quote, quasiquote, unquote, unquote-splicing
5. wprowadzic obsluge quote, quasiquote, unquote,
  unquote-splicing do parsera

No dobra, czyli teraz: komentarze liniowe dla klienta
terminalowego (i textowego)

To zaczynamy od tekstowego.
Bedzie trzeba dodac testy jednostkowe,
natomiast w przypadku terminalowego - jeszcze
ustawic kolory odpowiednio.

No dobra. Implementacja komentarzy musi sie skladac
z nastepujacych metod:
1. draw!
2. extent
3. cursor-under

* 24.02.2023

Teraz pomysl jest taki, ze poniewaz zakladamy,
ze linie skladajace sie tylko z komentarzy liniowych
moglibysmy ze soba scalac, moglibysmy rozdzielic
parametr "min-line-height" na "min-box-height"
i "min-line-height"

Gdzie jest uzywany min-line-height?

- W (extent '())
- w (empty-space-extent)
- przy inicjalizacji "traversal" jako max-line-height
  w traverse
- przy inicjalizacji obiektu Traversal w Space:extent
- w funkcji resize! do zmiany rozmiaru pudelka
- w metodzie new-line! obiektu Traversal
- w metodzie atom-extent w CharPainterze


* 23.02.2023

bysmy moze zaczeli od zaimplementowania
draw-line-comment! i draw-box-comment!
w painterze (tzn. w TextPainterze,
TerminalPainterze, screen-rendererze,
a w pozniejszym czasie rowniez
w androidowym View).

Dla TextPainter bysmy tylko robili

dla TerminalPainter bysmy tez dodali
troche koloru.

│ jeden srednik
┃ dwa sredniki
┣ trzy sredniki
┣━ cztery sredniki
┣━━ piec srednikow

Wreszcie dla screen-renderera - i docelowo
dla Androida tez - bysmy wybrali jakas
zwariowana czczionke

Jezeli idzie o komentarze pudelkowe,
to bysmy je tak rysowali:

┌───┐
│   │
└───┘

Lispiarze maja ogolnie taka konwencje, ze
;;; Heading
;;;; subheading
;;;;; subsubheading

No dobra, ale pozostaje nam jeszcze kwestia
tego, ze chcielibysmy, zeby komentarze liniowe
byly jedna linia pod druga, tzn. zeby nie bylo
miedzy nimi takiego duzego odstepu, jak w przypadku
atomow

* 22.02.2023

Wydaje sie, ze przynajmniej pozornie:
- dodanie rysowania do komentarzy bedzie
raczej proste
- dodanie "cursor-under*" wymaga nieco myslenia
- dodanie 'advance!' tez powinno byc raczej latwe

No to zastanowmy sie nad tym "cursor-under*"

Mamy sobie kopie obiektu traverse.
Funkcja "cursor-under" odejmuje t:left i t:top
od otrzymanych wartosci left i top.

Ale z jakichs wzgledow implementacja cursor-under*
w Space przywraca rame odniesienia dla danego
obiektu Traverse.

Ogolnie rzecz biorac to ma sens o tyle, ze
spacje nie sa "foremne" i moga rozciagac sie
na wiele linii.

No ale dobra. W przypadku spacji transformujemy
wspolrzedne z powrotem do ukladu wspolrzednych
obiektu (the-traverse).

To teraz zamysl jest taki:
1. implementujemy metody draw!, cursor-under* oraz advance!
   dla wszystkich trzech odmian komentarzy
2. integrujemy to sobie w obiekcie space
3. wszystko hula i sie cieszymy

No dobrze, ale mamy tak:

|---------------+--------------------+------------------------+--------------------------|
| metoda        | LineComment        | BlockComment           | ExpressionComment        |
|---------------+--------------------+------------------------+--------------------------|
| draw!         | rysujemy           | rysujemy               | najpierw rysujemy        |
|               | jakis znacznik     | pudelko wewnatrz       | spacje (mozemy sobie     |
|               | i renderujemy      | ktorego renderujemy    | zalozyc ze sa zerowe)    |
|               | tekst (ale trzeba  | tekst (trzeba pomyslec | a po nich wyrazenie      |
|               | pomyslec o kolorze | o kolorze i kroju      | - ale trzeba w jakis     |
|               | i kroju czcionki)  | czcionki)              | sposob zmienic tryb      |
|---------------+--------------------+------------------------+--------------------------|
| cursor-under* |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|
| advance!      | normalnie          | normalnie              | najpierw spaces:advance! |
|               |                    |                        |                          |
|---------------+--------------------+------------------------+--------------------------|


Trzeba przemyslec jakie zmiany by nalezalo wprowadzic do paintera.

Moglibysmy po prostu dodac:

enter-comment-drawing-mode!
exit-comment-drawing-mode!

A co z cytowaniem?

increase-quotation-level!
decrease-quotation-level!

increase-quasiquotation-level!
decrease-quasiquotation-level!

No i jeszcze co ze zwyklymi komentarzami?

draw-line-comment!
draw-block-comment!

line-comment-extent
block-comment-extent


╭        ╭         ╮      ╮
│ define │ map f l │      │
│        ╰         ╯      │
│ ╭                     ╮ │
│ │ match l             │ │
│ │                     │ │
│ │ ╭ ┏  ┓ ┏  ┓ ╮       │ │
│ │ │ ┃  ┃ ┃  ┃ │       │ │
│ │ ╰ ┗  ┛ ┗  ┛ ╯       │ │
│ │ ╭ ╓      ╥      ╖ ╮ │ │
│ │ │ ║ head ║ tail ║ │ │ │
╰ ╰ ╰ ╙      ^      ╜ ╯ ╯ ╯


╭        ╭         ╮      ╮
┆ define ┆ map f l ┆      ┊
┆        ╰         ╯      ┊
┆ ╭                     ╮ ┊
┆ ┆ match l             ┆ ┊
┆ ┆                     ┆ ┊
┆ ┆ ╭ ┏  ┓ ┏  ┓ ╮       ┆ ┊
┆ ┆ ┆ ┇  ┇ ┇  ┋ ┆       ┆ ┊
┆ ┆ ╰ ┗  ┛ ┗  ┛ ╯       ┆ ┊
┆ ┆ ╭ ╓      ╥      ╖ ╮ ┆ ┊
┆ ┆ ┆ ┋ head ┋ tail ┋ ┆ ┆ ┊
╰ ╰ ╰ ╙      ^      ╜ ╯ ╯ ╯




* 21.02.2023

Dzis bysmy sie zajeli tym, zeby komentarze byly uwzgledniane
przy renderowaniu, rozmiaru wyliczaniu i myszki klikaniu.

I to wyglada tak, ze mamy sobie funkcje "traverse",
ktora wywoluje naprzemiennie zadana akcje oraz
metode advance! na obiekcie traversal.


W przypadku rysowania mamy item:draw!,
dla mapowania kursora mamy item:cursor-under*
natomiast przy wyliczaniu 'extent' nie mamy
zadnej akcji, ale mamy okreslona funkcje
zwracajaca.

I teraz: tutaj nic nie bedziemy zmieniac.

Musimy tylko zaktualizowac metody wewnatrz
Space:
- draw!
- cursor-under*
- advance!

* 20.02.2023

No dobra, wydaje sie, ze edycje z klawiatury mamy
jakos tam zaimplementowana.

Moze finalnie bedzie trzeba wprowadzic jakas
dywersyfikacje dla delete-forward! i delete-backward!
(zeby kursor lepiej sie zachowywal)

No, ale teraz zajelibysmy sie juz innymi sprawami:
- po pierwsze, renderowaniem komentarzy (i to az w trzech
smakach) oraz nawigowaniem po komentarzach, edycja
komentarzy, ... (czyli mowiac krotko - edycja komentarzy)

- po drugie, obsluga kawowych rozszerzen skladniowych,
tak zebysmy mogli parsowac zrodla GRASP,
a przy okazji zajelibysmy sie obsluga rozszerzen
jako takich, tak zeby moc wyswietlac quote'y,
unquote'y i quasiquote'y, a takze - skoro to juz jest
w jakiejs formie - to moze nasz guzik?

- po trzecie, bysmy wreszcie zrobili to otwieranie
i zapisywanie plikow, scrollowanie widokow oraz
podzial ekranu

- a po czwarte - przywrocilibysmy podsystem gestow

Pozostaje jeszcze kwestia naszego pejperu,
do ktorego chcielibysmy dopisac informacje o tym,
jak ma byc zaprojektowany system gestow,
oraz screenow z rysowania gestow.

No ale tak:
do interfejsu Painter dolozymy metody
-quasiquote!
-unquote!
-quote!
albo cos w tym rodzaju

Chodziloby o to, ze:
- teksty i nawiasy ktore nie sa owiniete w quote'a
  ani unquote-a rysujemy normalnie
- teksty i nawiasy owiniete w jednego quote'a rysujemy
  pogrubione
- teksty i nawiasy owiniete w jednego unquote'a
  rysujemy kursywa

Czy cos. Jakos to sprobujemy pomyslec.

Na razie jednak te komentarze.

Problem jest taki, ze:
- LineComment i BlockComment wymagaja (text)
- ExpressionComment wymaga (space)
- (text) wymaga (space)

Wydaje sie zatem ze moze rzeczywiscie
bedzie trzeba utworzyc jakis interfejs
ktory bedzie w (space), natomiast same
implementacje umiescimy gdzie indziej
(moze w (text) i (primitive))

Natomiast metody, jakich bedziemy potrzebowac,
to:
- print


OK, na razie udalo sie wyodrebnic modul z komentarzami.

I co chcemy dalej?

No, dalej to z pewnoscia chcemy wyswietlac
te komentarze, uwzgledniac je przy wyliczaniu
rozmiarow i przy klikaniu kursorem

Co wiecej: w kliencie terminalowym chcielibysmy
wyswietlac komentarze w ciemniejszym kolorze,
zas w klientach graficznych uzyc do tego celu
jakiejs smiesznej czcionki.

I moze tym bysmy jutro sie zajeli, a pozniej
dodali do operacji edycji mozliwosc odkomentowywania
i zakomentowywania wyrazen oraz dodawania blokow
komentarzy i zakomentowywania linii


* 18.02.2023

*bold*
/italic/

╭        ╭         ╮                                   ╮
│ define │ map f l │                                   │
│        ╰         ╯                                   │
│   ╭                                                ╮ │
│   │ march l                                        │ │
│   │                                                │ │
│   │    ╭ ◹╭    ╷    ╮ ◹╭  ╭     ╮  ╭         ╮ ╮ ╮ │ │
│   │    │  │  h │  t │  │  │ f h │ ◿│ map f l │ │ │ │ │
│   │    ╰  ╰ ◿  ╵ ◿  ╯  ╰ ◿╰     ╯ ○╰         ╯ ╯ ╯ │ │
│   │    ╭ ◻╭  ╮        ◻╭  ╮ ╮                      │ │
│   │    │  │  │         │  │ │                      │ │
╰   ╰    ╰  ╰  ╯         ╰  ╯ ╯                      ╯ ╯


╭        ╭         ╮                  ╮
│ define │ map f l │                  │
│        ╰         ╯                  │
│ ╭                                 ╮ │
│ │ match l                         │ │
│ │                                 │ │
│ │ ╭ ┏      ┓ ┏  ┓ ╮               │ │
│ │ │ ┃      ┃ ┃  ┃ │               │ │
│ │ ╰ ┗      ┛ ┗| ┛ ╯               │ │
│ │ ╭ ╓      ╖ ╓ ╭        ╮     ╖ ╮ │ │
│ │ │ ║ head ║ ║ │ f head │     ║ │ │ │
│ │ │ ║ ____ ║ ║ ╰_______ ╯____ ║ │ │ │
│ │ │ ║      ║ ║ ╭            ╮ ║ │ │ │
│ │ │ ║ tail ║ ║ │ map f tail │ ║ │ │ │
╰ ╰ ╰ ╙      ╜ ╙ ╰            ╯ ╜ ╯ ╯ ╯

⋮

◴
▴◹○
▾
▲
▼

▮◀◀  ▮◀  ▶/▮▮  ▶▮  ▶▶▮

Pomalu sobie pomysliwamy
zeby quote i quasiquote implementowac
jako rozszerzenia (tyle ze musialyby byc
dostepne i wstawiane podczas parsowania)

* 17.02.2023

Wiele bledow udalo sie wczoraj naprawic, ale na pewno
sa tez takie, ktorych nie udalo sie znalezc ani obsluzyc.

Co nam teraz pozostaje:
- zrobmy tego delete-forward!
- poprawmy parser tak, zeby zamiast '() wstawial
  (empty) - tam gdzie powinien

To sa jednak rzeczy do scommitowania w kolejnym tygodniu
(choc zrealizowac je mozemy juz dzis)

Natomiast w weekend bysmy sie zajeli uzupelnieniem
ELSowego pejpera o referencje i kody CCS (na pewno
trzeba tez dodac medc.mark.dev i ewentualnie Bochser
oraz ten drugi GRASP)

OK, czyli moze na poczatku przyszlego tygodnia by sie
udalo miec delete-character! i tematyke edycji z grubsza
zamknieta (modulo ewentualne bugi)

Natomiast w dalszej kolejnosci mamy:
- obsluge komentarzy
- obsluge specjalnej skladni
- otwieranie i zamykanie plikow
- scrollowanie ekranu
- dzielenie ekranu

Zakladamy, ze to minimum do ELS (choc oczywiscie
mozemy sie pomylic), a jesli tak, to moze sie jeszcze
uda:

- mechanizm rozszerzen (we wszystkich klientach)
- rozszerzenie Button
- obsluga gestow (glownie a Androidzie, ale wszedzie
  indziej czemu nie?)

Natomiast celowalibysmy w to, zeby te funkcjonalnosci
byly juz implementowane w samym GRASPie.

* 16.02.2023

Ostatni przypadek testowy wykazal problem z robieniem "undo!"
merge'a, wiec to nim bysmy sie dzis zajeli.

Poza tym sprobowalibysmy przetestowac operacje na tekscie,
a jezeli czas pozwoli, to rowniez bysmy sprobowali
zrobic delete-backward!

OK, z tym merge'owaniem to sprawa wydaje sie nieco grubsza,
bo wyglada na to, ze operacja inverse nie dziala prawidlowo

Byc moze jednak bedzie to okazja do tego, zeby usunac
pole "document" z wiekszosci operacji edycji.

Ale bedzie trzeba albo dodac dodatkowe pole do

(SplitElement with: Space
              at: Cursor := (the-cursor)
	      in: pair := (the-document))

badz

(MergeElements removing: Space
               at: Cursor := (the-cursor)
               in: pair := (the-document))

albo moze tak:

(SplitElement with: Space at: Cursor)
(MergeElements removing: Space after: Cursor)

tak zeby

(inverse (MergeElements removing: Space after: Cursor))
= (SplitElement at: Cursor with: space)


* 15.02.2023

Mamy zrobione wstawianie znakow w atomy
i to jako tako dziala.

Ale duzo rzeczy jeszcze nie dziala, wiec
plan jest taki, ze:

- chcemy popisac troche testow dla funkcjonalnosci,
ktora mamy, i dla tej, ktorej jeszcze nie mamy

- zrobic scalanie historii kasowania znaku
  (analogicznie do scalania historii dodawania
  znaku)

- oraz naturalnie zaimplementowac
  delete-forward!

Commity moga byc robione dopiero dzis i jutro,
a nastepny w niedziele, dlatego byloby super
zamknac do jutra kwestie zwiazane z edycja.

* 13.02.2023

Wczoraj udalo sie zrealizowac (1). Dzisiaj
bysmy sie sprobowali zajac (2).

Ale trzeba ustalic nieco szczegolow, bo
zasadniczo chcemy, zeby kursor zachowywal
sie poprawnie, tzn. zeby operacja "redo!"
po wykonaniu "undo!" dzialala tak jak wczesniej.

Ale czy rzeczywiscie musimy sie tym martwic?
Operacje zapamietuja sobie przeciez polozenie
kursora, na ktorym operuja.

No dobra, spojrzmy zatem na [[analiza-edycji]] (28.01.2023)

* 12.02.2023

Na razie napisalismy wiekszosc pejpera - zostaly
nam jeszcze tylko referencje i kategoryzacje.

Natomiast teraz chcemy:
1. wyjasnic dlaczego jak dodajemy [] do "toplevelu",
to kursor jest zle pozycjonowany

2. zaimplementowac delete-backward! z obsluga historii

3. zaimplementowac delete-forward!?


* 09.02.2023

Wczoraj udalo sie poprawic blad w historii. Natomias
wczorajsze cele zasadniczo pozostaja w mocy, ale
do tego dochodzi jeszcze poprawienie edycji stringow.

* 08.02.2023

Dzisiaj na pewno chcemy przebadac i naprawic system
"undo!", i jakby sie udalo, to takze zaimplementowac
delete-backward! i zastanowic sie, co zrobic z
delete-forward!.

Mozna tez juz pomalu myslec o zgloszeniu na ELS.

* 07.02.2023

Teraz rzeczy do zrobienia:
- optymalizacja historii: chcemy scalac ze soba operacje
InsertCharacter o ile naleza do tej samej klasy
(czyli dodawanie spacji albo dodawanie nie-spacji)
no i oczywiscie spelnione sa warunki ciaglosci kursora.

To jedna rzecz.

Druga rzecz, to chcemy przetestowac czy operacje
dzielenia i scalania atomu dobrze dzialaja.

Trzecia rzecz wreszcie, to chcemy zaimplementowac
operacje kasowania.

* 06.02.2023

Mamy mala zagwozdke dotyczaca tego, w jaki sposob reprezentowac
usuwanie znaku w sytuacji, gdy robimy delete-forward! - ale
to na szczescie jeszcze nie jest palaca kwestia.

No dobra, dzis zajelibysmy sie tym:
- jezeli jestesmy na granicy atomu (lewej albo prawej)
  i wstawiamy bialy znak, to InsertCharacter powinien
  dotyczyc nie tego atomu, tylko graniczacej spacji
- Space powinno implementowac Textual
- jezeli wstawiamy bialy znak do srodka atomu, to powinnismy
  wygenerowac operacje Split, natomiast jezeli kasujemy
  spacje z wnetrza atomu, to powinnismy wygenerowac operacje
  Join

I taki oto jest plan na dzis.

No i OK. I teraz mamy takie cus:

(define-interface Textual ()
  (insert-char! c::char index::int)::void
  (delete-char! index::int)::char
  (char-ref index::int)::char
  (truncate! length::int)::void
  (subpart start::int)::Textual
  (text-length)::int
  )

Natomiast po stronie spacji to mamy metody:
- insert-space!
- insert-break!
- delete-space!

oraz funkcje
- insert-space!
- insert-break!
- insert-whitespace!
- delete-space!
- join-spaces!
- split-space!

Dobrze by bylo, gdybysmy przynajmniej pojeciowo
sprobowali sobie zmapowac, czy tez wypowiedziec
relacje, pomiedzy join-spaces! oraz split-space!,
a metodami subpart oraz truncate! interfejsu
Textual.

Otoz: subpart i truncate! sa uzywane w funkcji
insert! w przypadku dzielenia atomu.

Czyli teoretycznie funkcje "split-space!" moglibysmy
zaimplementowac analogicznie.

Ale jednak pomysl mamy duzo lepszy - usunmy
funkcje subpart i truncate, i zamiast nich
stworzmy metode split!

OK, to mamy:
- metode split! zamiast truncate! i subpart w Textual
- Space jako instancje Textual


* 04.02.2023

Wczoraj udalo sie wprowadzic InsertCharacter i RemoveCharacter
- tzn dodawanie znakow do obiektow Textual - ale koszt tego
przedsiewziecia byl taki, ze teraz mamy zepsuta obsluge spacji.

Wydaje sie tez, ze chcielibysmy:
- uzywac nowej metody (cursor) do wyliczania polozenia
kursora
- usunac reczne manipulacje kursorem z kodu
- moze bysmy zrobili tak, ze po prostu funkcja apply!
bedzie zwracala kursor, i usunelibysmy metode
(cursor)?


* 03.02.2023

wczorajszy plan o refaktoryzacji "Extract" pozostaje w mocy.
Ale do tego dochodzi jeszcze kilka pomyslow:

- na razie wydaje sie, ze probujemy zrobic takie cos:
  edycja: wcisniecie klawisza -> dispatching -> dodanie operacji
  -> wykonanie operacji -> dispatching -> wlasciwa edycja
  cofanie: wybor operacji -> dispatching -> wlasciwa edycja

  gdzie "wykonanie operacji" to albo "insert!" albo "extract!",
  natomiast historyczne operacje to Insert albo Remove.

  Mozna rozwazyc, czy nie lepiej po prostu miec operacje
  InsertExpression i RemoveExpression, albo moze zostawmy
  juz to i zamiast tego dodajmy InsertCharacters oraz
  RemoveCharacters, a takze SplitElements i MergeElements

Ale moze na razie to olejmy? Niech sobie bedzie ten
podwojny dispatching.

Byc moze tez bysmy chcieli sprawic, zeby Space bylo Textual
(ale akceptowalo tylko #\space i #\newline)?

Na razie olewamy.

No OK, wyglada na to, ze problemem jest to, ze odwrotnosc
"Insert" w przypadku znakow nie dziala najlepiej.

Dlatego moze dodamy operacje InsertCharacter i RemoveCharacter

OK, one zostaly dodane.

Teraz jednak wydaje sie, ze bylby sens, zeby Space
byl Textual.

* 02.02.2023

kilka planow na dzis:
- zrefaktoryzowac extract! w taki sposob, zeby biezacy
  "extract!" stal sie "extract-from-cell!" albo cos takiego,
  natomiast "glowny" extract! zeby dispatchowal:
  1. jezeli rodzicem wyrazenia jest pair?, to wywolujemy
     extract-expression-from-cell!
  2. jezeli docelowym wyrazeniem jest atom, to wywolujemy
     extract-character-from-atom!
  3. jezeli docelowym wyrazeniem jest text, to wywolujemy
     extract-character-from-text!
 (4. jezeli idzie o rozszerzenia, to na razie nie wiemy
     co robic, ale kiedys na pewno wymyslimy)

Trzeba tez bedzie cos pomyslec o refaktoryzacji, bo wydaje sie,
ze niektore rzeczy sa niepotrzebnie rozbite na (document-operations).
(editor-operations) oraz (history) - a wiekszosc operacji w tych
modulach dotyczy edycji dokumentu!

No, ale w praktyce wyszlo tak, ze dodalismy interfejs Textual,
i implementacje w Atom oraz Text.

Jeszcze bysmy chcieli wywalic te funkcje:

(atom-length a::Atom)
(insert-char! c::char a::Atom index::int)
(delete-char! a::Atom index::int)
(truncate-atom! a::Atom length::int)
(atom-subpart a::Atom start::int)

i zastapic je uzyciem metod interfejsu.

* 01.02.2023

Dzis bysmy sie zajeli tym, zeby "undo!" i "redo!" przy dodawaniu
spacji i pojedynczego znaku dzialalo poprawnie

Zaczniemy od pojedynczego znaku.

Nie ma problemu z dodawaniem znaku, poniewaz ten przypadek
obsluzylismy w funkcji "insert!".

Jednak funkcja "extract!" zostala przemianowana z funkcji
"take-cell!", ktora zawierala w sobie zalozenie, ze dotyczy
wyodrebniania elementow z komorek.

Teraz bedziemy chcieli odejsc od tego zalozenia.

Tzn. moze w okreslonych warunkach biezaca funkcja bedzie
sie nazywac "extract-from-cell!"

Powinnismy natomiast okreslic warunki wyodrebniania.

(extract! at: cursor from: document)

zasadniczo dziala w taki sposob, ze wyrazenie
znajdujace sie pod kursorem zostaje wyodrebnione.

I teraz tak: jezeli kursor jest "pelny", to

(eq? (the-expression at: cursor)
     (the-expression at: (cdr cursor)))

Czyli zasadniczo sprawdzamy, kto jest rodzicem naszego elementu:
- jezeli jest to para (a nasz element to nie spacja)
  to wywolamy "extract-tile-from-cell!"
- jezeli jest to atom, to usuwamy znak i zwracamy go
- jezeli jest to spacja, to zwrocimy albo nowa linie, albo
  znak spacji - chyba ze spacja jest pusta, wtedy
  albo scalamy elementy (jesli mozemy), albo nic
  nie robimy

No dobra, czyli przychodzi nam do glowy kolejna para operacji:

(SplitElement at: Cursor with: Space)
(MergeElements at: Cursor removing: Space)

ktore jednak mozna uznac za

(Remove element: Space from: Cursor)
(Insert element: Space at: Cursor)

* 31.01.2023

Musimy dokonac analizy intelektualnej problemu kursora
i historii.

Wydaje sie bowiem, ze mamy dwa rodzaje operacji:
drag&drop, ktory nie powinien wplywac na polozenie
kursora (a moze moze?) oraz edycje z klawiatury,
ktora ewidentnie wplywa na polozenie kursora

Byc moze latwiej bedzie zalozyc, ze drag&drop
rowniez wplywa na polozenia kursora (bo zasadniczo
to sie wydaje nie miec znaczenia), i ze zawsze
umieszczamy kursor za dodanym elementem
albo przed usunietym elementem.

-----


[Insert element: (f) at: (1 2 1 1)]
[Insert element: ('i') at: (1 3 1 1)]

===>
[Insert element: (fi) at: (1 2 1 1)]
[Insert element: ('n') at: (2 3 1 1)]

===>
[Insert element: (fin) at: (1 2 1 1)]
[Insert element: ('e') at: (3 3 1 1)]

===>
[Insert element: (fine) at: (1 2 1 1)]

Warunek jest taki:
- jezeli ostatnia operacja to wstawienie atomu A
dlugosci L na pozycji (_ n . x), a kolejna operacja
to wstawienie znaku C na pozycji
(L (+ n 1) . x), to zmieniamy operacje w historii
tak, ze jest to dopisanie symbolu AC na pozycji (_ n . x).


* 30.01.2023

OK, to teraz:
- albo piszemy testy jednostkowe
- albo probujemy implementowac poszczegolne
  funkcjonalnosci (pamietajac o zaimplementowaniu
  undo! i redo! oraz o polozeniach kursora)

Wydaje sie tez, ze trzeba przemyslec sprawe
zachowania kursora w kontekscie operacji
historycznych oraz drag&dropa.

Co do drag&dropa to mamy pewna koncepcje.


* 28.01.2023

<<analiza-edycji>>

Plan na teraz jest taki:
1. wypisujemy sobie wszystkie operacje dopuszczalne
  z klawiatury (na razie bez rozszerzen, ktore wszelako
  dodamy pozniej)
2. dla kazdej takiej operacji piszemy "test jednostkowy",
uwzgledniajacy rowniez operacje "undo!" i "redo!"
3. poczatkowo napiszemy po prostu duzo testow jednostkowych,
ale wiekszosc z nich pozostanie zakomentowana
4. bedziemy powoli dodawac funkcjonalnosci, odkomentowujac
poszczegolne testy - ale przy tym bedziemy uwazac, zeby
kod pozostal w miare ladny i elegancki, wiec nie bedziemy
sie spieszyc

A kiedy to sie uda zrealizowac, to wowczas zajmiemy sie
trawersowaniem i nawigowaniem po komentarzach oraz obsluga
pelnej skladni Kawy uzytej w implementacji GRASP, zeby dalej
moc edytowac GRASPa z poziomu niego samego.

Poniewaz zas zbliza sie luty, bedzie trzeba sie zajac
napisaniem zgloszenia na ELS.

No dobra, to teraz lista (albo tabela?)

Zacznijmy od tego:

A. insert-char!

  1. jezeli element pod kursorem to tekst, to po prostu
     wstawiamy znak do tego tekstu i zwiekszamy wierzcholek
     kursora o 1

 (2. analogicznie, jezeli element pod kursorem to rozszerzenie,
     to przekazujemy znak do rozszerzenia (i to juz ewentualnie
     rozszerzenie zajmuje sie kursorem))

  3. jezeli wstawiany znak to #\[, to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to
     tworzymy nowe pudelko
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym pudelkiem
   (c. docelowo: jezeli mamy wybrana selekcje, to owijamy selekcje
     w pudelko)

  4. jezeli wstawiamy znak #\", to:
    a. jezeli kursor jest na spacji albo krawedzi atomu, to
     tworzymy nowy Text
    b. jezeli kursor jest wewnatrz atomu, to przedzielamy atom
     nowym Textem

  5. jezeli wstawiamy spacje albo nowa linie, to:
    a. jezeli jestesmy na spacji, to odpowiednio powiekszamy spacje
    b. jezeli jestesmy na atomie, to dzielimy atom i dodajemy spacje

  6. jezeli wstawiamy atomowa litere w spacje, to tworzymy nowy atom

  7. jezeli wstawiamy atomowa litere w atom, to po prostu dopisujemy
     te litere do atomu (scalajac odpowiednio operacje Insert)


B. delete-backward!

  1. jezeli jestesmy na lewej krawedzi spacji za nawiasem
     zamykajacym, to kasujemy cale wyrazenie zamykane przez
     ten nawias
  2. jezeli jestesmy na lewej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawwiasy
  3. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta, kasujemy
        wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
     (od prawej strony)
  4. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na lewej krawedzi spacji za atomem, to
     usuwamy ostatni znak z tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja poprzedzajaca
     ten atom
  6. jezeli jestesmy wewnatrz spacji, to kasujemy poprzedzajaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak przed
     kursorem. Jezeli przed kursorem nie ma zadnego znaku,
     to usuwamy spacje przed atomem, chyba ze ta spacja jest
     zerowa - wowczas scalamy biezacy atom ze wczesniejszym
     atomem
  8. jezeli jestesmy na lewej krawedzi atomu i przed atomem
     jest nawias zamykajacy (oraz pusta spacja), to kasujemy cale
     wyrazenie
  9. jezeli jestesmy na lewej krawedzi atomu albo niepustej spacji
     za nawiasem otwierajacym, to nic robimy

C. delete-forward!

  1. jezeli jestesmy na prawiej krawedzi spacji przed nawiasem
     otwierajacym, to kasujemy cale wyrazenie otwierane przez
     ten nawias
  2. jezeli jestesmy na prawej krawedzi spacji wewnatrz pustych
     nawiasow, to kasujemy te nawiasy
  3. jezeli jestesmy na nawiasie otwierajacym pusta pare nawiasow,
     to
     a. jezeli spacja wewnatrz tych nawiasow jest pusta,
        kasujemy to wyrazenie
     b. w przeciwnym razie kasujemy zawarta w wyrazeniu spacje
       (od lewej strony)
  4. jezeli jestesmy na nawiasie zamykajacym pusta pare nawiasow
     i spacja wewnatrz jest pusta, tzn. (Space fragments: (0)),
     to kasujemy te pare nawiasow
  5. jezeli jestesmy na prawej krawedzi spacji przed atomem,
     to usuwamy pierwszy znak tego atomu, a jezeli to jedyny znak,
     to usuwamy atom i scalamy biezaca spacje ze spacja znajdujaca
     sie za tym atomem
  6. jezeli jestesmy wewnatrz spacji, to kasujemy nastepujaca
     spacje (czyli albo odpowiednio zmniejszamy wartosc fragmentu,
     albo w ogole usuwamy fragment)
  7. jezeli jestesmy wewnatrz atomu, to usuwamy znak za kursorem.
     Jezeli za kursorem nie ma zadnego znaku, to usuwamy spacje
     za atomem, chyba ze ta spacja jest zerowa - wowczas scalamy
     biezacy atom z nastepujacym atomem

  8. jezeli jestesmy na prawej krawedzi atomu i za atomem
     jest nawias otwierajacy (oraz pusta spacja), to kasujemy
     cale wyrazenie
  9. jezeli jestesmy na prawej krawedzi atomu albo niepustej
     spacji przed nawiasem zamykajacym, to nic nie robimy


* 26.01.2023

Odkrylismy, ze klawisze w kliencie terminalowym nie sa
obslugiwane poprawnie, i mozemy sie sprobowac zajac
ich naprawa.

OK, to juz zrobione.

I co daley?

Trzeba w jakis sposob usystematyzowac edycje. Ogolnie
mamy dwie kwestie:
- modyfikacja dokumentu
- modyfikacja polozenia kursora

Do tego dochodzi nam jeszcze kwestia "odwracalnosci operacji",
w tym - w szczegolnosci - odwracalnosc operacji kasowania
(oraz scalanie operacji edycji na poziomie znaku w historii)

Dobrze by bylo rowniez rozprawic sie z kwestia reprezentacji
selekcji, bo aktualnie wydaje sie, ze (the-selection-anchor)
nie dziala zbyt dobrze.

Wreszcie byloby doskonale, gdybysmy mieli pelna obsluge selekcji.
Ale wydaje sie, ze to nie na teraz.

Ogolnie musimy tez pamietac, ze oprocz edycji z klawiatury
oraz wsparcia dla komentarzy, chcielibysmy tez w jakis sposob
reprezenotwac quote'y i unquote'y.

Natomiast w kwestii najpredszych zmian, warto byloby dodac
kolorowanie wybranego nawiasu, i warto by bylo tez obsluzyc
podswietlanie nawiasu na ktorym znajduje sie kursor.

* 25.01.2023

Wczoraj sie udalo zrobic dopisywanie znakow do atomow.
Dzisiaj natomiast zajelibysmy sie spacjami i nowymi liniami.

Chodzi zasadniczo o to, ze:
- znak spacji lub nowej linii na poczatku albo na koncu atomu
  powinien zostac dodany do przylegajacej spacji
- znak spacji lub nowej linii wewnatrz atomu powinien spowodowac
  przelamanie tego atomu
- znak spacji albo nowej linii wewnatrz spacji powinien
  pozostac w tej spacji
- znak spacji albo nowej linii wewnatrz Textu powinien
  po prostu zostac do niej odpowiednio dodany

Takie rzeczy chcielibysmy zaimplementowac, ale tez przy okazji
pojawia sie perspektywa refaktoryzacji - chodzi o to, czy
nie daloby sie zrobic tak, zeby to box, albo spacja, albo tekst
decydowaly o tym, w jaki sposob sie zachowac - bo ostatecznie
rozszerzenia powinny rowniez byc w stanie obslugiwac inputy
na swoj sposob.

---

po dzisiejszym dniu nasuwa sie kilka uwag:
1. dziwne zachowanie kursora
2. (the-selection-anchor) to upierdliwy mechanizm,
bo trzeba sie nim zajmowac przy kazdej aktualizacji kursora
3. chcielibysmy miec symetrie pomiedzy dodawaniem i usuwaniem
4. mamy kilka dziwnych bledow


* 24.01.2023

Ponizej jest sobie costam jakos tam napisane.

Natomiast tym, na czym zalezy nam przede wszystkim,
sa testy jednostkowe w test-editor-operations.scm.

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone - zmienic nazwe na "extract-from-box!"?

2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu pierwszego
     czyli:
     - merge-boxes!
     - merge-atoms!

4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
     - merge-texts!
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

1. insert! [lista do spacji]
   - wyodrebnic "insert-into-box!"
2. insert! [spacja do atomu]
   - rozbijamy atom na dwa -
3. insert! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. insert! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. insert! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem



* 23.01.2023

Musimy dodac obsluge wstawiania spacji w spacje
do procedury insert!, jak rowniez obsluge pozostalych
sytuacji, takich jak:

- wstawienie znaku w Atom
- wstawienie znaku w Text
- wstawienie spacji/nowej linii w Atom
- wstawienie spacji/nowej linii w Text

Z pewnoscia chcemy tez napisac testy jednostkowe


* 22.01.2023

Mini-plan jest taki, zeby przeniesc funkcje
delete-forward!, delete-backward!, insert-character!
oraz delete! do primitive-terminal-client!
i dodac im przedrostek np. old!, tak zebysmy
mieli do nich dostep, ale zebysmy mogli zaczac
pisac nasze funkcje od poczatku.

Rzecz w tym, ze chcielibysmy, zeby te nowe funkcje
byly juz zaposredniczone w historii.

No ale. Plan na jutro rano jest taki, zeby:
- scommitowac zminy nazw z take-cell! na extract!
oraz ze splice! na insert!
- scommitowac przeniesienie funkcji z editor-operations
do primitive-terminal-client oraz nadanie przedrostka /old/
- zaczac pisac implementacje dla insert-character!
(i zmodyfikowac domyslna funkcje keymap tak, zeby
wywolywala insert-character!)


* 21.01.2023

No, to teraz mozemy radosnie
dodawac nowy ficzer edycji do GRASPa.

Najogolniej rzecz biorac, chcemy, zeby
wcisniecie klawisza powodowalo domyslnie
wywolanie

(insert-character! (unicode-input)
             into: (the-document)
               at: (the-cursor))

gdzie:
- jezeli input to lewy nawias i jestesmy na spacji,
tworzymy nowe pudelko
- jezeli input to prawy nawias i jestesmy na lewym nawiasie,
atomie albo spacji, to idziemy do nastepnego zamykajacego nawiasu

dosc obszerna analize do przetrawienia mamy napisana
6 stycznia.

najblizsze commit w poniedzialek; programowanie
na telefonie jest duzo dostepniejsze, ale
na laptopie komfort pisania jest nieporownywalnie
lepszy.

OK, to z takich bardziej podstawowych rzeczy:
- chcemy zmienic nazwy z take-cell! na extract!
i ze splice! na insert!
(nie do konca juz pamietamy, dlaczego chcemy,
ale mimo wszystko nadal chcemy?)

W kazdym razie nazwy zostaly juz zmienione.

No i co dalej?

Moze bysmy usuneli:
- primitive-terminal-client
- funkcje "delete-forward!", "delete-backward!"
  oraz "insert-character!" z (editor-operations),
  zeby je moc zaimplementowac od nowa?

Nooo, tyle ze tam juz jakas funkcjonalnosc jest.

Mozemy zatem albo przeprowadzic analize tego,
co juz mamy, albo - w oparciu o wczesniejsza analize
- zaprojektowac to, co powinnismy miec.

Co dziwne, wydaje sie, ze niektore rzeczy
dzialaja.

* 19.01.2023

pozostale dwa punkty ze wtorkowej listy odhaczone

* 18.01.2023

pierwsy punkt z wczorajszej listy odhaczony.
teraz nam pozostaje dodac extend-selection
(usuwajac tego przykrego enuma)

* 17.01.2023

zadania na dzis/jutro:
- przetestowac desktop-client na asusie
  (i ew. ponaprawiac)
- uzupelnic mapy klawiatury
- dodac (shift left) oraz (shift right) jako ekspansje selekcji

* 14.01.2023

zbudowalismy juz zalazki map klawiatur dla
trzech klientow

teraz bysmy chcieli usunac stare zdarzenia
z modulu pane, i zastapic je nowymi

- bedzie to wymagalo translacji kodu
  zdarzenia do odpowiedniej postaci
  (w tym ustawienia parametru (unicode-input)
  tam gdzie to stosowne)

  w przypadku kazdego klienta bedzie to trzeba
  robic inaczej, i dlatego nalezy ustalic jakas
  kolejnosc:
  - najpierw klient terminalowy
  - po nim klient androidowy
  - a na koncu klient desktopowy
    (ktotego i tak nie mamy na razie jak
    przetestowac)

natomiast plany dlugofalowe:
+ skonczyc ta refaktoryzacje
+ zaimplementowac edycje
+ obsluga komentarzy (renderowanie i nawigacja)
+ obsluga uzytych rozszerzen Kawy/rezygnacja z nieuzytych rozszerzen
+ ladowanie i zapisywanie plikow; podzial ekranu
+ zgloszenie na ELS
+ mechanizm rozszerzen
+ poszczegolne rozszerzenia + sukcesywny rozwoj API do rysowania
+ evisulator
+ edytor grafow
+ obsluga selekcji (kopiowanie, wklejanie, usuwanie, historia)
+ naprawianie bledow (w tym zwiazanych z drag&dropem)
+ prezentacja na ELS
+ pierwsze wydanie, 2 aplikacje w sklepie
+ zgloszenie na StrangeLoop
+ siec spolecznosciowa

+ SICP - GRASP edition
+ The Little Schemer - GRASP edition
  (i podobnie: The Seasoned Schemer, The Reasoned Schemer)
+ The Dream Machine - GRASP edition
+ The Way Things Work - GRASP edition

+ The Art of Metaprogramming in Scheme

ok, tosmy sobie odplyneli

teraz do roboty: zmieniamy sposob obslugi
klawiszy w kliencie terminalowym - ale trzeba
jeszcze pomyslec co z obsluga myszy/wskaznikow

ok, klient terminalowy juz obskoczony.
teraz jeszcze tylko zostaje androidowy i desktopowy.

na razie sie zajmiemy androidowym

ok, wyglada na to ze to tez sie udalo.


* 13.01.2023

Mamy sobie 3 klienty. I teraz dla tych
3 klientow bedziemy chcieli zbudowac
moduly (android-key-map) (desktop-key-map)
oraz (teminal-key-map).

* 12.01.2023

No dobra, to teraz - zeby byla jasnosc - zaczynamy
od uwspolnionego systemu obslugi zdarzen, w ktorym
bedzie tylko zdarzenie 'key-typed', a funkcje beda
definiowane w pliku init.scm.

Na razie nie robmy hierarchicznej obslugi, bo to
moze byc overengineering.

Dopiero jak to bedzie gotowe, zajmiemy sie 'wstawianiem
znakow', ze szczegolnym uwzglednieniem aspektu historii
/cofania.

* 11.01.2023

trzeba obmyslic strategie implementacji
nowego podsystemu wprowadzania

W androidzie mamy:
getKeyCode(), getScanCode(), getMetaState()


w androidzie chcemy zmienic podsystem zdarzen
tak zeby na razie po prostu wypluwal zdarzenie
do logow


(active-pointers) ::(list-of int)

(pointer-position index::int) ::Position

(unicode-input)::char

w KeyboardEvent z awt mamy metode getKeyChar,
ktora zwraca kod albo CHAR_UNDEFINED.

(define-mapping (key-handler key-code)::(maps () to: void)
  (lambda ()::void
    (and-let* ((c (unicode-input)))
      (insert-character! c))))

Jeszcze trzeba rozwazyc opcje dodawania trybow,
tak zeby mozna bylo przeslaniac sobie tablice znakow
w roznych kontekstach.


(define-type (KeyMap bindings: (maps (key::int) to: () to: void)
                     parent: KeyMap))

* 10.01.2023

Wczorajszybi dzisiejszy dzien to glownie
walka z ewaluacja w kliencie androidowym
(i to trzeba odnotowac)


Jutro j pojutrze beda comity:
- ocpowiedziec na issue
- commitnw grasp-android

- zarchiwizowac grasp-android
- scomitowac zmiany tutaj

Na razie plan jest taki, ze chcemy
ujednolicic konfiguracje po stronie
androida, terminala i awt, szukajac
najwiekzzsgo wxpolnego mianownika

nastepnie bysmy te konfiguracje
przeniesli do init.scm

nastepnie bysmy juz zaczeli walke
z podpinaniem funkcji do edycji
dokumentu

fajnie by bylo to zrobic do konca
stycznia - i jeszcze obsluge
komentarzy w rendererze, oraz
otwieranie i zapisywanie plikow
oraz podzial ekranu

na pewno tez troche pracy bedzie
trzeba poswiecic zeby dopiescic
klienta awt

na dalszy ogien idzie mechanizm
rozszerzen oraz ewaluacja wyrazen
roraz juz partykularne rozszerzenia
(Img src: ...), wizualny ewaluator,
edytor grafow, chmura punktow

natomiast priorytetem powinno
byc doproeadzenie do sytuacji
w ktorej GRASP rozwijamy w GRASP,
a nie w Emacsie

----------------------------------

ok, to co teraz robimy?

trzeba bedzie rozehrac zdarzemia
z awt na kawalki

moze warto zrobic tabelke

|---------+------------+-------------+-----------|
| system  | press      | release     | type      |
|---------+------------+-------------+-----------|
| AWT     | keyPressed | keyReleasee | keyTyped  |
|---------+------------+-------------+-----------|
| Lantrna |            |             | readInput |
|---------+------------+-------------+-----------|
| Android | onKeyDown  | onKeyUp     |           |
|---------+------------+-------------+-----------|

Ok, i teraz co?

Teraz musimy odwzorowac klawisze i sekwencje
w ich nazwy. Na przyklad

(on-key '(ctrl alt shit x) cut-selection!)

czy cos

i teraz bysmy sobie zrobili takie cos,
ze tlumaczylibysmy sekwencje na wartosc
typu long, i systemy zdarzen w poszczegolnych
klientach robilyby to samo - i mielibysmy
tablice haszujaca, ktora mapuje nam
klawisze na odpowiednie procedury

Poniewaz jednak nie chcemy tracic
dotychczasowej funkcjonalnosci,
moze wypiszmy sobie jakie do tej porg
mielismy wiazania w poszczegolnych
klienach:

** klient terminalowy:

  (set! (on-key-press KeyType:ArrowLeft)
	(lambda ()
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowRight)
	(lambda ()
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyType:ArrowUp)
	move-cursor-up!)

  (set! (on-key-press KeyType:ArrowDown)
	move-cursor-down!)

  (set! (on-key-type #\x) exit)

** klient desktopowy

  (set! (on-key-press KeyEvent:VK_LEFT)
	(lambda _
	  (move-cursor-left!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_RIGHT)
	(lambda _
	  (move-cursor-right!
	   selection: (if (shift-pressed?)
			  SelectionAction:resize
			  SelectionAction:discard))))

  (set! (on-key-press KeyEvent:VK_UP)
	move-cursor-up!)

  (set! (on-key-press KeyEvent:VK_DOWN)
	move-cursor-down!)

  (set! (on-key-press KeyEvent:VK_Z)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:undo!)))))

  (set! (on-key-press KeyEvent:VK_Y)
	(lambda ()
	  (if (ctrl-pressed?)
	      (let ((history ::History (history (the-document))))
		(history:redo!)))))

** klient androidowy:

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_LEFT)
      (lambda _
	(move-cursor-left!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_RIGHT)
      (lambda _
	(move-cursor-right!
	 selection: (if (shift-pressed?)
			SelectionAction:resize
			SelectionAction:discard))))

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_UP)
      move-cursor-up!)

    (set! (on-key-press KeyEvent:KEYCODE_DPAD_DOWN)
      move-cursor-down!)


* 09.01.2023

wyglada na to, ze mamy takie problemy
implementacyjne:
- w wersji skompilowanej, init.scm musi
  ladowac moduly, z ktorych korzysta
- ale trzy klienty beda musialy definiowac
  on-key na swoj sposob
- ale czy rzeczywiscie?

Definicja on-key bedzie taka sama, tylko
sposob wywolania bedzie rozny.

Teraz trzeba:

- usunac key-pressed! i key-released! z (panel),
  moze tez zmienic nazwe na (pane)

- zrobic jakos tak, zeby wywolywac odpowiednia
  funkcje dla kazdego klienta

* 08.01.2023

plan jak na razie wyglada zacnie.

jego realizacje zaczelibysmy od tego, ze kazdy
klient wykonywalby plik init.scm - na poczatku
to moze byc po prostu wypisanie loga albo cos.

co wiecej, zmiany w kliencie desktopowym
i terminalowym mozemy robic na laptopie

* 07.01.2023

Usunelismy funkcje "insert!", ale jest pewien
problem z testowaniem - na telefonie mozemy
jedynie przetestowac dzialanie aplikacji
na telefon.

Poza tym jest jeszcze kwestia taka, ze chcielibysmy
zbudowac przenosny interfejs wwjscia/wyjscia
pomiedzy klientami - cos w rodzaju

(on-key '(ctrl z) undo!)

(on-key '(ctrl y) redo!)

i wowczas bysmy sobie zdefiniowali:

(on-key 'space insert-space!)

(on-key 'backspace delete-backward!)

(on-key 'delete delete-forward!)

(on-key 'enter insert-newline!)

(on-key 'left move-cursor-left!)

(on-key '(shift left) expand-selection-left!)

(on-key 'right move-cursor-right!)

(on-key '(shift right) expand-selection-right!)

Mielibysmy tez takie funkcje:

(active-pointers) ::int

(pointer-position index::int) ::Position

(unicode-input)::char

Bedziemy chcieli miec plik init.scm, zawierajacy
powyzsze definicje.

Od strony implementacyjniej bysmy chcieli miec:
- bezposrednia tablice
- tablice shift dla klawiszy sterujaych
- tablice ctrl
- tablice alt
- tablice ctrl+alt
- tablice ctrl+shift
- tablice alt+shift
- tablice ctrl+alt+shift

Albo nawet nie. Moze byc jedna tablica.

* 06.01.2023

Idealnie byloby, gdybysmy nie dodawali
zadnych nowych operacji, tylko poprzestali
na Move, Remove oraz Insert.

Dzielenie atomu odbywaloby sie na zasadzie
wstawienia spacji w atom, laczenie - na zasadzie
usuniecia spacji itd.

Trzeba to bedzie sobie rozpisac.
Move -> take-cell!, splice!
Remove -> take-cell!
Insert -> splice!

Trzeba bedzie pozmieniac nazwy:
1. insert! z modulu (history) na cos (to trywialna
   funkcja uzyta w jednym miejscu w (panel))
2. ze splice! na insert!
3. z take-cell! na extract!

I teraz: funkcje (nowe) insert! i extract!
bedziemy musieli zmienic tak, zeby dzialaly
w roznych konfiguracjach

(docelowo do extract! bedziemy chcieli
jeszcze dodac argument numeryczny, tak
zeby moc uzywac tej funkcji do obslugi
selekcji, zas splice! rowniez bedzie
trzeba do tego celu przysposobic)

No dobra, ale teraz chyba bedzie trzeba
rozwazyc

1. extract! [atom/pudelko z wnetrza pudelka]
   - juz obsluzone: wydobywamy element
     z wnetrza pudelka
2. extract! [spacje spomiedzy atomow]
   - laczymy dwa atomy w jeden3. extract! [spacje spomiedzy dwoch pudelek]
   - doklejamy drugie pudelko na koncu
     pierwszego
4. extract! [spacje spomiedzy dwoch tekstow]
   - laczymy teksty ze soba
5. extract! [z wnetrza atomu albo tekstu]
   - powinnismy usunac znak znajdujacy sie przed
     kursorem (jeden lub wiecej w przypadku selekcji)
6. extract! [spacje spomiedzy dwoch roznych typow]
   - nic nie robimy (zwracamy #!null)

i teraz insert! analogicznie:

1. splice! [lista do spacji]
   - juz obsluzone (wklejamy liste pomiedzy element
     poprzedzajacy spacjena kolejny element)
2. splice! [spacja do atomu]
   - rozbijamy atom na dwa
3. splice! [spacje do spacji]
   - to sie moze wydawac nieco nieintuicyjne,
     ale powinnismy rozbic jedno pudelko na dwa
     na elementach rozdzielanych przez spacje
4. splice! [spacje do tekstu]
   - tak jak w przypadkh atomow, powinnismy
     rozbic jeden tekst na dwa
5. splice! [lista znakow do atomu albo tekstu]
   - dodajemy znaki do atomu za kursorem

1. extract-tile! at: Cursor from: document
   splice-list! list at: Cursor into: document
2. merge-atoms! at: Cursor in: document
   split-atom! at: Cursor in: document
3. merge-boxes! at: Cursor in: document
   split-box! at: Cursor in: document
4. merge-texts! at: Cursor in document
   split-text! at: Cursor in: document
5. remove-characters! at: Cursor from: document
   insert-charactets! at: Cursor into: document

* 02.01.2023

Dwie pierwsze zmiany w nowym roku:
- archiwizacja grasp-android
- odpowiedziec na "issue" w nowym repo

Natomiast to, czym teraz bysmy sie chcieli
zajac, to edycja dokumentow z klawiatury,
czyli:

- jak piszemy [, to tworzymy nowe puste pudelko
- jak piszemy ]. to wychodzimy z pudelka

W kazdym razie to sie dzieje w kontekscie
pudelek - bo w przypadku Textu dla niesterujacych
znakow zawsze owe znaki dopisujemy (pewnym wyjatkiem
moze byc \, ale to jeszcze trzeba przemyslec)

- jak piszemy ", to tworzymy nowy Text

jak wciskamy znak drukowalny, to:
- jezeli jestesmy na spacji, to tworzymy
  nowy atom
- jezeli jestesmy na atomie, to dopisujemy
  znak

Wyjatki:
- wcisniecie spacji, gdy jestesmy na spacji,
  dodaje spacje pozioma
- wcisniecie entera dodaje spacje pionowa
- wcisniecie spacji albo entera na atomie
  powoduje rozbicie atomu (chyha ze jestesmy
  na ostatniej pozycji - wtedy edytujemy
  nastepujaca spacje)

Trzeba bedzie zaczac od napisanis testow
dla takiego czegos, oraz dodac odpowiednie
operacjendo historii edycji

Rowniez chcielibysmy obsluzyc dzialanie
klawisza backspace.

Jezeli idzie o historie, to mozemy zamodelowac:
- rozszczepienie atomu jako wstawienie spacji
- scalenie atomu jako usuniecie spacji

Dzieki temu nie musimy dodawac nowych operacji
do historii.

Mamy zatem do dodania nastepujace operacje:
